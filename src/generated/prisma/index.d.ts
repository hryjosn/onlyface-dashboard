
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model activity
 * 
 */
export type activity = $Result.DefaultSelection<Prisma.$activityPayload>
/**
 * Model block_user
 * 
 */
export type block_user = $Result.DefaultSelection<Prisma.$block_userPayload>
/**
 * Model chatroom
 * 
 */
export type chatroom = $Result.DefaultSelection<Prisma.$chatroomPayload>
/**
 * Model chatroom_member
 * 
 */
export type chatroom_member = $Result.DefaultSelection<Prisma.$chatroom_memberPayload>
/**
 * Model combo
 * 
 */
export type combo = $Result.DefaultSelection<Prisma.$comboPayload>
/**
 * Model comment
 * 
 */
export type comment = $Result.DefaultSelection<Prisma.$commentPayload>
/**
 * Model config
 * 
 */
export type config = $Result.DefaultSelection<Prisma.$configPayload>
/**
 * Model email_otp
 * 
 */
export type email_otp = $Result.DefaultSelection<Prisma.$email_otpPayload>
/**
 * Model followship
 * 
 */
export type followship = $Result.DefaultSelection<Prisma.$followshipPayload>
/**
 * Model guest
 * 
 */
export type guest = $Result.DefaultSelection<Prisma.$guestPayload>
/**
 * Model image_message
 * 
 */
export type image_message = $Result.DefaultSelection<Prisma.$image_messagePayload>
/**
 * Model invite
 * 
 */
export type invite = $Result.DefaultSelection<Prisma.$invitePayload>
/**
 * Model message
 * 
 */
export type message = $Result.DefaultSelection<Prisma.$messagePayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model post
 * 
 */
export type post = $Result.DefaultSelection<Prisma.$postPayload>
/**
 * Model post_like
 * 
 */
export type post_like = $Result.DefaultSelection<Prisma.$post_likePayload>
/**
 * Model praise
 * 
 */
export type praise = $Result.DefaultSelection<Prisma.$praisePayload>
/**
 * Model recycle_account
 * 
 */
export type recycle_account = $Result.DefaultSelection<Prisma.$recycle_accountPayload>
/**
 * Model report_post
 * 
 */
export type report_post = $Result.DefaultSelection<Prisma.$report_postPayload>
/**
 * Model reset_password
 * 
 */
export type reset_password = $Result.DefaultSelection<Prisma.$reset_passwordPayload>
/**
 * Model reward
 * 
 */
export type reward = $Result.DefaultSelection<Prisma.$rewardPayload>
/**
 * Model user
 * 
 */
export type user = $Result.DefaultSelection<Prisma.$userPayload>
/**
 * Model warning
 * 
 */
export type warning = $Result.DefaultSelection<Prisma.$warningPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Activities
 * const activities = await prisma.activity.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Activities
   * const activities = await prisma.activity.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.activity`: Exposes CRUD operations for the **activity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Activities
    * const activities = await prisma.activity.findMany()
    * ```
    */
  get activity(): Prisma.activityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block_user`: Exposes CRUD operations for the **block_user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Block_users
    * const block_users = await prisma.block_user.findMany()
    * ```
    */
  get block_user(): Prisma.block_userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatroom`: Exposes CRUD operations for the **chatroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatrooms
    * const chatrooms = await prisma.chatroom.findMany()
    * ```
    */
  get chatroom(): Prisma.chatroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatroom_member`: Exposes CRUD operations for the **chatroom_member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatroom_members
    * const chatroom_members = await prisma.chatroom_member.findMany()
    * ```
    */
  get chatroom_member(): Prisma.chatroom_memberDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.combo`: Exposes CRUD operations for the **combo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Combos
    * const combos = await prisma.combo.findMany()
    * ```
    */
  get combo(): Prisma.comboDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.commentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.config`: Exposes CRUD operations for the **config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configs
    * const configs = await prisma.config.findMany()
    * ```
    */
  get config(): Prisma.configDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.email_otp`: Exposes CRUD operations for the **email_otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Email_otps
    * const email_otps = await prisma.email_otp.findMany()
    * ```
    */
  get email_otp(): Prisma.email_otpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followship`: Exposes CRUD operations for the **followship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Followships
    * const followships = await prisma.followship.findMany()
    * ```
    */
  get followship(): Prisma.followshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.guest`: Exposes CRUD operations for the **guest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Guests
    * const guests = await prisma.guest.findMany()
    * ```
    */
  get guest(): Prisma.guestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image_message`: Exposes CRUD operations for the **image_message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Image_messages
    * const image_messages = await prisma.image_message.findMany()
    * ```
    */
  get image_message(): Prisma.image_messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.inviteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.messageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.postDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post_like`: Exposes CRUD operations for the **post_like** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Post_likes
    * const post_likes = await prisma.post_like.findMany()
    * ```
    */
  get post_like(): Prisma.post_likeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.praise`: Exposes CRUD operations for the **praise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Praises
    * const praises = await prisma.praise.findMany()
    * ```
    */
  get praise(): Prisma.praiseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.recycle_account`: Exposes CRUD operations for the **recycle_account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Recycle_accounts
    * const recycle_accounts = await prisma.recycle_account.findMany()
    * ```
    */
  get recycle_account(): Prisma.recycle_accountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.report_post`: Exposes CRUD operations for the **report_post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Report_posts
    * const report_posts = await prisma.report_post.findMany()
    * ```
    */
  get report_post(): Prisma.report_postDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reset_password`: Exposes CRUD operations for the **reset_password** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reset_passwords
    * const reset_passwords = await prisma.reset_password.findMany()
    * ```
    */
  get reset_password(): Prisma.reset_passwordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reward`: Exposes CRUD operations for the **reward** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rewards
    * const rewards = await prisma.reward.findMany()
    * ```
    */
  get reward(): Prisma.rewardDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.warning`: Exposes CRUD operations for the **warning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Warnings
    * const warnings = await prisma.warning.findMany()
    * ```
    */
  get warning(): Prisma.warningDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.12.0
   * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    activity: 'activity',
    block_user: 'block_user',
    chatroom: 'chatroom',
    chatroom_member: 'chatroom_member',
    combo: 'combo',
    comment: 'comment',
    config: 'config',
    email_otp: 'email_otp',
    followship: 'followship',
    guest: 'guest',
    image_message: 'image_message',
    invite: 'invite',
    message: 'message',
    migrations: 'migrations',
    post: 'post',
    post_like: 'post_like',
    praise: 'praise',
    recycle_account: 'recycle_account',
    report_post: 'report_post',
    reset_password: 'reset_password',
    reward: 'reward',
    user: 'user',
    warning: 'warning'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "activity" | "block_user" | "chatroom" | "chatroom_member" | "combo" | "comment" | "config" | "email_otp" | "followship" | "guest" | "image_message" | "invite" | "message" | "migrations" | "post" | "post_like" | "praise" | "recycle_account" | "report_post" | "reset_password" | "reward" | "user" | "warning"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      activity: {
        payload: Prisma.$activityPayload<ExtArgs>
        fields: Prisma.activityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.activityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.activityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          findFirst: {
            args: Prisma.activityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.activityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          findMany: {
            args: Prisma.activityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          create: {
            args: Prisma.activityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          createMany: {
            args: Prisma.activityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.activityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          delete: {
            args: Prisma.activityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          update: {
            args: Prisma.activityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          deleteMany: {
            args: Prisma.activityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.activityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.activityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>[]
          }
          upsert: {
            args: Prisma.activityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$activityPayload>
          }
          aggregate: {
            args: Prisma.ActivityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivity>
          }
          groupBy: {
            args: Prisma.activityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityGroupByOutputType>[]
          }
          count: {
            args: Prisma.activityCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityCountAggregateOutputType> | number
          }
        }
      }
      block_user: {
        payload: Prisma.$block_userPayload<ExtArgs>
        fields: Prisma.block_userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.block_userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.block_userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          findFirst: {
            args: Prisma.block_userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.block_userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          findMany: {
            args: Prisma.block_userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>[]
          }
          create: {
            args: Prisma.block_userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          createMany: {
            args: Prisma.block_userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.block_userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>[]
          }
          delete: {
            args: Prisma.block_userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          update: {
            args: Prisma.block_userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          deleteMany: {
            args: Prisma.block_userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.block_userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.block_userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>[]
          }
          upsert: {
            args: Prisma.block_userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$block_userPayload>
          }
          aggregate: {
            args: Prisma.Block_userAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock_user>
          }
          groupBy: {
            args: Prisma.block_userGroupByArgs<ExtArgs>
            result: $Utils.Optional<Block_userGroupByOutputType>[]
          }
          count: {
            args: Prisma.block_userCountArgs<ExtArgs>
            result: $Utils.Optional<Block_userCountAggregateOutputType> | number
          }
        }
      }
      chatroom: {
        payload: Prisma.$chatroomPayload<ExtArgs>
        fields: Prisma.chatroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findFirst: {
            args: Prisma.chatroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          findMany: {
            args: Prisma.chatroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          create: {
            args: Prisma.chatroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          createMany: {
            args: Prisma.chatroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          delete: {
            args: Prisma.chatroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          update: {
            args: Prisma.chatroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          deleteMany: {
            args: Prisma.chatroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>[]
          }
          upsert: {
            args: Prisma.chatroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroomPayload>
          }
          aggregate: {
            args: Prisma.ChatroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom>
          }
          groupBy: {
            args: Prisma.chatroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatroomCountArgs<ExtArgs>
            result: $Utils.Optional<ChatroomCountAggregateOutputType> | number
          }
        }
      }
      chatroom_member: {
        payload: Prisma.$chatroom_memberPayload<ExtArgs>
        fields: Prisma.chatroom_memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatroom_memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatroom_memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          findFirst: {
            args: Prisma.chatroom_memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatroom_memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          findMany: {
            args: Prisma.chatroom_memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>[]
          }
          create: {
            args: Prisma.chatroom_memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          createMany: {
            args: Prisma.chatroom_memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatroom_memberCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>[]
          }
          delete: {
            args: Prisma.chatroom_memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          update: {
            args: Prisma.chatroom_memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          deleteMany: {
            args: Prisma.chatroom_memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatroom_memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatroom_memberUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>[]
          }
          upsert: {
            args: Prisma.chatroom_memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatroom_memberPayload>
          }
          aggregate: {
            args: Prisma.Chatroom_memberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatroom_member>
          }
          groupBy: {
            args: Prisma.chatroom_memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chatroom_memberGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatroom_memberCountArgs<ExtArgs>
            result: $Utils.Optional<Chatroom_memberCountAggregateOutputType> | number
          }
        }
      }
      combo: {
        payload: Prisma.$comboPayload<ExtArgs>
        fields: Prisma.comboFieldRefs
        operations: {
          findUnique: {
            args: Prisma.comboFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.comboFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          findFirst: {
            args: Prisma.comboFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.comboFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          findMany: {
            args: Prisma.comboFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>[]
          }
          create: {
            args: Prisma.comboCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          createMany: {
            args: Prisma.comboCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.comboCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>[]
          }
          delete: {
            args: Prisma.comboDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          update: {
            args: Prisma.comboUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          deleteMany: {
            args: Prisma.comboDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.comboUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.comboUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>[]
          }
          upsert: {
            args: Prisma.comboUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$comboPayload>
          }
          aggregate: {
            args: Prisma.ComboAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCombo>
          }
          groupBy: {
            args: Prisma.comboGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComboGroupByOutputType>[]
          }
          count: {
            args: Prisma.comboCountArgs<ExtArgs>
            result: $Utils.Optional<ComboCountAggregateOutputType> | number
          }
        }
      }
      comment: {
        payload: Prisma.$commentPayload<ExtArgs>
        fields: Prisma.commentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.commentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.commentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          findFirst: {
            args: Prisma.commentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.commentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          findMany: {
            args: Prisma.commentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>[]
          }
          create: {
            args: Prisma.commentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          createMany: {
            args: Prisma.commentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.commentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>[]
          }
          delete: {
            args: Prisma.commentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          update: {
            args: Prisma.commentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          deleteMany: {
            args: Prisma.commentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.commentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.commentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>[]
          }
          upsert: {
            args: Prisma.commentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$commentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.commentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.commentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      config: {
        payload: Prisma.$configPayload<ExtArgs>
        fields: Prisma.configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findFirst: {
            args: Prisma.configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          findMany: {
            args: Prisma.configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          create: {
            args: Prisma.configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          createMany: {
            args: Prisma.configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.configCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          delete: {
            args: Prisma.configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          update: {
            args: Prisma.configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          deleteMany: {
            args: Prisma.configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.configUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>[]
          }
          upsert: {
            args: Prisma.configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$configPayload>
          }
          aggregate: {
            args: Prisma.ConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfig>
          }
          groupBy: {
            args: Prisma.configGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.configCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigCountAggregateOutputType> | number
          }
        }
      }
      email_otp: {
        payload: Prisma.$email_otpPayload<ExtArgs>
        fields: Prisma.email_otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.email_otpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.email_otpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          findFirst: {
            args: Prisma.email_otpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.email_otpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          findMany: {
            args: Prisma.email_otpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>[]
          }
          create: {
            args: Prisma.email_otpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          createMany: {
            args: Prisma.email_otpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.email_otpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>[]
          }
          delete: {
            args: Prisma.email_otpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          update: {
            args: Prisma.email_otpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          deleteMany: {
            args: Prisma.email_otpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.email_otpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.email_otpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>[]
          }
          upsert: {
            args: Prisma.email_otpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$email_otpPayload>
          }
          aggregate: {
            args: Prisma.Email_otpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmail_otp>
          }
          groupBy: {
            args: Prisma.email_otpGroupByArgs<ExtArgs>
            result: $Utils.Optional<Email_otpGroupByOutputType>[]
          }
          count: {
            args: Prisma.email_otpCountArgs<ExtArgs>
            result: $Utils.Optional<Email_otpCountAggregateOutputType> | number
          }
        }
      }
      followship: {
        payload: Prisma.$followshipPayload<ExtArgs>
        fields: Prisma.followshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.followshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.followshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          findFirst: {
            args: Prisma.followshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.followshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          findMany: {
            args: Prisma.followshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>[]
          }
          create: {
            args: Prisma.followshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          createMany: {
            args: Prisma.followshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.followshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>[]
          }
          delete: {
            args: Prisma.followshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          update: {
            args: Prisma.followshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          deleteMany: {
            args: Prisma.followshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.followshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.followshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>[]
          }
          upsert: {
            args: Prisma.followshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followshipPayload>
          }
          aggregate: {
            args: Prisma.FollowshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowship>
          }
          groupBy: {
            args: Prisma.followshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.followshipCountArgs<ExtArgs>
            result: $Utils.Optional<FollowshipCountAggregateOutputType> | number
          }
        }
      }
      guest: {
        payload: Prisma.$guestPayload<ExtArgs>
        fields: Prisma.guestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.guestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.guestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          findFirst: {
            args: Prisma.guestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.guestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          findMany: {
            args: Prisma.guestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>[]
          }
          create: {
            args: Prisma.guestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          createMany: {
            args: Prisma.guestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.guestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>[]
          }
          delete: {
            args: Prisma.guestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          update: {
            args: Prisma.guestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          deleteMany: {
            args: Prisma.guestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.guestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.guestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>[]
          }
          upsert: {
            args: Prisma.guestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$guestPayload>
          }
          aggregate: {
            args: Prisma.GuestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGuest>
          }
          groupBy: {
            args: Prisma.guestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GuestGroupByOutputType>[]
          }
          count: {
            args: Prisma.guestCountArgs<ExtArgs>
            result: $Utils.Optional<GuestCountAggregateOutputType> | number
          }
        }
      }
      image_message: {
        payload: Prisma.$image_messagePayload<ExtArgs>
        fields: Prisma.image_messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.image_messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.image_messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          findFirst: {
            args: Prisma.image_messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.image_messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          findMany: {
            args: Prisma.image_messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>[]
          }
          create: {
            args: Prisma.image_messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          createMany: {
            args: Prisma.image_messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.image_messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>[]
          }
          delete: {
            args: Prisma.image_messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          update: {
            args: Prisma.image_messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          deleteMany: {
            args: Prisma.image_messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.image_messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.image_messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>[]
          }
          upsert: {
            args: Prisma.image_messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$image_messagePayload>
          }
          aggregate: {
            args: Prisma.Image_messageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage_message>
          }
          groupBy: {
            args: Prisma.image_messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<Image_messageGroupByOutputType>[]
          }
          count: {
            args: Prisma.image_messageCountArgs<ExtArgs>
            result: $Utils.Optional<Image_messageCountAggregateOutputType> | number
          }
        }
      }
      invite: {
        payload: Prisma.$invitePayload<ExtArgs>
        fields: Prisma.inviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.inviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.inviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          findFirst: {
            args: Prisma.inviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.inviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          findMany: {
            args: Prisma.inviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>[]
          }
          create: {
            args: Prisma.inviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          createMany: {
            args: Prisma.inviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.inviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>[]
          }
          delete: {
            args: Prisma.inviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          update: {
            args: Prisma.inviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          deleteMany: {
            args: Prisma.inviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.inviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.inviteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>[]
          }
          upsert: {
            args: Prisma.inviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.inviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.inviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      message: {
        payload: Prisma.$messagePayload<ExtArgs>
        fields: Prisma.messageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findFirst: {
            args: Prisma.messageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          findMany: {
            args: Prisma.messageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          create: {
            args: Prisma.messageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          createMany: {
            args: Prisma.messageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          delete: {
            args: Prisma.messageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          update: {
            args: Prisma.messageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          deleteMany: {
            args: Prisma.messageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>[]
          }
          upsert: {
            args: Prisma.messageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.messageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      post: {
        payload: Prisma.$postPayload<ExtArgs>
        fields: Prisma.postFieldRefs
        operations: {
          findUnique: {
            args: Prisma.postFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.postFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          findFirst: {
            args: Prisma.postFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.postFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          findMany: {
            args: Prisma.postFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          create: {
            args: Prisma.postCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          createMany: {
            args: Prisma.postCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.postCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          delete: {
            args: Prisma.postDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          update: {
            args: Prisma.postUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          deleteMany: {
            args: Prisma.postDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.postUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.postUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>[]
          }
          upsert: {
            args: Prisma.postUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$postPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.postGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.postCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      post_like: {
        payload: Prisma.$post_likePayload<ExtArgs>
        fields: Prisma.post_likeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.post_likeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.post_likeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          findFirst: {
            args: Prisma.post_likeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.post_likeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          findMany: {
            args: Prisma.post_likeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>[]
          }
          create: {
            args: Prisma.post_likeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          createMany: {
            args: Prisma.post_likeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.post_likeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>[]
          }
          delete: {
            args: Prisma.post_likeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          update: {
            args: Prisma.post_likeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          deleteMany: {
            args: Prisma.post_likeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.post_likeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.post_likeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>[]
          }
          upsert: {
            args: Prisma.post_likeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$post_likePayload>
          }
          aggregate: {
            args: Prisma.Post_likeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost_like>
          }
          groupBy: {
            args: Prisma.post_likeGroupByArgs<ExtArgs>
            result: $Utils.Optional<Post_likeGroupByOutputType>[]
          }
          count: {
            args: Prisma.post_likeCountArgs<ExtArgs>
            result: $Utils.Optional<Post_likeCountAggregateOutputType> | number
          }
        }
      }
      praise: {
        payload: Prisma.$praisePayload<ExtArgs>
        fields: Prisma.praiseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.praiseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.praiseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          findFirst: {
            args: Prisma.praiseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.praiseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          findMany: {
            args: Prisma.praiseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>[]
          }
          create: {
            args: Prisma.praiseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          createMany: {
            args: Prisma.praiseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.praiseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>[]
          }
          delete: {
            args: Prisma.praiseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          update: {
            args: Prisma.praiseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          deleteMany: {
            args: Prisma.praiseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.praiseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.praiseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>[]
          }
          upsert: {
            args: Prisma.praiseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$praisePayload>
          }
          aggregate: {
            args: Prisma.PraiseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePraise>
          }
          groupBy: {
            args: Prisma.praiseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PraiseGroupByOutputType>[]
          }
          count: {
            args: Prisma.praiseCountArgs<ExtArgs>
            result: $Utils.Optional<PraiseCountAggregateOutputType> | number
          }
        }
      }
      recycle_account: {
        payload: Prisma.$recycle_accountPayload<ExtArgs>
        fields: Prisma.recycle_accountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recycle_accountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recycle_accountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          findFirst: {
            args: Prisma.recycle_accountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recycle_accountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          findMany: {
            args: Prisma.recycle_accountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>[]
          }
          create: {
            args: Prisma.recycle_accountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          createMany: {
            args: Prisma.recycle_accountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recycle_accountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>[]
          }
          delete: {
            args: Prisma.recycle_accountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          update: {
            args: Prisma.recycle_accountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          deleteMany: {
            args: Prisma.recycle_accountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recycle_accountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recycle_accountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>[]
          }
          upsert: {
            args: Prisma.recycle_accountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recycle_accountPayload>
          }
          aggregate: {
            args: Prisma.Recycle_accountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecycle_account>
          }
          groupBy: {
            args: Prisma.recycle_accountGroupByArgs<ExtArgs>
            result: $Utils.Optional<Recycle_accountGroupByOutputType>[]
          }
          count: {
            args: Prisma.recycle_accountCountArgs<ExtArgs>
            result: $Utils.Optional<Recycle_accountCountAggregateOutputType> | number
          }
        }
      }
      report_post: {
        payload: Prisma.$report_postPayload<ExtArgs>
        fields: Prisma.report_postFieldRefs
        operations: {
          findUnique: {
            args: Prisma.report_postFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.report_postFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          findFirst: {
            args: Prisma.report_postFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.report_postFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          findMany: {
            args: Prisma.report_postFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>[]
          }
          create: {
            args: Prisma.report_postCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          createMany: {
            args: Prisma.report_postCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.report_postCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>[]
          }
          delete: {
            args: Prisma.report_postDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          update: {
            args: Prisma.report_postUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          deleteMany: {
            args: Prisma.report_postDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.report_postUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.report_postUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>[]
          }
          upsert: {
            args: Prisma.report_postUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$report_postPayload>
          }
          aggregate: {
            args: Prisma.Report_postAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport_post>
          }
          groupBy: {
            args: Prisma.report_postGroupByArgs<ExtArgs>
            result: $Utils.Optional<Report_postGroupByOutputType>[]
          }
          count: {
            args: Prisma.report_postCountArgs<ExtArgs>
            result: $Utils.Optional<Report_postCountAggregateOutputType> | number
          }
        }
      }
      reset_password: {
        payload: Prisma.$reset_passwordPayload<ExtArgs>
        fields: Prisma.reset_passwordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.reset_passwordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.reset_passwordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          findFirst: {
            args: Prisma.reset_passwordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.reset_passwordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          findMany: {
            args: Prisma.reset_passwordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>[]
          }
          create: {
            args: Prisma.reset_passwordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          createMany: {
            args: Prisma.reset_passwordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.reset_passwordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>[]
          }
          delete: {
            args: Prisma.reset_passwordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          update: {
            args: Prisma.reset_passwordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          deleteMany: {
            args: Prisma.reset_passwordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.reset_passwordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.reset_passwordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>[]
          }
          upsert: {
            args: Prisma.reset_passwordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$reset_passwordPayload>
          }
          aggregate: {
            args: Prisma.Reset_passwordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReset_password>
          }
          groupBy: {
            args: Prisma.reset_passwordGroupByArgs<ExtArgs>
            result: $Utils.Optional<Reset_passwordGroupByOutputType>[]
          }
          count: {
            args: Prisma.reset_passwordCountArgs<ExtArgs>
            result: $Utils.Optional<Reset_passwordCountAggregateOutputType> | number
          }
        }
      }
      reward: {
        payload: Prisma.$rewardPayload<ExtArgs>
        fields: Prisma.rewardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rewardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rewardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          findFirst: {
            args: Prisma.rewardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rewardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          findMany: {
            args: Prisma.rewardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          create: {
            args: Prisma.rewardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          createMany: {
            args: Prisma.rewardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rewardCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          delete: {
            args: Prisma.rewardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          update: {
            args: Prisma.rewardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          deleteMany: {
            args: Prisma.rewardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rewardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rewardUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>[]
          }
          upsert: {
            args: Prisma.rewardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rewardPayload>
          }
          aggregate: {
            args: Prisma.RewardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReward>
          }
          groupBy: {
            args: Prisma.rewardGroupByArgs<ExtArgs>
            result: $Utils.Optional<RewardGroupByOutputType>[]
          }
          count: {
            args: Prisma.rewardCountArgs<ExtArgs>
            result: $Utils.Optional<RewardCountAggregateOutputType> | number
          }
        }
      }
      user: {
        payload: Prisma.$userPayload<ExtArgs>
        fields: Prisma.userFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findFirst: {
            args: Prisma.userFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          findMany: {
            args: Prisma.userFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          create: {
            args: Prisma.userCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          createMany: {
            args: Prisma.userCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          delete: {
            args: Prisma.userDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          update: {
            args: Prisma.userUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          deleteMany: {
            args: Prisma.userDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>[]
          }
          upsert: {
            args: Prisma.userUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.userGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.userCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      warning: {
        payload: Prisma.$warningPayload<ExtArgs>
        fields: Prisma.warningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.warningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.warningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          findFirst: {
            args: Prisma.warningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.warningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          findMany: {
            args: Prisma.warningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>[]
          }
          create: {
            args: Prisma.warningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          createMany: {
            args: Prisma.warningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.warningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>[]
          }
          delete: {
            args: Prisma.warningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          update: {
            args: Prisma.warningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          deleteMany: {
            args: Prisma.warningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.warningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.warningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>[]
          }
          upsert: {
            args: Prisma.warningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$warningPayload>
          }
          aggregate: {
            args: Prisma.WarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWarning>
          }
          groupBy: {
            args: Prisma.warningGroupByArgs<ExtArgs>
            result: $Utils.Optional<WarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.warningCountArgs<ExtArgs>
            result: $Utils.Optional<WarningCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    activity?: activityOmit
    block_user?: block_userOmit
    chatroom?: chatroomOmit
    chatroom_member?: chatroom_memberOmit
    combo?: comboOmit
    comment?: commentOmit
    config?: configOmit
    email_otp?: email_otpOmit
    followship?: followshipOmit
    guest?: guestOmit
    image_message?: image_messageOmit
    invite?: inviteOmit
    message?: messageOmit
    migrations?: migrationsOmit
    post?: postOmit
    post_like?: post_likeOmit
    praise?: praiseOmit
    recycle_account?: recycle_accountOmit
    report_post?: report_postOmit
    reset_password?: reset_passwordOmit
    reward?: rewardOmit
    user?: userOmit
    warning?: warningOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChatroomCountOutputType
   */

  export type ChatroomCountOutputType = {
    chatroom_member: number
    message: number
  }

  export type ChatroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom_member?: boolean | ChatroomCountOutputTypeCountChatroom_memberArgs
    message?: boolean | ChatroomCountOutputTypeCountMessageArgs
  }

  // Custom InputTypes
  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatroomCountOutputType
     */
    select?: ChatroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountChatroom_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroom_memberWhereInput
  }

  /**
   * ChatroomCountOutputType without action
   */
  export type ChatroomCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }


  /**
   * Count Type GuestCountOutputType
   */

  export type GuestCountOutputType = {
    activity_activity_subscriberIdToguest: number
    activity_activity_guestIdToguest: number
    invite_invite_inviterIdToguest: number
    praise: number
    reward: number
  }

  export type GuestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_activity_subscriberIdToguest?: boolean | GuestCountOutputTypeCountActivity_activity_subscriberIdToguestArgs
    activity_activity_guestIdToguest?: boolean | GuestCountOutputTypeCountActivity_activity_guestIdToguestArgs
    invite_invite_inviterIdToguest?: boolean | GuestCountOutputTypeCountInvite_invite_inviterIdToguestArgs
    praise?: boolean | GuestCountOutputTypeCountPraiseArgs
    reward?: boolean | GuestCountOutputTypeCountRewardArgs
  }

  // Custom InputTypes
  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GuestCountOutputType
     */
    select?: GuestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountActivity_activity_subscriberIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountActivity_activity_guestIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountInvite_invite_inviterIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inviteWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountPraiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: praiseWhereInput
  }

  /**
   * GuestCountOutputType without action
   */
  export type GuestCountOutputTypeCountRewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    image_message: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image_message?: boolean | MessageCountOutputTypeCountImage_messageArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountImage_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: image_messageWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    combo: number
    comment: number
    post_like: number
    report_post: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    combo?: boolean | PostCountOutputTypeCountComboArgs
    comment?: boolean | PostCountOutputTypeCountCommentArgs
    post_like?: boolean | PostCountOutputTypeCountPost_likeArgs
    report_post?: boolean | PostCountOutputTypeCountReport_postArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountComboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comboWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountPost_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_likeWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReport_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_postWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    block_user_block_user_blockerIdTouser: number
    block_user_block_user_blockedIdTouser: number
    chatroom_member: number
    combo: number
    comment: number
    followship_followship_followerIdTouser: number
    followship_followship_followedIdTouser: number
    message: number
    post: number
    post_like: number
    praise: number
    report_post: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block_user_block_user_blockerIdTouser?: boolean | UserCountOutputTypeCountBlock_user_block_user_blockerIdTouserArgs
    block_user_block_user_blockedIdTouser?: boolean | UserCountOutputTypeCountBlock_user_block_user_blockedIdTouserArgs
    chatroom_member?: boolean | UserCountOutputTypeCountChatroom_memberArgs
    combo?: boolean | UserCountOutputTypeCountComboArgs
    comment?: boolean | UserCountOutputTypeCountCommentArgs
    followship_followship_followerIdTouser?: boolean | UserCountOutputTypeCountFollowship_followship_followerIdTouserArgs
    followship_followship_followedIdTouser?: boolean | UserCountOutputTypeCountFollowship_followship_followedIdTouserArgs
    message?: boolean | UserCountOutputTypeCountMessageArgs
    post?: boolean | UserCountOutputTypeCountPostArgs
    post_like?: boolean | UserCountOutputTypeCountPost_likeArgs
    praise?: boolean | UserCountOutputTypeCountPraiseArgs
    report_post?: boolean | UserCountOutputTypeCountReport_postArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlock_user_block_user_blockerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: block_userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlock_user_block_user_blockedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: block_userWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatroom_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroom_memberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comboWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowship_followship_followerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFollowship_followship_followedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followshipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPost_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_likeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPraiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: praiseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReport_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_postWhereInput
  }


  /**
   * Models
   */

  /**
   * Model activity
   */

  export type AggregateActivity = {
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  export type ActivityMinAggregateOutputType = {
    id: string | null
    content: string | null
    route: string | null
    param: string | null
    subscriber_avatar: string | null
    post_image: string | null
    type: string | null
    created_at: Date | null
    guestId: string | null
    subscriberId: string | null
  }

  export type ActivityMaxAggregateOutputType = {
    id: string | null
    content: string | null
    route: string | null
    param: string | null
    subscriber_avatar: string | null
    post_image: string | null
    type: string | null
    created_at: Date | null
    guestId: string | null
    subscriberId: string | null
  }

  export type ActivityCountAggregateOutputType = {
    id: number
    content: number
    route: number
    param: number
    subscriber_avatar: number
    post_image: number
    type: number
    created_at: number
    guestId: number
    subscriberId: number
    _all: number
  }


  export type ActivityMinAggregateInputType = {
    id?: true
    content?: true
    route?: true
    param?: true
    subscriber_avatar?: true
    post_image?: true
    type?: true
    created_at?: true
    guestId?: true
    subscriberId?: true
  }

  export type ActivityMaxAggregateInputType = {
    id?: true
    content?: true
    route?: true
    param?: true
    subscriber_avatar?: true
    post_image?: true
    type?: true
    created_at?: true
    guestId?: true
    subscriberId?: true
  }

  export type ActivityCountAggregateInputType = {
    id?: true
    content?: true
    route?: true
    param?: true
    subscriber_avatar?: true
    post_image?: true
    type?: true
    created_at?: true
    guestId?: true
    subscriberId?: true
    _all?: true
  }

  export type ActivityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activity to aggregate.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned activities
    **/
    _count?: true | ActivityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityMaxAggregateInputType
  }

  export type GetActivityAggregateType<T extends ActivityAggregateArgs> = {
        [P in keyof T & keyof AggregateActivity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivity[P]>
      : GetScalarType<T[P], AggregateActivity[P]>
  }




  export type activityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: activityWhereInput
    orderBy?: activityOrderByWithAggregationInput | activityOrderByWithAggregationInput[]
    by: ActivityScalarFieldEnum[] | ActivityScalarFieldEnum
    having?: activityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityCountAggregateInputType | true
    _min?: ActivityMinAggregateInputType
    _max?: ActivityMaxAggregateInputType
  }

  export type ActivityGroupByOutputType = {
    id: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at: Date
    guestId: string | null
    subscriberId: string | null
    _count: ActivityCountAggregateOutputType | null
    _min: ActivityMinAggregateOutputType | null
    _max: ActivityMaxAggregateOutputType | null
  }

  type GetActivityGroupByPayload<T extends activityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityGroupByOutputType[P]>
        }
      >
    >


  export type activitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    route?: boolean
    param?: boolean
    subscriber_avatar?: boolean
    post_image?: boolean
    type?: boolean
    created_at?: boolean
    guestId?: boolean
    subscriberId?: boolean
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    route?: boolean
    param?: boolean
    subscriber_avatar?: boolean
    post_image?: boolean
    type?: boolean
    created_at?: boolean
    guestId?: boolean
    subscriberId?: boolean
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    route?: boolean
    param?: boolean
    subscriber_avatar?: boolean
    post_image?: boolean
    type?: boolean
    created_at?: boolean
    guestId?: boolean
    subscriberId?: boolean
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["activity"]>

  export type activitySelectScalar = {
    id?: boolean
    content?: boolean
    route?: boolean
    param?: boolean
    subscriber_avatar?: boolean
    post_image?: boolean
    type?: boolean
    created_at?: boolean
    guestId?: boolean
    subscriberId?: boolean
  }

  export type activityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "route" | "param" | "subscriber_avatar" | "post_image" | "type" | "created_at" | "guestId" | "subscriberId", ExtArgs["result"]["activity"]>
  export type activityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }
  export type activityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }
  export type activityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_activity_subscriberIdToguest?: boolean | activity$guest_activity_subscriberIdToguestArgs<ExtArgs>
    guest_activity_guestIdToguest?: boolean | activity$guest_activity_guestIdToguestArgs<ExtArgs>
  }

  export type $activityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "activity"
    objects: {
      guest_activity_subscriberIdToguest: Prisma.$guestPayload<ExtArgs> | null
      guest_activity_guestIdToguest: Prisma.$guestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      route: string
      param: string
      subscriber_avatar: string
      post_image: string
      type: string
      created_at: Date
      guestId: string | null
      subscriberId: string | null
    }, ExtArgs["result"]["activity"]>
    composites: {}
  }

  type activityGetPayload<S extends boolean | null | undefined | activityDefaultArgs> = $Result.GetResult<Prisma.$activityPayload, S>

  type activityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<activityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityCountAggregateInputType | true
    }

  export interface activityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['activity'], meta: { name: 'activity' } }
    /**
     * Find zero or one Activity that matches the filter.
     * @param {activityFindUniqueArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends activityFindUniqueArgs>(args: SelectSubset<T, activityFindUniqueArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Activity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {activityFindUniqueOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends activityFindUniqueOrThrowArgs>(args: SelectSubset<T, activityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindFirstArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends activityFindFirstArgs>(args?: SelectSubset<T, activityFindFirstArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Activity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindFirstOrThrowArgs} args - Arguments to find a Activity
     * @example
     * // Get one Activity
     * const activity = await prisma.activity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends activityFindFirstOrThrowArgs>(args?: SelectSubset<T, activityFindFirstOrThrowArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Activities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Activities
     * const activities = await prisma.activity.findMany()
     * 
     * // Get first 10 Activities
     * const activities = await prisma.activity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityWithIdOnly = await prisma.activity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends activityFindManyArgs>(args?: SelectSubset<T, activityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Activity.
     * @param {activityCreateArgs} args - Arguments to create a Activity.
     * @example
     * // Create one Activity
     * const Activity = await prisma.activity.create({
     *   data: {
     *     // ... data to create a Activity
     *   }
     * })
     * 
     */
    create<T extends activityCreateArgs>(args: SelectSubset<T, activityCreateArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Activities.
     * @param {activityCreateManyArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends activityCreateManyArgs>(args?: SelectSubset<T, activityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Activities and returns the data saved in the database.
     * @param {activityCreateManyAndReturnArgs} args - Arguments to create many Activities.
     * @example
     * // Create many Activities
     * const activity = await prisma.activity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends activityCreateManyAndReturnArgs>(args?: SelectSubset<T, activityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Activity.
     * @param {activityDeleteArgs} args - Arguments to delete one Activity.
     * @example
     * // Delete one Activity
     * const Activity = await prisma.activity.delete({
     *   where: {
     *     // ... filter to delete one Activity
     *   }
     * })
     * 
     */
    delete<T extends activityDeleteArgs>(args: SelectSubset<T, activityDeleteArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Activity.
     * @param {activityUpdateArgs} args - Arguments to update one Activity.
     * @example
     * // Update one Activity
     * const activity = await prisma.activity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends activityUpdateArgs>(args: SelectSubset<T, activityUpdateArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Activities.
     * @param {activityDeleteManyArgs} args - Arguments to filter Activities to delete.
     * @example
     * // Delete a few Activities
     * const { count } = await prisma.activity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends activityDeleteManyArgs>(args?: SelectSubset<T, activityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends activityUpdateManyArgs>(args: SelectSubset<T, activityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Activities and returns the data updated in the database.
     * @param {activityUpdateManyAndReturnArgs} args - Arguments to update many Activities.
     * @example
     * // Update many Activities
     * const activity = await prisma.activity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Activities and only return the `id`
     * const activityWithIdOnly = await prisma.activity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends activityUpdateManyAndReturnArgs>(args: SelectSubset<T, activityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Activity.
     * @param {activityUpsertArgs} args - Arguments to update or create a Activity.
     * @example
     * // Update or create a Activity
     * const activity = await prisma.activity.upsert({
     *   create: {
     *     // ... data to create a Activity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Activity we want to update
     *   }
     * })
     */
    upsert<T extends activityUpsertArgs>(args: SelectSubset<T, activityUpsertArgs<ExtArgs>>): Prisma__activityClient<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Activities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityCountArgs} args - Arguments to filter Activities to count.
     * @example
     * // Count the number of Activities
     * const count = await prisma.activity.count({
     *   where: {
     *     // ... the filter for the Activities we want to count
     *   }
     * })
    **/
    count<T extends activityCountArgs>(
      args?: Subset<T, activityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityAggregateArgs>(args: Subset<T, ActivityAggregateArgs>): Prisma.PrismaPromise<GetActivityAggregateType<T>>

    /**
     * Group by Activity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {activityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends activityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: activityGroupByArgs['orderBy'] }
        : { orderBy?: activityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, activityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the activity model
   */
  readonly fields: activityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for activity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__activityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest_activity_subscriberIdToguest<T extends activity$guest_activity_subscriberIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, activity$guest_activity_subscriberIdToguestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guest_activity_guestIdToguest<T extends activity$guest_activity_guestIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, activity$guest_activity_guestIdToguestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the activity model
   */
  interface activityFieldRefs {
    readonly id: FieldRef<"activity", 'String'>
    readonly content: FieldRef<"activity", 'String'>
    readonly route: FieldRef<"activity", 'String'>
    readonly param: FieldRef<"activity", 'String'>
    readonly subscriber_avatar: FieldRef<"activity", 'String'>
    readonly post_image: FieldRef<"activity", 'String'>
    readonly type: FieldRef<"activity", 'String'>
    readonly created_at: FieldRef<"activity", 'DateTime'>
    readonly guestId: FieldRef<"activity", 'String'>
    readonly subscriberId: FieldRef<"activity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * activity findUnique
   */
  export type activityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity findUniqueOrThrow
   */
  export type activityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity findFirst
   */
  export type activityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity findFirstOrThrow
   */
  export type activityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activity to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of activities.
     */
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity findMany
   */
  export type activityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter, which activities to fetch.
     */
    where?: activityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of activities to fetch.
     */
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing activities.
     */
    cursor?: activityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` activities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` activities.
     */
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * activity create
   */
  export type activityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The data needed to create a activity.
     */
    data: XOR<activityCreateInput, activityUncheckedCreateInput>
  }

  /**
   * activity createMany
   */
  export type activityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many activities.
     */
    data: activityCreateManyInput | activityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * activity createManyAndReturn
   */
  export type activityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * The data used to create many activities.
     */
    data: activityCreateManyInput | activityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * activity update
   */
  export type activityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The data needed to update a activity.
     */
    data: XOR<activityUpdateInput, activityUncheckedUpdateInput>
    /**
     * Choose, which activity to update.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity updateMany
   */
  export type activityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update activities.
     */
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
  }

  /**
   * activity updateManyAndReturn
   */
  export type activityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * The data used to update activities.
     */
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyInput>
    /**
     * Filter which activities to update
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * activity upsert
   */
  export type activityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * The filter to search for the activity to update in case it exists.
     */
    where: activityWhereUniqueInput
    /**
     * In case the activity found by the `where` argument doesn't exist, create a new activity with this data.
     */
    create: XOR<activityCreateInput, activityUncheckedCreateInput>
    /**
     * In case the activity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<activityUpdateInput, activityUncheckedUpdateInput>
  }

  /**
   * activity delete
   */
  export type activityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    /**
     * Filter which activity to delete.
     */
    where: activityWhereUniqueInput
  }

  /**
   * activity deleteMany
   */
  export type activityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which activities to delete
     */
    where?: activityWhereInput
    /**
     * Limit how many activities to delete.
     */
    limit?: number
  }

  /**
   * activity.guest_activity_subscriberIdToguest
   */
  export type activity$guest_activity_subscriberIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * activity.guest_activity_guestIdToguest
   */
  export type activity$guest_activity_guestIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * activity without action
   */
  export type activityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
  }


  /**
   * Model block_user
   */

  export type AggregateBlock_user = {
    _count: Block_userCountAggregateOutputType | null
    _min: Block_userMinAggregateOutputType | null
    _max: Block_userMaxAggregateOutputType | null
  }

  export type Block_userMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    blockerId: string | null
    blockedId: string | null
  }

  export type Block_userMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    blockerId: string | null
    blockedId: string | null
  }

  export type Block_userCountAggregateOutputType = {
    id: number
    created_at: number
    blockerId: number
    blockedId: number
    _all: number
  }


  export type Block_userMinAggregateInputType = {
    id?: true
    created_at?: true
    blockerId?: true
    blockedId?: true
  }

  export type Block_userMaxAggregateInputType = {
    id?: true
    created_at?: true
    blockerId?: true
    blockedId?: true
  }

  export type Block_userCountAggregateInputType = {
    id?: true
    created_at?: true
    blockerId?: true
    blockedId?: true
    _all?: true
  }

  export type Block_userAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which block_user to aggregate.
     */
    where?: block_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_users to fetch.
     */
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: block_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned block_users
    **/
    _count?: true | Block_userCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Block_userMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Block_userMaxAggregateInputType
  }

  export type GetBlock_userAggregateType<T extends Block_userAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock_user]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock_user[P]>
      : GetScalarType<T[P], AggregateBlock_user[P]>
  }




  export type block_userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: block_userWhereInput
    orderBy?: block_userOrderByWithAggregationInput | block_userOrderByWithAggregationInput[]
    by: Block_userScalarFieldEnum[] | Block_userScalarFieldEnum
    having?: block_userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Block_userCountAggregateInputType | true
    _min?: Block_userMinAggregateInputType
    _max?: Block_userMaxAggregateInputType
  }

  export type Block_userGroupByOutputType = {
    id: string
    created_at: Date
    blockerId: string | null
    blockedId: string | null
    _count: Block_userCountAggregateOutputType | null
    _min: Block_userMinAggregateOutputType | null
    _max: Block_userMaxAggregateOutputType | null
  }

  type GetBlock_userGroupByPayload<T extends block_userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Block_userGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Block_userGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Block_userGroupByOutputType[P]>
            : GetScalarType<T[P], Block_userGroupByOutputType[P]>
        }
      >
    >


  export type block_userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    blockerId?: boolean
    blockedId?: boolean
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["block_user"]>

  export type block_userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    blockerId?: boolean
    blockedId?: boolean
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["block_user"]>

  export type block_userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    blockerId?: boolean
    blockedId?: boolean
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["block_user"]>

  export type block_userSelectScalar = {
    id?: boolean
    created_at?: boolean
    blockerId?: boolean
    blockedId?: boolean
  }

  export type block_userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "blockerId" | "blockedId", ExtArgs["result"]["block_user"]>
  export type block_userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }
  export type block_userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }
  export type block_userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_block_user_blockerIdTouser?: boolean | block_user$user_block_user_blockerIdTouserArgs<ExtArgs>
    user_block_user_blockedIdTouser?: boolean | block_user$user_block_user_blockedIdTouserArgs<ExtArgs>
  }

  export type $block_userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "block_user"
    objects: {
      user_block_user_blockerIdTouser: Prisma.$userPayload<ExtArgs> | null
      user_block_user_blockedIdTouser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      blockerId: string | null
      blockedId: string | null
    }, ExtArgs["result"]["block_user"]>
    composites: {}
  }

  type block_userGetPayload<S extends boolean | null | undefined | block_userDefaultArgs> = $Result.GetResult<Prisma.$block_userPayload, S>

  type block_userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<block_userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Block_userCountAggregateInputType | true
    }

  export interface block_userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['block_user'], meta: { name: 'block_user' } }
    /**
     * Find zero or one Block_user that matches the filter.
     * @param {block_userFindUniqueArgs} args - Arguments to find a Block_user
     * @example
     * // Get one Block_user
     * const block_user = await prisma.block_user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends block_userFindUniqueArgs>(args: SelectSubset<T, block_userFindUniqueArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block_user that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {block_userFindUniqueOrThrowArgs} args - Arguments to find a Block_user
     * @example
     * // Get one Block_user
     * const block_user = await prisma.block_user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends block_userFindUniqueOrThrowArgs>(args: SelectSubset<T, block_userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block_user that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userFindFirstArgs} args - Arguments to find a Block_user
     * @example
     * // Get one Block_user
     * const block_user = await prisma.block_user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends block_userFindFirstArgs>(args?: SelectSubset<T, block_userFindFirstArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block_user that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userFindFirstOrThrowArgs} args - Arguments to find a Block_user
     * @example
     * // Get one Block_user
     * const block_user = await prisma.block_user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends block_userFindFirstOrThrowArgs>(args?: SelectSubset<T, block_userFindFirstOrThrowArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Block_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Block_users
     * const block_users = await prisma.block_user.findMany()
     * 
     * // Get first 10 Block_users
     * const block_users = await prisma.block_user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const block_userWithIdOnly = await prisma.block_user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends block_userFindManyArgs>(args?: SelectSubset<T, block_userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block_user.
     * @param {block_userCreateArgs} args - Arguments to create a Block_user.
     * @example
     * // Create one Block_user
     * const Block_user = await prisma.block_user.create({
     *   data: {
     *     // ... data to create a Block_user
     *   }
     * })
     * 
     */
    create<T extends block_userCreateArgs>(args: SelectSubset<T, block_userCreateArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Block_users.
     * @param {block_userCreateManyArgs} args - Arguments to create many Block_users.
     * @example
     * // Create many Block_users
     * const block_user = await prisma.block_user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends block_userCreateManyArgs>(args?: SelectSubset<T, block_userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Block_users and returns the data saved in the database.
     * @param {block_userCreateManyAndReturnArgs} args - Arguments to create many Block_users.
     * @example
     * // Create many Block_users
     * const block_user = await prisma.block_user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Block_users and only return the `id`
     * const block_userWithIdOnly = await prisma.block_user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends block_userCreateManyAndReturnArgs>(args?: SelectSubset<T, block_userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block_user.
     * @param {block_userDeleteArgs} args - Arguments to delete one Block_user.
     * @example
     * // Delete one Block_user
     * const Block_user = await prisma.block_user.delete({
     *   where: {
     *     // ... filter to delete one Block_user
     *   }
     * })
     * 
     */
    delete<T extends block_userDeleteArgs>(args: SelectSubset<T, block_userDeleteArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block_user.
     * @param {block_userUpdateArgs} args - Arguments to update one Block_user.
     * @example
     * // Update one Block_user
     * const block_user = await prisma.block_user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends block_userUpdateArgs>(args: SelectSubset<T, block_userUpdateArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Block_users.
     * @param {block_userDeleteManyArgs} args - Arguments to filter Block_users to delete.
     * @example
     * // Delete a few Block_users
     * const { count } = await prisma.block_user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends block_userDeleteManyArgs>(args?: SelectSubset<T, block_userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Block_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Block_users
     * const block_user = await prisma.block_user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends block_userUpdateManyArgs>(args: SelectSubset<T, block_userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Block_users and returns the data updated in the database.
     * @param {block_userUpdateManyAndReturnArgs} args - Arguments to update many Block_users.
     * @example
     * // Update many Block_users
     * const block_user = await prisma.block_user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Block_users and only return the `id`
     * const block_userWithIdOnly = await prisma.block_user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends block_userUpdateManyAndReturnArgs>(args: SelectSubset<T, block_userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block_user.
     * @param {block_userUpsertArgs} args - Arguments to update or create a Block_user.
     * @example
     * // Update or create a Block_user
     * const block_user = await prisma.block_user.upsert({
     *   create: {
     *     // ... data to create a Block_user
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block_user we want to update
     *   }
     * })
     */
    upsert<T extends block_userUpsertArgs>(args: SelectSubset<T, block_userUpsertArgs<ExtArgs>>): Prisma__block_userClient<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Block_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userCountArgs} args - Arguments to filter Block_users to count.
     * @example
     * // Count the number of Block_users
     * const count = await prisma.block_user.count({
     *   where: {
     *     // ... the filter for the Block_users we want to count
     *   }
     * })
    **/
    count<T extends block_userCountArgs>(
      args?: Subset<T, block_userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Block_userCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Block_userAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Block_userAggregateArgs>(args: Subset<T, Block_userAggregateArgs>): Prisma.PrismaPromise<GetBlock_userAggregateType<T>>

    /**
     * Group by Block_user.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {block_userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends block_userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: block_userGroupByArgs['orderBy'] }
        : { orderBy?: block_userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, block_userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlock_userGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the block_user model
   */
  readonly fields: block_userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for block_user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__block_userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_block_user_blockerIdTouser<T extends block_user$user_block_user_blockerIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, block_user$user_block_user_blockerIdTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_block_user_blockedIdTouser<T extends block_user$user_block_user_blockedIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, block_user$user_block_user_blockedIdTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the block_user model
   */
  interface block_userFieldRefs {
    readonly id: FieldRef<"block_user", 'String'>
    readonly created_at: FieldRef<"block_user", 'DateTime'>
    readonly blockerId: FieldRef<"block_user", 'String'>
    readonly blockedId: FieldRef<"block_user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * block_user findUnique
   */
  export type block_userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter, which block_user to fetch.
     */
    where: block_userWhereUniqueInput
  }

  /**
   * block_user findUniqueOrThrow
   */
  export type block_userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter, which block_user to fetch.
     */
    where: block_userWhereUniqueInput
  }

  /**
   * block_user findFirst
   */
  export type block_userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter, which block_user to fetch.
     */
    where?: block_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_users to fetch.
     */
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for block_users.
     */
    cursor?: block_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of block_users.
     */
    distinct?: Block_userScalarFieldEnum | Block_userScalarFieldEnum[]
  }

  /**
   * block_user findFirstOrThrow
   */
  export type block_userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter, which block_user to fetch.
     */
    where?: block_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_users to fetch.
     */
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for block_users.
     */
    cursor?: block_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of block_users.
     */
    distinct?: Block_userScalarFieldEnum | Block_userScalarFieldEnum[]
  }

  /**
   * block_user findMany
   */
  export type block_userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter, which block_users to fetch.
     */
    where?: block_userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of block_users to fetch.
     */
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing block_users.
     */
    cursor?: block_userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` block_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` block_users.
     */
    skip?: number
    distinct?: Block_userScalarFieldEnum | Block_userScalarFieldEnum[]
  }

  /**
   * block_user create
   */
  export type block_userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * The data needed to create a block_user.
     */
    data?: XOR<block_userCreateInput, block_userUncheckedCreateInput>
  }

  /**
   * block_user createMany
   */
  export type block_userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many block_users.
     */
    data: block_userCreateManyInput | block_userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * block_user createManyAndReturn
   */
  export type block_userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * The data used to create many block_users.
     */
    data: block_userCreateManyInput | block_userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * block_user update
   */
  export type block_userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * The data needed to update a block_user.
     */
    data: XOR<block_userUpdateInput, block_userUncheckedUpdateInput>
    /**
     * Choose, which block_user to update.
     */
    where: block_userWhereUniqueInput
  }

  /**
   * block_user updateMany
   */
  export type block_userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update block_users.
     */
    data: XOR<block_userUpdateManyMutationInput, block_userUncheckedUpdateManyInput>
    /**
     * Filter which block_users to update
     */
    where?: block_userWhereInput
    /**
     * Limit how many block_users to update.
     */
    limit?: number
  }

  /**
   * block_user updateManyAndReturn
   */
  export type block_userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * The data used to update block_users.
     */
    data: XOR<block_userUpdateManyMutationInput, block_userUncheckedUpdateManyInput>
    /**
     * Filter which block_users to update
     */
    where?: block_userWhereInput
    /**
     * Limit how many block_users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * block_user upsert
   */
  export type block_userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * The filter to search for the block_user to update in case it exists.
     */
    where: block_userWhereUniqueInput
    /**
     * In case the block_user found by the `where` argument doesn't exist, create a new block_user with this data.
     */
    create: XOR<block_userCreateInput, block_userUncheckedCreateInput>
    /**
     * In case the block_user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<block_userUpdateInput, block_userUncheckedUpdateInput>
  }

  /**
   * block_user delete
   */
  export type block_userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    /**
     * Filter which block_user to delete.
     */
    where: block_userWhereUniqueInput
  }

  /**
   * block_user deleteMany
   */
  export type block_userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which block_users to delete
     */
    where?: block_userWhereInput
    /**
     * Limit how many block_users to delete.
     */
    limit?: number
  }

  /**
   * block_user.user_block_user_blockerIdTouser
   */
  export type block_user$user_block_user_blockerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * block_user.user_block_user_blockedIdTouser
   */
  export type block_user$user_block_user_blockedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * block_user without action
   */
  export type block_userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
  }


  /**
   * Model chatroom
   */

  export type AggregateChatroom = {
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  export type ChatroomMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatroomMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ChatroomCountAggregateOutputType = {
    id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ChatroomMinAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatroomMaxAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
  }

  export type ChatroomCountAggregateInputType = {
    id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ChatroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatroom to aggregate.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatrooms
    **/
    _count?: true | ChatroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatroomMaxAggregateInputType
  }

  export type GetChatroomAggregateType<T extends ChatroomAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom[P]>
      : GetScalarType<T[P], AggregateChatroom[P]>
  }




  export type chatroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroomWhereInput
    orderBy?: chatroomOrderByWithAggregationInput | chatroomOrderByWithAggregationInput[]
    by: ChatroomScalarFieldEnum[] | ChatroomScalarFieldEnum
    having?: chatroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatroomCountAggregateInputType | true
    _min?: ChatroomMinAggregateInputType
    _max?: ChatroomMaxAggregateInputType
  }

  export type ChatroomGroupByOutputType = {
    id: string
    created_at: Date
    updated_at: Date
    _count: ChatroomCountAggregateOutputType | null
    _min: ChatroomMinAggregateOutputType | null
    _max: ChatroomMaxAggregateOutputType | null
  }

  type GetChatroomGroupByPayload<T extends chatroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
            : GetScalarType<T[P], ChatroomGroupByOutputType[P]>
        }
      >
    >


  export type chatroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
    chatroom_member?: boolean | chatroom$chatroom_memberArgs<ExtArgs>
    message?: boolean | chatroom$messageArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["chatroom"]>

  export type chatroomSelectScalar = {
    id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type chatroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "updated_at", ExtArgs["result"]["chatroom"]>
  export type chatroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom_member?: boolean | chatroom$chatroom_memberArgs<ExtArgs>
    message?: boolean | chatroom$messageArgs<ExtArgs>
    _count?: boolean | ChatroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type chatroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chatroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatroom"
    objects: {
      chatroom_member: Prisma.$chatroom_memberPayload<ExtArgs>[]
      message: Prisma.$messagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["chatroom"]>
    composites: {}
  }

  type chatroomGetPayload<S extends boolean | null | undefined | chatroomDefaultArgs> = $Result.GetResult<Prisma.$chatroomPayload, S>

  type chatroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatroomCountAggregateInputType | true
    }

  export interface chatroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatroom'], meta: { name: 'chatroom' } }
    /**
     * Find zero or one Chatroom that matches the filter.
     * @param {chatroomFindUniqueArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatroomFindUniqueArgs>(args: SelectSubset<T, chatroomFindUniqueArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatroomFindUniqueOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatroomFindUniqueOrThrowArgs>(args: SelectSubset<T, chatroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatroomFindFirstArgs>(args?: SelectSubset<T, chatroomFindFirstArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindFirstOrThrowArgs} args - Arguments to find a Chatroom
     * @example
     * // Get one Chatroom
     * const chatroom = await prisma.chatroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatroomFindFirstOrThrowArgs>(args?: SelectSubset<T, chatroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatrooms
     * const chatrooms = await prisma.chatroom.findMany()
     * 
     * // Get first 10 Chatrooms
     * const chatrooms = await prisma.chatroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatroomFindManyArgs>(args?: SelectSubset<T, chatroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatroom.
     * @param {chatroomCreateArgs} args - Arguments to create a Chatroom.
     * @example
     * // Create one Chatroom
     * const Chatroom = await prisma.chatroom.create({
     *   data: {
     *     // ... data to create a Chatroom
     *   }
     * })
     * 
     */
    create<T extends chatroomCreateArgs>(args: SelectSubset<T, chatroomCreateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatrooms.
     * @param {chatroomCreateManyArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatroomCreateManyArgs>(args?: SelectSubset<T, chatroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatrooms and returns the data saved in the database.
     * @param {chatroomCreateManyAndReturnArgs} args - Arguments to create many Chatrooms.
     * @example
     * // Create many Chatrooms
     * const chatroom = await prisma.chatroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatroomCreateManyAndReturnArgs>(args?: SelectSubset<T, chatroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatroom.
     * @param {chatroomDeleteArgs} args - Arguments to delete one Chatroom.
     * @example
     * // Delete one Chatroom
     * const Chatroom = await prisma.chatroom.delete({
     *   where: {
     *     // ... filter to delete one Chatroom
     *   }
     * })
     * 
     */
    delete<T extends chatroomDeleteArgs>(args: SelectSubset<T, chatroomDeleteArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatroom.
     * @param {chatroomUpdateArgs} args - Arguments to update one Chatroom.
     * @example
     * // Update one Chatroom
     * const chatroom = await prisma.chatroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatroomUpdateArgs>(args: SelectSubset<T, chatroomUpdateArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatrooms.
     * @param {chatroomDeleteManyArgs} args - Arguments to filter Chatrooms to delete.
     * @example
     * // Delete a few Chatrooms
     * const { count } = await prisma.chatroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatroomDeleteManyArgs>(args?: SelectSubset<T, chatroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatroomUpdateManyArgs>(args: SelectSubset<T, chatroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatrooms and returns the data updated in the database.
     * @param {chatroomUpdateManyAndReturnArgs} args - Arguments to update many Chatrooms.
     * @example
     * // Update many Chatrooms
     * const chatroom = await prisma.chatroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatrooms and only return the `id`
     * const chatroomWithIdOnly = await prisma.chatroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatroomUpdateManyAndReturnArgs>(args: SelectSubset<T, chatroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatroom.
     * @param {chatroomUpsertArgs} args - Arguments to update or create a Chatroom.
     * @example
     * // Update or create a Chatroom
     * const chatroom = await prisma.chatroom.upsert({
     *   create: {
     *     // ... data to create a Chatroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom we want to update
     *   }
     * })
     */
    upsert<T extends chatroomUpsertArgs>(args: SelectSubset<T, chatroomUpsertArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomCountArgs} args - Arguments to filter Chatrooms to count.
     * @example
     * // Count the number of Chatrooms
     * const count = await prisma.chatroom.count({
     *   where: {
     *     // ... the filter for the Chatrooms we want to count
     *   }
     * })
    **/
    count<T extends chatroomCountArgs>(
      args?: Subset<T, chatroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatroomAggregateArgs>(args: Subset<T, ChatroomAggregateArgs>): Prisma.PrismaPromise<GetChatroomAggregateType<T>>

    /**
     * Group by Chatroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatroomGroupByArgs['orderBy'] }
        : { orderBy?: chatroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatroom model
   */
  readonly fields: chatroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom_member<T extends chatroom$chatroom_memberArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$chatroom_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends chatroom$messageArgs<ExtArgs> = {}>(args?: Subset<T, chatroom$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatroom model
   */
  interface chatroomFieldRefs {
    readonly id: FieldRef<"chatroom", 'String'>
    readonly created_at: FieldRef<"chatroom", 'DateTime'>
    readonly updated_at: FieldRef<"chatroom", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chatroom findUnique
   */
  export type chatroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findUniqueOrThrow
   */
  export type chatroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom findFirst
   */
  export type chatroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findFirstOrThrow
   */
  export type chatroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatroom to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatrooms.
     */
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom findMany
   */
  export type chatroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter, which chatrooms to fetch.
     */
    where?: chatroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatrooms to fetch.
     */
    orderBy?: chatroomOrderByWithRelationInput | chatroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatrooms.
     */
    cursor?: chatroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatrooms.
     */
    skip?: number
    distinct?: ChatroomScalarFieldEnum | ChatroomScalarFieldEnum[]
  }

  /**
   * chatroom create
   */
  export type chatroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to create a chatroom.
     */
    data?: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
  }

  /**
   * chatroom createMany
   */
  export type chatroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatroom createManyAndReturn
   */
  export type chatroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to create many chatrooms.
     */
    data: chatroomCreateManyInput | chatroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatroom update
   */
  export type chatroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The data needed to update a chatroom.
     */
    data: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
    /**
     * Choose, which chatroom to update.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom updateMany
   */
  export type chatroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
  }

  /**
   * chatroom updateManyAndReturn
   */
  export type chatroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * The data used to update chatrooms.
     */
    data: XOR<chatroomUpdateManyMutationInput, chatroomUncheckedUpdateManyInput>
    /**
     * Filter which chatrooms to update
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to update.
     */
    limit?: number
  }

  /**
   * chatroom upsert
   */
  export type chatroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * The filter to search for the chatroom to update in case it exists.
     */
    where: chatroomWhereUniqueInput
    /**
     * In case the chatroom found by the `where` argument doesn't exist, create a new chatroom with this data.
     */
    create: XOR<chatroomCreateInput, chatroomUncheckedCreateInput>
    /**
     * In case the chatroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatroomUpdateInput, chatroomUncheckedUpdateInput>
  }

  /**
   * chatroom delete
   */
  export type chatroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    /**
     * Filter which chatroom to delete.
     */
    where: chatroomWhereUniqueInput
  }

  /**
   * chatroom deleteMany
   */
  export type chatroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatrooms to delete
     */
    where?: chatroomWhereInput
    /**
     * Limit how many chatrooms to delete.
     */
    limit?: number
  }

  /**
   * chatroom.chatroom_member
   */
  export type chatroom$chatroom_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    where?: chatroom_memberWhereInput
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    cursor?: chatroom_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chatroom_memberScalarFieldEnum | Chatroom_memberScalarFieldEnum[]
  }

  /**
   * chatroom.message
   */
  export type chatroom$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * chatroom without action
   */
  export type chatroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
  }


  /**
   * Model chatroom_member
   */

  export type AggregateChatroom_member = {
    _count: Chatroom_memberCountAggregateOutputType | null
    _min: Chatroom_memberMinAggregateOutputType | null
    _max: Chatroom_memberMaxAggregateOutputType | null
  }

  export type Chatroom_memberMinAggregateOutputType = {
    chatroomId: string | null
    userId: string | null
  }

  export type Chatroom_memberMaxAggregateOutputType = {
    chatroomId: string | null
    userId: string | null
  }

  export type Chatroom_memberCountAggregateOutputType = {
    chatroomId: number
    userId: number
    _all: number
  }


  export type Chatroom_memberMinAggregateInputType = {
    chatroomId?: true
    userId?: true
  }

  export type Chatroom_memberMaxAggregateInputType = {
    chatroomId?: true
    userId?: true
  }

  export type Chatroom_memberCountAggregateInputType = {
    chatroomId?: true
    userId?: true
    _all?: true
  }

  export type Chatroom_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatroom_member to aggregate.
     */
    where?: chatroom_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatroom_members to fetch.
     */
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatroom_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatroom_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatroom_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatroom_members
    **/
    _count?: true | Chatroom_memberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chatroom_memberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chatroom_memberMaxAggregateInputType
  }

  export type GetChatroom_memberAggregateType<T extends Chatroom_memberAggregateArgs> = {
        [P in keyof T & keyof AggregateChatroom_member]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatroom_member[P]>
      : GetScalarType<T[P], AggregateChatroom_member[P]>
  }




  export type chatroom_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatroom_memberWhereInput
    orderBy?: chatroom_memberOrderByWithAggregationInput | chatroom_memberOrderByWithAggregationInput[]
    by: Chatroom_memberScalarFieldEnum[] | Chatroom_memberScalarFieldEnum
    having?: chatroom_memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chatroom_memberCountAggregateInputType | true
    _min?: Chatroom_memberMinAggregateInputType
    _max?: Chatroom_memberMaxAggregateInputType
  }

  export type Chatroom_memberGroupByOutputType = {
    chatroomId: string
    userId: string
    _count: Chatroom_memberCountAggregateOutputType | null
    _min: Chatroom_memberMinAggregateOutputType | null
    _max: Chatroom_memberMaxAggregateOutputType | null
  }

  type GetChatroom_memberGroupByPayload<T extends chatroom_memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chatroom_memberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chatroom_memberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chatroom_memberGroupByOutputType[P]>
            : GetScalarType<T[P], Chatroom_memberGroupByOutputType[P]>
        }
      >
    >


  export type chatroom_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatroomId?: boolean
    userId?: boolean
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom_member"]>

  export type chatroom_memberSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatroomId?: boolean
    userId?: boolean
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom_member"]>

  export type chatroom_memberSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatroomId?: boolean
    userId?: boolean
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatroom_member"]>

  export type chatroom_memberSelectScalar = {
    chatroomId?: boolean
    userId?: boolean
  }

  export type chatroom_memberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chatroomId" | "userId", ExtArgs["result"]["chatroom_member"]>
  export type chatroom_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type chatroom_memberIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type chatroom_memberIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | chatroomDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $chatroom_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatroom_member"
    objects: {
      chatroom: Prisma.$chatroomPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chatroomId: string
      userId: string
    }, ExtArgs["result"]["chatroom_member"]>
    composites: {}
  }

  type chatroom_memberGetPayload<S extends boolean | null | undefined | chatroom_memberDefaultArgs> = $Result.GetResult<Prisma.$chatroom_memberPayload, S>

  type chatroom_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatroom_memberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chatroom_memberCountAggregateInputType | true
    }

  export interface chatroom_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatroom_member'], meta: { name: 'chatroom_member' } }
    /**
     * Find zero or one Chatroom_member that matches the filter.
     * @param {chatroom_memberFindUniqueArgs} args - Arguments to find a Chatroom_member
     * @example
     * // Get one Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatroom_memberFindUniqueArgs>(args: SelectSubset<T, chatroom_memberFindUniqueArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Chatroom_member that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatroom_memberFindUniqueOrThrowArgs} args - Arguments to find a Chatroom_member
     * @example
     * // Get one Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatroom_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, chatroom_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom_member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberFindFirstArgs} args - Arguments to find a Chatroom_member
     * @example
     * // Get one Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatroom_memberFindFirstArgs>(args?: SelectSubset<T, chatroom_memberFindFirstArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Chatroom_member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberFindFirstOrThrowArgs} args - Arguments to find a Chatroom_member
     * @example
     * // Get one Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatroom_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, chatroom_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Chatroom_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatroom_members
     * const chatroom_members = await prisma.chatroom_member.findMany()
     * 
     * // Get first 10 Chatroom_members
     * const chatroom_members = await prisma.chatroom_member.findMany({ take: 10 })
     * 
     * // Only select the `chatroomId`
     * const chatroom_memberWithChatroomIdOnly = await prisma.chatroom_member.findMany({ select: { chatroomId: true } })
     * 
     */
    findMany<T extends chatroom_memberFindManyArgs>(args?: SelectSubset<T, chatroom_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Chatroom_member.
     * @param {chatroom_memberCreateArgs} args - Arguments to create a Chatroom_member.
     * @example
     * // Create one Chatroom_member
     * const Chatroom_member = await prisma.chatroom_member.create({
     *   data: {
     *     // ... data to create a Chatroom_member
     *   }
     * })
     * 
     */
    create<T extends chatroom_memberCreateArgs>(args: SelectSubset<T, chatroom_memberCreateArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Chatroom_members.
     * @param {chatroom_memberCreateManyArgs} args - Arguments to create many Chatroom_members.
     * @example
     * // Create many Chatroom_members
     * const chatroom_member = await prisma.chatroom_member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatroom_memberCreateManyArgs>(args?: SelectSubset<T, chatroom_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatroom_members and returns the data saved in the database.
     * @param {chatroom_memberCreateManyAndReturnArgs} args - Arguments to create many Chatroom_members.
     * @example
     * // Create many Chatroom_members
     * const chatroom_member = await prisma.chatroom_member.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatroom_members and only return the `chatroomId`
     * const chatroom_memberWithChatroomIdOnly = await prisma.chatroom_member.createManyAndReturn({
     *   select: { chatroomId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatroom_memberCreateManyAndReturnArgs>(args?: SelectSubset<T, chatroom_memberCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Chatroom_member.
     * @param {chatroom_memberDeleteArgs} args - Arguments to delete one Chatroom_member.
     * @example
     * // Delete one Chatroom_member
     * const Chatroom_member = await prisma.chatroom_member.delete({
     *   where: {
     *     // ... filter to delete one Chatroom_member
     *   }
     * })
     * 
     */
    delete<T extends chatroom_memberDeleteArgs>(args: SelectSubset<T, chatroom_memberDeleteArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Chatroom_member.
     * @param {chatroom_memberUpdateArgs} args - Arguments to update one Chatroom_member.
     * @example
     * // Update one Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatroom_memberUpdateArgs>(args: SelectSubset<T, chatroom_memberUpdateArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Chatroom_members.
     * @param {chatroom_memberDeleteManyArgs} args - Arguments to filter Chatroom_members to delete.
     * @example
     * // Delete a few Chatroom_members
     * const { count } = await prisma.chatroom_member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatroom_memberDeleteManyArgs>(args?: SelectSubset<T, chatroom_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatroom_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatroom_members
     * const chatroom_member = await prisma.chatroom_member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatroom_memberUpdateManyArgs>(args: SelectSubset<T, chatroom_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatroom_members and returns the data updated in the database.
     * @param {chatroom_memberUpdateManyAndReturnArgs} args - Arguments to update many Chatroom_members.
     * @example
     * // Update many Chatroom_members
     * const chatroom_member = await prisma.chatroom_member.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatroom_members and only return the `chatroomId`
     * const chatroom_memberWithChatroomIdOnly = await prisma.chatroom_member.updateManyAndReturn({
     *   select: { chatroomId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatroom_memberUpdateManyAndReturnArgs>(args: SelectSubset<T, chatroom_memberUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Chatroom_member.
     * @param {chatroom_memberUpsertArgs} args - Arguments to update or create a Chatroom_member.
     * @example
     * // Update or create a Chatroom_member
     * const chatroom_member = await prisma.chatroom_member.upsert({
     *   create: {
     *     // ... data to create a Chatroom_member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatroom_member we want to update
     *   }
     * })
     */
    upsert<T extends chatroom_memberUpsertArgs>(args: SelectSubset<T, chatroom_memberUpsertArgs<ExtArgs>>): Prisma__chatroom_memberClient<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Chatroom_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberCountArgs} args - Arguments to filter Chatroom_members to count.
     * @example
     * // Count the number of Chatroom_members
     * const count = await prisma.chatroom_member.count({
     *   where: {
     *     // ... the filter for the Chatroom_members we want to count
     *   }
     * })
    **/
    count<T extends chatroom_memberCountArgs>(
      args?: Subset<T, chatroom_memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chatroom_memberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatroom_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chatroom_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chatroom_memberAggregateArgs>(args: Subset<T, Chatroom_memberAggregateArgs>): Prisma.PrismaPromise<GetChatroom_memberAggregateType<T>>

    /**
     * Group by Chatroom_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatroom_memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatroom_memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatroom_memberGroupByArgs['orderBy'] }
        : { orderBy?: chatroom_memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatroom_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatroom_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatroom_member model
   */
  readonly fields: chatroom_memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatroom_member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatroom_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatroom<T extends chatroomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatroomDefaultArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatroom_member model
   */
  interface chatroom_memberFieldRefs {
    readonly chatroomId: FieldRef<"chatroom_member", 'String'>
    readonly userId: FieldRef<"chatroom_member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatroom_member findUnique
   */
  export type chatroom_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter, which chatroom_member to fetch.
     */
    where: chatroom_memberWhereUniqueInput
  }

  /**
   * chatroom_member findUniqueOrThrow
   */
  export type chatroom_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter, which chatroom_member to fetch.
     */
    where: chatroom_memberWhereUniqueInput
  }

  /**
   * chatroom_member findFirst
   */
  export type chatroom_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter, which chatroom_member to fetch.
     */
    where?: chatroom_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatroom_members to fetch.
     */
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatroom_members.
     */
    cursor?: chatroom_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatroom_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatroom_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatroom_members.
     */
    distinct?: Chatroom_memberScalarFieldEnum | Chatroom_memberScalarFieldEnum[]
  }

  /**
   * chatroom_member findFirstOrThrow
   */
  export type chatroom_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter, which chatroom_member to fetch.
     */
    where?: chatroom_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatroom_members to fetch.
     */
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatroom_members.
     */
    cursor?: chatroom_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatroom_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatroom_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatroom_members.
     */
    distinct?: Chatroom_memberScalarFieldEnum | Chatroom_memberScalarFieldEnum[]
  }

  /**
   * chatroom_member findMany
   */
  export type chatroom_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter, which chatroom_members to fetch.
     */
    where?: chatroom_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatroom_members to fetch.
     */
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatroom_members.
     */
    cursor?: chatroom_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatroom_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatroom_members.
     */
    skip?: number
    distinct?: Chatroom_memberScalarFieldEnum | Chatroom_memberScalarFieldEnum[]
  }

  /**
   * chatroom_member create
   */
  export type chatroom_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * The data needed to create a chatroom_member.
     */
    data: XOR<chatroom_memberCreateInput, chatroom_memberUncheckedCreateInput>
  }

  /**
   * chatroom_member createMany
   */
  export type chatroom_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatroom_members.
     */
    data: chatroom_memberCreateManyInput | chatroom_memberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatroom_member createManyAndReturn
   */
  export type chatroom_memberCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * The data used to create many chatroom_members.
     */
    data: chatroom_memberCreateManyInput | chatroom_memberCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom_member update
   */
  export type chatroom_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * The data needed to update a chatroom_member.
     */
    data: XOR<chatroom_memberUpdateInput, chatroom_memberUncheckedUpdateInput>
    /**
     * Choose, which chatroom_member to update.
     */
    where: chatroom_memberWhereUniqueInput
  }

  /**
   * chatroom_member updateMany
   */
  export type chatroom_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatroom_members.
     */
    data: XOR<chatroom_memberUpdateManyMutationInput, chatroom_memberUncheckedUpdateManyInput>
    /**
     * Filter which chatroom_members to update
     */
    where?: chatroom_memberWhereInput
    /**
     * Limit how many chatroom_members to update.
     */
    limit?: number
  }

  /**
   * chatroom_member updateManyAndReturn
   */
  export type chatroom_memberUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * The data used to update chatroom_members.
     */
    data: XOR<chatroom_memberUpdateManyMutationInput, chatroom_memberUncheckedUpdateManyInput>
    /**
     * Filter which chatroom_members to update
     */
    where?: chatroom_memberWhereInput
    /**
     * Limit how many chatroom_members to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatroom_member upsert
   */
  export type chatroom_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * The filter to search for the chatroom_member to update in case it exists.
     */
    where: chatroom_memberWhereUniqueInput
    /**
     * In case the chatroom_member found by the `where` argument doesn't exist, create a new chatroom_member with this data.
     */
    create: XOR<chatroom_memberCreateInput, chatroom_memberUncheckedCreateInput>
    /**
     * In case the chatroom_member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatroom_memberUpdateInput, chatroom_memberUncheckedUpdateInput>
  }

  /**
   * chatroom_member delete
   */
  export type chatroom_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    /**
     * Filter which chatroom_member to delete.
     */
    where: chatroom_memberWhereUniqueInput
  }

  /**
   * chatroom_member deleteMany
   */
  export type chatroom_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatroom_members to delete
     */
    where?: chatroom_memberWhereInput
    /**
     * Limit how many chatroom_members to delete.
     */
    limit?: number
  }

  /**
   * chatroom_member without action
   */
  export type chatroom_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
  }


  /**
   * Model combo
   */

  export type AggregateCombo = {
    _count: ComboCountAggregateOutputType | null
    _avg: ComboAvgAggregateOutputType | null
    _sum: ComboSumAggregateOutputType | null
    _min: ComboMinAggregateOutputType | null
    _max: ComboMaxAggregateOutputType | null
  }

  export type ComboAvgAggregateOutputType = {
    count: number | null
  }

  export type ComboSumAggregateOutputType = {
    count: number | null
  }

  export type ComboMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    post_id: string | null
    count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComboMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    post_id: string | null
    count: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComboCountAggregateOutputType = {
    id: number
    user_id: number
    post_id: number
    count: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComboAvgAggregateInputType = {
    count?: true
  }

  export type ComboSumAggregateInputType = {
    count?: true
  }

  export type ComboMinAggregateInputType = {
    id?: true
    user_id?: true
    post_id?: true
    count?: true
    created_at?: true
    updated_at?: true
  }

  export type ComboMaxAggregateInputType = {
    id?: true
    user_id?: true
    post_id?: true
    count?: true
    created_at?: true
    updated_at?: true
  }

  export type ComboCountAggregateInputType = {
    id?: true
    user_id?: true
    post_id?: true
    count?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComboAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combo to aggregate.
     */
    where?: comboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combos to fetch.
     */
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: comboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned combos
    **/
    _count?: true | ComboCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComboAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComboSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboMaxAggregateInputType
  }

  export type GetComboAggregateType<T extends ComboAggregateArgs> = {
        [P in keyof T & keyof AggregateCombo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCombo[P]>
      : GetScalarType<T[P], AggregateCombo[P]>
  }




  export type comboGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: comboWhereInput
    orderBy?: comboOrderByWithAggregationInput | comboOrderByWithAggregationInput[]
    by: ComboScalarFieldEnum[] | ComboScalarFieldEnum
    having?: comboScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboCountAggregateInputType | true
    _avg?: ComboAvgAggregateInputType
    _sum?: ComboSumAggregateInputType
    _min?: ComboMinAggregateInputType
    _max?: ComboMaxAggregateInputType
  }

  export type ComboGroupByOutputType = {
    id: string
    user_id: string
    post_id: string
    count: number
    created_at: Date
    updated_at: Date
    _count: ComboCountAggregateOutputType | null
    _avg: ComboAvgAggregateOutputType | null
    _sum: ComboSumAggregateOutputType | null
    _min: ComboMinAggregateOutputType | null
    _max: ComboMaxAggregateOutputType | null
  }

  type GetComboGroupByPayload<T extends comboGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboGroupByOutputType[P]>
            : GetScalarType<T[P], ComboGroupByOutputType[P]>
        }
      >
    >


  export type comboSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    post_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combo"]>

  export type comboSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    post_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combo"]>

  export type comboSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    post_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["combo"]>

  export type comboSelectScalar = {
    id?: boolean
    user_id?: boolean
    post_id?: boolean
    count?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type comboOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "post_id" | "count" | "created_at" | "updated_at", ExtArgs["result"]["combo"]>
  export type comboInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type comboIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }
  export type comboIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | postDefaultArgs<ExtArgs>
    user?: boolean | userDefaultArgs<ExtArgs>
  }

  export type $comboPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "combo"
    objects: {
      post: Prisma.$postPayload<ExtArgs>
      user: Prisma.$userPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      post_id: string
      count: number
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["combo"]>
    composites: {}
  }

  type comboGetPayload<S extends boolean | null | undefined | comboDefaultArgs> = $Result.GetResult<Prisma.$comboPayload, S>

  type comboCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<comboFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComboCountAggregateInputType | true
    }

  export interface comboDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['combo'], meta: { name: 'combo' } }
    /**
     * Find zero or one Combo that matches the filter.
     * @param {comboFindUniqueArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends comboFindUniqueArgs>(args: SelectSubset<T, comboFindUniqueArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Combo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {comboFindUniqueOrThrowArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends comboFindUniqueOrThrowArgs>(args: SelectSubset<T, comboFindUniqueOrThrowArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Combo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboFindFirstArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends comboFindFirstArgs>(args?: SelectSubset<T, comboFindFirstArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Combo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboFindFirstOrThrowArgs} args - Arguments to find a Combo
     * @example
     * // Get one Combo
     * const combo = await prisma.combo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends comboFindFirstOrThrowArgs>(args?: SelectSubset<T, comboFindFirstOrThrowArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Combos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Combos
     * const combos = await prisma.combo.findMany()
     * 
     * // Get first 10 Combos
     * const combos = await prisma.combo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboWithIdOnly = await prisma.combo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends comboFindManyArgs>(args?: SelectSubset<T, comboFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Combo.
     * @param {comboCreateArgs} args - Arguments to create a Combo.
     * @example
     * // Create one Combo
     * const Combo = await prisma.combo.create({
     *   data: {
     *     // ... data to create a Combo
     *   }
     * })
     * 
     */
    create<T extends comboCreateArgs>(args: SelectSubset<T, comboCreateArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Combos.
     * @param {comboCreateManyArgs} args - Arguments to create many Combos.
     * @example
     * // Create many Combos
     * const combo = await prisma.combo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends comboCreateManyArgs>(args?: SelectSubset<T, comboCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Combos and returns the data saved in the database.
     * @param {comboCreateManyAndReturnArgs} args - Arguments to create many Combos.
     * @example
     * // Create many Combos
     * const combo = await prisma.combo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Combos and only return the `id`
     * const comboWithIdOnly = await prisma.combo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends comboCreateManyAndReturnArgs>(args?: SelectSubset<T, comboCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Combo.
     * @param {comboDeleteArgs} args - Arguments to delete one Combo.
     * @example
     * // Delete one Combo
     * const Combo = await prisma.combo.delete({
     *   where: {
     *     // ... filter to delete one Combo
     *   }
     * })
     * 
     */
    delete<T extends comboDeleteArgs>(args: SelectSubset<T, comboDeleteArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Combo.
     * @param {comboUpdateArgs} args - Arguments to update one Combo.
     * @example
     * // Update one Combo
     * const combo = await prisma.combo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends comboUpdateArgs>(args: SelectSubset<T, comboUpdateArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Combos.
     * @param {comboDeleteManyArgs} args - Arguments to filter Combos to delete.
     * @example
     * // Delete a few Combos
     * const { count } = await prisma.combo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends comboDeleteManyArgs>(args?: SelectSubset<T, comboDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Combos
     * const combo = await prisma.combo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends comboUpdateManyArgs>(args: SelectSubset<T, comboUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Combos and returns the data updated in the database.
     * @param {comboUpdateManyAndReturnArgs} args - Arguments to update many Combos.
     * @example
     * // Update many Combos
     * const combo = await prisma.combo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Combos and only return the `id`
     * const comboWithIdOnly = await prisma.combo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends comboUpdateManyAndReturnArgs>(args: SelectSubset<T, comboUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Combo.
     * @param {comboUpsertArgs} args - Arguments to update or create a Combo.
     * @example
     * // Update or create a Combo
     * const combo = await prisma.combo.upsert({
     *   create: {
     *     // ... data to create a Combo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Combo we want to update
     *   }
     * })
     */
    upsert<T extends comboUpsertArgs>(args: SelectSubset<T, comboUpsertArgs<ExtArgs>>): Prisma__comboClient<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Combos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboCountArgs} args - Arguments to filter Combos to count.
     * @example
     * // Count the number of Combos
     * const count = await prisma.combo.count({
     *   where: {
     *     // ... the filter for the Combos we want to count
     *   }
     * })
    **/
    count<T extends comboCountArgs>(
      args?: Subset<T, comboCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Combo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboAggregateArgs>(args: Subset<T, ComboAggregateArgs>): Prisma.PrismaPromise<GetComboAggregateType<T>>

    /**
     * Group by Combo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {comboGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends comboGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: comboGroupByArgs['orderBy'] }
        : { orderBy?: comboGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, comboGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the combo model
   */
  readonly fields: comboFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for combo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__comboClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends postDefaultArgs<ExtArgs> = {}>(args?: Subset<T, postDefaultArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends userDefaultArgs<ExtArgs> = {}>(args?: Subset<T, userDefaultArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the combo model
   */
  interface comboFieldRefs {
    readonly id: FieldRef<"combo", 'String'>
    readonly user_id: FieldRef<"combo", 'String'>
    readonly post_id: FieldRef<"combo", 'String'>
    readonly count: FieldRef<"combo", 'Int'>
    readonly created_at: FieldRef<"combo", 'DateTime'>
    readonly updated_at: FieldRef<"combo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * combo findUnique
   */
  export type comboFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter, which combo to fetch.
     */
    where: comboWhereUniqueInput
  }

  /**
   * combo findUniqueOrThrow
   */
  export type comboFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter, which combo to fetch.
     */
    where: comboWhereUniqueInput
  }

  /**
   * combo findFirst
   */
  export type comboFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter, which combo to fetch.
     */
    where?: comboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combos to fetch.
     */
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combos.
     */
    cursor?: comboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combos.
     */
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }

  /**
   * combo findFirstOrThrow
   */
  export type comboFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter, which combo to fetch.
     */
    where?: comboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combos to fetch.
     */
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for combos.
     */
    cursor?: comboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of combos.
     */
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }

  /**
   * combo findMany
   */
  export type comboFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter, which combos to fetch.
     */
    where?: comboWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of combos to fetch.
     */
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing combos.
     */
    cursor?: comboWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` combos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` combos.
     */
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }

  /**
   * combo create
   */
  export type comboCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * The data needed to create a combo.
     */
    data: XOR<comboCreateInput, comboUncheckedCreateInput>
  }

  /**
   * combo createMany
   */
  export type comboCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many combos.
     */
    data: comboCreateManyInput | comboCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * combo createManyAndReturn
   */
  export type comboCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * The data used to create many combos.
     */
    data: comboCreateManyInput | comboCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * combo update
   */
  export type comboUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * The data needed to update a combo.
     */
    data: XOR<comboUpdateInput, comboUncheckedUpdateInput>
    /**
     * Choose, which combo to update.
     */
    where: comboWhereUniqueInput
  }

  /**
   * combo updateMany
   */
  export type comboUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update combos.
     */
    data: XOR<comboUpdateManyMutationInput, comboUncheckedUpdateManyInput>
    /**
     * Filter which combos to update
     */
    where?: comboWhereInput
    /**
     * Limit how many combos to update.
     */
    limit?: number
  }

  /**
   * combo updateManyAndReturn
   */
  export type comboUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * The data used to update combos.
     */
    data: XOR<comboUpdateManyMutationInput, comboUncheckedUpdateManyInput>
    /**
     * Filter which combos to update
     */
    where?: comboWhereInput
    /**
     * Limit how many combos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * combo upsert
   */
  export type comboUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * The filter to search for the combo to update in case it exists.
     */
    where: comboWhereUniqueInput
    /**
     * In case the combo found by the `where` argument doesn't exist, create a new combo with this data.
     */
    create: XOR<comboCreateInput, comboUncheckedCreateInput>
    /**
     * In case the combo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<comboUpdateInput, comboUncheckedUpdateInput>
  }

  /**
   * combo delete
   */
  export type comboDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    /**
     * Filter which combo to delete.
     */
    where: comboWhereUniqueInput
  }

  /**
   * combo deleteMany
   */
  export type comboDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which combos to delete
     */
    where?: comboWhereInput
    /**
     * Limit how many combos to delete.
     */
    limit?: number
  }

  /**
   * combo without action
   */
  export type comboDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
  }


  /**
   * Model comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    comment: string | null
    created_at: Date | null
    post_id: string | null
    user_id: string | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    comment: string | null
    created_at: Date | null
    post_id: string | null
    user_id: string | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    comment: number
    created_at: number
    post_id: number
    user_id: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    comment?: true
    created_at?: true
    post_id?: true
    user_id?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    comment?: true
    created_at?: true
    post_id?: true
    user_id?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    comment?: true
    created_at?: true
    post_id?: true
    user_id?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comment to aggregate.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type commentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: commentWhereInput
    orderBy?: commentOrderByWithAggregationInput | commentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: commentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    comment: string
    created_at: Date
    post_id: string | null
    user_id: string | null
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends commentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type commentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type commentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type commentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    comment?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type commentSelectScalar = {
    id?: boolean
    comment?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
  }

  export type commentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "comment" | "created_at" | "post_id" | "user_id", ExtArgs["result"]["comment"]>
  export type commentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }
  export type commentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }
  export type commentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | comment$postArgs<ExtArgs>
    user?: boolean | comment$userArgs<ExtArgs>
  }

  export type $commentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "comment"
    objects: {
      post: Prisma.$postPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      comment: string
      created_at: Date
      post_id: string | null
      user_id: string | null
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type commentGetPayload<S extends boolean | null | undefined | commentDefaultArgs> = $Result.GetResult<Prisma.$commentPayload, S>

  type commentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<commentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface commentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['comment'], meta: { name: 'comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {commentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends commentFindUniqueArgs>(args: SelectSubset<T, commentFindUniqueArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {commentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends commentFindUniqueOrThrowArgs>(args: SelectSubset<T, commentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends commentFindFirstArgs>(args?: SelectSubset<T, commentFindFirstArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends commentFindFirstOrThrowArgs>(args?: SelectSubset<T, commentFindFirstOrThrowArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends commentFindManyArgs>(args?: SelectSubset<T, commentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {commentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends commentCreateArgs>(args: SelectSubset<T, commentCreateArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {commentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends commentCreateManyArgs>(args?: SelectSubset<T, commentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {commentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends commentCreateManyAndReturnArgs>(args?: SelectSubset<T, commentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {commentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends commentDeleteArgs>(args: SelectSubset<T, commentDeleteArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {commentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends commentUpdateArgs>(args: SelectSubset<T, commentUpdateArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {commentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends commentDeleteManyArgs>(args?: SelectSubset<T, commentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends commentUpdateManyArgs>(args: SelectSubset<T, commentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {commentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends commentUpdateManyAndReturnArgs>(args: SelectSubset<T, commentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {commentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends commentUpsertArgs>(args: SelectSubset<T, commentUpsertArgs<ExtArgs>>): Prisma__commentClient<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends commentCountArgs>(
      args?: Subset<T, commentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {commentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends commentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: commentGroupByArgs['orderBy'] }
        : { orderBy?: commentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, commentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the comment model
   */
  readonly fields: commentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__commentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends comment$postArgs<ExtArgs> = {}>(args?: Subset<T, comment$postArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends comment$userArgs<ExtArgs> = {}>(args?: Subset<T, comment$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the comment model
   */
  interface commentFieldRefs {
    readonly id: FieldRef<"comment", 'String'>
    readonly comment: FieldRef<"comment", 'String'>
    readonly created_at: FieldRef<"comment", 'DateTime'>
    readonly post_id: FieldRef<"comment", 'String'>
    readonly user_id: FieldRef<"comment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * comment findUnique
   */
  export type commentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment findUniqueOrThrow
   */
  export type commentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment findFirst
   */
  export type commentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment findFirstOrThrow
   */
  export type commentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comment to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment findMany
   */
  export type commentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter, which comments to fetch.
     */
    where?: commentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of comments to fetch.
     */
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing comments.
     */
    cursor?: commentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * comment create
   */
  export type commentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The data needed to create a comment.
     */
    data: XOR<commentCreateInput, commentUncheckedCreateInput>
  }

  /**
   * comment createMany
   */
  export type commentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many comments.
     */
    data: commentCreateManyInput | commentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * comment createManyAndReturn
   */
  export type commentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * The data used to create many comments.
     */
    data: commentCreateManyInput | commentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * comment update
   */
  export type commentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The data needed to update a comment.
     */
    data: XOR<commentUpdateInput, commentUncheckedUpdateInput>
    /**
     * Choose, which comment to update.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment updateMany
   */
  export type commentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update comments.
     */
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
  }

  /**
   * comment updateManyAndReturn
   */
  export type commentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * The data used to update comments.
     */
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyInput>
    /**
     * Filter which comments to update
     */
    where?: commentWhereInput
    /**
     * Limit how many comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * comment upsert
   */
  export type commentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * The filter to search for the comment to update in case it exists.
     */
    where: commentWhereUniqueInput
    /**
     * In case the comment found by the `where` argument doesn't exist, create a new comment with this data.
     */
    create: XOR<commentCreateInput, commentUncheckedCreateInput>
    /**
     * In case the comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<commentUpdateInput, commentUncheckedUpdateInput>
  }

  /**
   * comment delete
   */
  export type commentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    /**
     * Filter which comment to delete.
     */
    where: commentWhereUniqueInput
  }

  /**
   * comment deleteMany
   */
  export type commentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which comments to delete
     */
    where?: commentWhereInput
    /**
     * Limit how many comments to delete.
     */
    limit?: number
  }

  /**
   * comment.post
   */
  export type comment$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    where?: postWhereInput
  }

  /**
   * comment.user
   */
  export type comment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * comment without action
   */
  export type commentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
  }


  /**
   * Model config
   */

  export type AggregateConfig = {
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  export type ConfigAvgAggregateOutputType = {
    verify_amount: number | null
  }

  export type ConfigSumAggregateOutputType = {
    verify_amount: number | null
  }

  export type ConfigMinAggregateOutputType = {
    id: string | null
    verify_amount: number | null
  }

  export type ConfigMaxAggregateOutputType = {
    id: string | null
    verify_amount: number | null
  }

  export type ConfigCountAggregateOutputType = {
    id: number
    verify_amount: number
    _all: number
  }


  export type ConfigAvgAggregateInputType = {
    verify_amount?: true
  }

  export type ConfigSumAggregateInputType = {
    verify_amount?: true
  }

  export type ConfigMinAggregateInputType = {
    id?: true
    verify_amount?: true
  }

  export type ConfigMaxAggregateInputType = {
    id?: true
    verify_amount?: true
  }

  export type ConfigCountAggregateInputType = {
    id?: true
    verify_amount?: true
    _all?: true
  }

  export type ConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which config to aggregate.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned configs
    **/
    _count?: true | ConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMaxAggregateInputType
  }

  export type GetConfigAggregateType<T extends ConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfig[P]>
      : GetScalarType<T[P], AggregateConfig[P]>
  }




  export type configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: configWhereInput
    orderBy?: configOrderByWithAggregationInput | configOrderByWithAggregationInput[]
    by: ConfigScalarFieldEnum[] | ConfigScalarFieldEnum
    having?: configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigCountAggregateInputType | true
    _avg?: ConfigAvgAggregateInputType
    _sum?: ConfigSumAggregateInputType
    _min?: ConfigMinAggregateInputType
    _max?: ConfigMaxAggregateInputType
  }

  export type ConfigGroupByOutputType = {
    id: string
    verify_amount: number
    _count: ConfigCountAggregateOutputType | null
    _avg: ConfigAvgAggregateOutputType | null
    _sum: ConfigSumAggregateOutputType | null
    _min: ConfigMinAggregateOutputType | null
    _max: ConfigMaxAggregateOutputType | null
  }

  type GetConfigGroupByPayload<T extends configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigGroupByOutputType[P]>
        }
      >
    >


  export type configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verify_amount?: boolean
  }, ExtArgs["result"]["config"]>

  export type configSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verify_amount?: boolean
  }, ExtArgs["result"]["config"]>

  export type configSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    verify_amount?: boolean
  }, ExtArgs["result"]["config"]>

  export type configSelectScalar = {
    id?: boolean
    verify_amount?: boolean
  }

  export type configOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "verify_amount", ExtArgs["result"]["config"]>

  export type $configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "config"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      verify_amount: number
    }, ExtArgs["result"]["config"]>
    composites: {}
  }

  type configGetPayload<S extends boolean | null | undefined | configDefaultArgs> = $Result.GetResult<Prisma.$configPayload, S>

  type configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<configFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigCountAggregateInputType | true
    }

  export interface configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['config'], meta: { name: 'config' } }
    /**
     * Find zero or one Config that matches the filter.
     * @param {configFindUniqueArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends configFindUniqueArgs>(args: SelectSubset<T, configFindUniqueArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Config that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {configFindUniqueOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends configFindUniqueOrThrowArgs>(args: SelectSubset<T, configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends configFindFirstArgs>(args?: SelectSubset<T, configFindFirstArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindFirstOrThrowArgs} args - Arguments to find a Config
     * @example
     * // Get one Config
     * const config = await prisma.config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends configFindFirstOrThrowArgs>(args?: SelectSubset<T, configFindFirstOrThrowArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configs
     * const configs = await prisma.config.findMany()
     * 
     * // Get first 10 Configs
     * const configs = await prisma.config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configWithIdOnly = await prisma.config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends configFindManyArgs>(args?: SelectSubset<T, configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Config.
     * @param {configCreateArgs} args - Arguments to create a Config.
     * @example
     * // Create one Config
     * const Config = await prisma.config.create({
     *   data: {
     *     // ... data to create a Config
     *   }
     * })
     * 
     */
    create<T extends configCreateArgs>(args: SelectSubset<T, configCreateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Configs.
     * @param {configCreateManyArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends configCreateManyArgs>(args?: SelectSubset<T, configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configs and returns the data saved in the database.
     * @param {configCreateManyAndReturnArgs} args - Arguments to create many Configs.
     * @example
     * // Create many Configs
     * const config = await prisma.config.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configs and only return the `id`
     * const configWithIdOnly = await prisma.config.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends configCreateManyAndReturnArgs>(args?: SelectSubset<T, configCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Config.
     * @param {configDeleteArgs} args - Arguments to delete one Config.
     * @example
     * // Delete one Config
     * const Config = await prisma.config.delete({
     *   where: {
     *     // ... filter to delete one Config
     *   }
     * })
     * 
     */
    delete<T extends configDeleteArgs>(args: SelectSubset<T, configDeleteArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Config.
     * @param {configUpdateArgs} args - Arguments to update one Config.
     * @example
     * // Update one Config
     * const config = await prisma.config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends configUpdateArgs>(args: SelectSubset<T, configUpdateArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Configs.
     * @param {configDeleteManyArgs} args - Arguments to filter Configs to delete.
     * @example
     * // Delete a few Configs
     * const { count } = await prisma.config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends configDeleteManyArgs>(args?: SelectSubset<T, configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends configUpdateManyArgs>(args: SelectSubset<T, configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configs and returns the data updated in the database.
     * @param {configUpdateManyAndReturnArgs} args - Arguments to update many Configs.
     * @example
     * // Update many Configs
     * const config = await prisma.config.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Configs and only return the `id`
     * const configWithIdOnly = await prisma.config.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends configUpdateManyAndReturnArgs>(args: SelectSubset<T, configUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Config.
     * @param {configUpsertArgs} args - Arguments to update or create a Config.
     * @example
     * // Update or create a Config
     * const config = await prisma.config.upsert({
     *   create: {
     *     // ... data to create a Config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Config we want to update
     *   }
     * })
     */
    upsert<T extends configUpsertArgs>(args: SelectSubset<T, configUpsertArgs<ExtArgs>>): Prisma__configClient<$Result.GetResult<Prisma.$configPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configCountArgs} args - Arguments to filter Configs to count.
     * @example
     * // Count the number of Configs
     * const count = await prisma.config.count({
     *   where: {
     *     // ... the filter for the Configs we want to count
     *   }
     * })
    **/
    count<T extends configCountArgs>(
      args?: Subset<T, configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigAggregateArgs>(args: Subset<T, ConfigAggregateArgs>): Prisma.PrismaPromise<GetConfigAggregateType<T>>

    /**
     * Group by Config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: configGroupByArgs['orderBy'] }
        : { orderBy?: configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the config model
   */
  readonly fields: configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the config model
   */
  interface configFieldRefs {
    readonly id: FieldRef<"config", 'String'>
    readonly verify_amount: FieldRef<"config", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * config findUnique
   */
  export type configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findUniqueOrThrow
   */
  export type configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where: configWhereUniqueInput
  }

  /**
   * config findFirst
   */
  export type configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findFirstOrThrow
   */
  export type configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter, which config to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of configs.
     */
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config findMany
   */
  export type configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter, which configs to fetch.
     */
    where?: configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of configs to fetch.
     */
    orderBy?: configOrderByWithRelationInput | configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing configs.
     */
    cursor?: configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` configs.
     */
    skip?: number
    distinct?: ConfigScalarFieldEnum | ConfigScalarFieldEnum[]
  }

  /**
   * config create
   */
  export type configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data needed to create a config.
     */
    data: XOR<configCreateInput, configUncheckedCreateInput>
  }

  /**
   * config createMany
   */
  export type configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * config createManyAndReturn
   */
  export type configCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data used to create many configs.
     */
    data: configCreateManyInput | configCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * config update
   */
  export type configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data needed to update a config.
     */
    data: XOR<configUpdateInput, configUncheckedUpdateInput>
    /**
     * Choose, which config to update.
     */
    where: configWhereUniqueInput
  }

  /**
   * config updateMany
   */
  export type configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
    /**
     * Limit how many configs to update.
     */
    limit?: number
  }

  /**
   * config updateManyAndReturn
   */
  export type configUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The data used to update configs.
     */
    data: XOR<configUpdateManyMutationInput, configUncheckedUpdateManyInput>
    /**
     * Filter which configs to update
     */
    where?: configWhereInput
    /**
     * Limit how many configs to update.
     */
    limit?: number
  }

  /**
   * config upsert
   */
  export type configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * The filter to search for the config to update in case it exists.
     */
    where: configWhereUniqueInput
    /**
     * In case the config found by the `where` argument doesn't exist, create a new config with this data.
     */
    create: XOR<configCreateInput, configUncheckedCreateInput>
    /**
     * In case the config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<configUpdateInput, configUncheckedUpdateInput>
  }

  /**
   * config delete
   */
  export type configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
    /**
     * Filter which config to delete.
     */
    where: configWhereUniqueInput
  }

  /**
   * config deleteMany
   */
  export type configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which configs to delete
     */
    where?: configWhereInput
    /**
     * Limit how many configs to delete.
     */
    limit?: number
  }

  /**
   * config without action
   */
  export type configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the config
     */
    select?: configSelect<ExtArgs> | null
    /**
     * Omit specific fields from the config
     */
    omit?: configOmit<ExtArgs> | null
  }


  /**
   * Model email_otp
   */

  export type AggregateEmail_otp = {
    _count: Email_otpCountAggregateOutputType | null
    _min: Email_otpMinAggregateOutputType | null
    _max: Email_otpMaxAggregateOutputType | null
  }

  export type Email_otpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expired_at: Date | null
    last_request_at: Date | null
  }

  export type Email_otpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expired_at: Date | null
    last_request_at: Date | null
  }

  export type Email_otpCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    expired_at: number
    last_request_at: number
    _all: number
  }


  export type Email_otpMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
  }

  export type Email_otpMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
  }

  export type Email_otpCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
    _all?: true
  }

  export type Email_otpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_otp to aggregate.
     */
    where?: email_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_otps to fetch.
     */
    orderBy?: email_otpOrderByWithRelationInput | email_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: email_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned email_otps
    **/
    _count?: true | Email_otpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Email_otpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Email_otpMaxAggregateInputType
  }

  export type GetEmail_otpAggregateType<T extends Email_otpAggregateArgs> = {
        [P in keyof T & keyof AggregateEmail_otp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmail_otp[P]>
      : GetScalarType<T[P], AggregateEmail_otp[P]>
  }




  export type email_otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: email_otpWhereInput
    orderBy?: email_otpOrderByWithAggregationInput | email_otpOrderByWithAggregationInput[]
    by: Email_otpScalarFieldEnum[] | Email_otpScalarFieldEnum
    having?: email_otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Email_otpCountAggregateInputType | true
    _min?: Email_otpMinAggregateInputType
    _max?: Email_otpMaxAggregateInputType
  }

  export type Email_otpGroupByOutputType = {
    id: string
    userId: string
    otp: string
    expired_at: Date
    last_request_at: Date
    _count: Email_otpCountAggregateOutputType | null
    _min: Email_otpMinAggregateOutputType | null
    _max: Email_otpMaxAggregateOutputType | null
  }

  type GetEmail_otpGroupByPayload<T extends email_otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Email_otpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Email_otpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Email_otpGroupByOutputType[P]>
            : GetScalarType<T[P], Email_otpGroupByOutputType[P]>
        }
      >
    >


  export type email_otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["email_otp"]>

  export type email_otpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["email_otp"]>

  export type email_otpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["email_otp"]>

  export type email_otpSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }

  export type email_otpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "otp" | "expired_at" | "last_request_at", ExtArgs["result"]["email_otp"]>

  export type $email_otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "email_otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otp: string
      expired_at: Date
      last_request_at: Date
    }, ExtArgs["result"]["email_otp"]>
    composites: {}
  }

  type email_otpGetPayload<S extends boolean | null | undefined | email_otpDefaultArgs> = $Result.GetResult<Prisma.$email_otpPayload, S>

  type email_otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<email_otpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Email_otpCountAggregateInputType | true
    }

  export interface email_otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['email_otp'], meta: { name: 'email_otp' } }
    /**
     * Find zero or one Email_otp that matches the filter.
     * @param {email_otpFindUniqueArgs} args - Arguments to find a Email_otp
     * @example
     * // Get one Email_otp
     * const email_otp = await prisma.email_otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends email_otpFindUniqueArgs>(args: SelectSubset<T, email_otpFindUniqueArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Email_otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {email_otpFindUniqueOrThrowArgs} args - Arguments to find a Email_otp
     * @example
     * // Get one Email_otp
     * const email_otp = await prisma.email_otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends email_otpFindUniqueOrThrowArgs>(args: SelectSubset<T, email_otpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpFindFirstArgs} args - Arguments to find a Email_otp
     * @example
     * // Get one Email_otp
     * const email_otp = await prisma.email_otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends email_otpFindFirstArgs>(args?: SelectSubset<T, email_otpFindFirstArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Email_otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpFindFirstOrThrowArgs} args - Arguments to find a Email_otp
     * @example
     * // Get one Email_otp
     * const email_otp = await prisma.email_otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends email_otpFindFirstOrThrowArgs>(args?: SelectSubset<T, email_otpFindFirstOrThrowArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Email_otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Email_otps
     * const email_otps = await prisma.email_otp.findMany()
     * 
     * // Get first 10 Email_otps
     * const email_otps = await prisma.email_otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const email_otpWithIdOnly = await prisma.email_otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends email_otpFindManyArgs>(args?: SelectSubset<T, email_otpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Email_otp.
     * @param {email_otpCreateArgs} args - Arguments to create a Email_otp.
     * @example
     * // Create one Email_otp
     * const Email_otp = await prisma.email_otp.create({
     *   data: {
     *     // ... data to create a Email_otp
     *   }
     * })
     * 
     */
    create<T extends email_otpCreateArgs>(args: SelectSubset<T, email_otpCreateArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Email_otps.
     * @param {email_otpCreateManyArgs} args - Arguments to create many Email_otps.
     * @example
     * // Create many Email_otps
     * const email_otp = await prisma.email_otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends email_otpCreateManyArgs>(args?: SelectSubset<T, email_otpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Email_otps and returns the data saved in the database.
     * @param {email_otpCreateManyAndReturnArgs} args - Arguments to create many Email_otps.
     * @example
     * // Create many Email_otps
     * const email_otp = await prisma.email_otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Email_otps and only return the `id`
     * const email_otpWithIdOnly = await prisma.email_otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends email_otpCreateManyAndReturnArgs>(args?: SelectSubset<T, email_otpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Email_otp.
     * @param {email_otpDeleteArgs} args - Arguments to delete one Email_otp.
     * @example
     * // Delete one Email_otp
     * const Email_otp = await prisma.email_otp.delete({
     *   where: {
     *     // ... filter to delete one Email_otp
     *   }
     * })
     * 
     */
    delete<T extends email_otpDeleteArgs>(args: SelectSubset<T, email_otpDeleteArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Email_otp.
     * @param {email_otpUpdateArgs} args - Arguments to update one Email_otp.
     * @example
     * // Update one Email_otp
     * const email_otp = await prisma.email_otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends email_otpUpdateArgs>(args: SelectSubset<T, email_otpUpdateArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Email_otps.
     * @param {email_otpDeleteManyArgs} args - Arguments to filter Email_otps to delete.
     * @example
     * // Delete a few Email_otps
     * const { count } = await prisma.email_otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends email_otpDeleteManyArgs>(args?: SelectSubset<T, email_otpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Email_otps
     * const email_otp = await prisma.email_otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends email_otpUpdateManyArgs>(args: SelectSubset<T, email_otpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Email_otps and returns the data updated in the database.
     * @param {email_otpUpdateManyAndReturnArgs} args - Arguments to update many Email_otps.
     * @example
     * // Update many Email_otps
     * const email_otp = await prisma.email_otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Email_otps and only return the `id`
     * const email_otpWithIdOnly = await prisma.email_otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends email_otpUpdateManyAndReturnArgs>(args: SelectSubset<T, email_otpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Email_otp.
     * @param {email_otpUpsertArgs} args - Arguments to update or create a Email_otp.
     * @example
     * // Update or create a Email_otp
     * const email_otp = await prisma.email_otp.upsert({
     *   create: {
     *     // ... data to create a Email_otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Email_otp we want to update
     *   }
     * })
     */
    upsert<T extends email_otpUpsertArgs>(args: SelectSubset<T, email_otpUpsertArgs<ExtArgs>>): Prisma__email_otpClient<$Result.GetResult<Prisma.$email_otpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Email_otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpCountArgs} args - Arguments to filter Email_otps to count.
     * @example
     * // Count the number of Email_otps
     * const count = await prisma.email_otp.count({
     *   where: {
     *     // ... the filter for the Email_otps we want to count
     *   }
     * })
    **/
    count<T extends email_otpCountArgs>(
      args?: Subset<T, email_otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Email_otpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Email_otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Email_otpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Email_otpAggregateArgs>(args: Subset<T, Email_otpAggregateArgs>): Prisma.PrismaPromise<GetEmail_otpAggregateType<T>>

    /**
     * Group by Email_otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {email_otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends email_otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: email_otpGroupByArgs['orderBy'] }
        : { orderBy?: email_otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, email_otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmail_otpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the email_otp model
   */
  readonly fields: email_otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for email_otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__email_otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the email_otp model
   */
  interface email_otpFieldRefs {
    readonly id: FieldRef<"email_otp", 'String'>
    readonly userId: FieldRef<"email_otp", 'String'>
    readonly otp: FieldRef<"email_otp", 'String'>
    readonly expired_at: FieldRef<"email_otp", 'DateTime'>
    readonly last_request_at: FieldRef<"email_otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * email_otp findUnique
   */
  export type email_otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter, which email_otp to fetch.
     */
    where: email_otpWhereUniqueInput
  }

  /**
   * email_otp findUniqueOrThrow
   */
  export type email_otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter, which email_otp to fetch.
     */
    where: email_otpWhereUniqueInput
  }

  /**
   * email_otp findFirst
   */
  export type email_otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter, which email_otp to fetch.
     */
    where?: email_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_otps to fetch.
     */
    orderBy?: email_otpOrderByWithRelationInput | email_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_otps.
     */
    cursor?: email_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_otps.
     */
    distinct?: Email_otpScalarFieldEnum | Email_otpScalarFieldEnum[]
  }

  /**
   * email_otp findFirstOrThrow
   */
  export type email_otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter, which email_otp to fetch.
     */
    where?: email_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_otps to fetch.
     */
    orderBy?: email_otpOrderByWithRelationInput | email_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for email_otps.
     */
    cursor?: email_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of email_otps.
     */
    distinct?: Email_otpScalarFieldEnum | Email_otpScalarFieldEnum[]
  }

  /**
   * email_otp findMany
   */
  export type email_otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter, which email_otps to fetch.
     */
    where?: email_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of email_otps to fetch.
     */
    orderBy?: email_otpOrderByWithRelationInput | email_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing email_otps.
     */
    cursor?: email_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` email_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` email_otps.
     */
    skip?: number
    distinct?: Email_otpScalarFieldEnum | Email_otpScalarFieldEnum[]
  }

  /**
   * email_otp create
   */
  export type email_otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * The data needed to create a email_otp.
     */
    data: XOR<email_otpCreateInput, email_otpUncheckedCreateInput>
  }

  /**
   * email_otp createMany
   */
  export type email_otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many email_otps.
     */
    data: email_otpCreateManyInput | email_otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_otp createManyAndReturn
   */
  export type email_otpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * The data used to create many email_otps.
     */
    data: email_otpCreateManyInput | email_otpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * email_otp update
   */
  export type email_otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * The data needed to update a email_otp.
     */
    data: XOR<email_otpUpdateInput, email_otpUncheckedUpdateInput>
    /**
     * Choose, which email_otp to update.
     */
    where: email_otpWhereUniqueInput
  }

  /**
   * email_otp updateMany
   */
  export type email_otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update email_otps.
     */
    data: XOR<email_otpUpdateManyMutationInput, email_otpUncheckedUpdateManyInput>
    /**
     * Filter which email_otps to update
     */
    where?: email_otpWhereInput
    /**
     * Limit how many email_otps to update.
     */
    limit?: number
  }

  /**
   * email_otp updateManyAndReturn
   */
  export type email_otpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * The data used to update email_otps.
     */
    data: XOR<email_otpUpdateManyMutationInput, email_otpUncheckedUpdateManyInput>
    /**
     * Filter which email_otps to update
     */
    where?: email_otpWhereInput
    /**
     * Limit how many email_otps to update.
     */
    limit?: number
  }

  /**
   * email_otp upsert
   */
  export type email_otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * The filter to search for the email_otp to update in case it exists.
     */
    where: email_otpWhereUniqueInput
    /**
     * In case the email_otp found by the `where` argument doesn't exist, create a new email_otp with this data.
     */
    create: XOR<email_otpCreateInput, email_otpUncheckedCreateInput>
    /**
     * In case the email_otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<email_otpUpdateInput, email_otpUncheckedUpdateInput>
  }

  /**
   * email_otp delete
   */
  export type email_otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
    /**
     * Filter which email_otp to delete.
     */
    where: email_otpWhereUniqueInput
  }

  /**
   * email_otp deleteMany
   */
  export type email_otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which email_otps to delete
     */
    where?: email_otpWhereInput
    /**
     * Limit how many email_otps to delete.
     */
    limit?: number
  }

  /**
   * email_otp without action
   */
  export type email_otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the email_otp
     */
    select?: email_otpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the email_otp
     */
    omit?: email_otpOmit<ExtArgs> | null
  }


  /**
   * Model followship
   */

  export type AggregateFollowship = {
    _count: FollowshipCountAggregateOutputType | null
    _min: FollowshipMinAggregateOutputType | null
    _max: FollowshipMaxAggregateOutputType | null
  }

  export type FollowshipMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    followedId: string | null
    followerId: string | null
  }

  export type FollowshipMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    followedId: string | null
    followerId: string | null
  }

  export type FollowshipCountAggregateOutputType = {
    id: number
    created_at: number
    followedId: number
    followerId: number
    _all: number
  }


  export type FollowshipMinAggregateInputType = {
    id?: true
    created_at?: true
    followedId?: true
    followerId?: true
  }

  export type FollowshipMaxAggregateInputType = {
    id?: true
    created_at?: true
    followedId?: true
    followerId?: true
  }

  export type FollowshipCountAggregateInputType = {
    id?: true
    created_at?: true
    followedId?: true
    followerId?: true
    _all?: true
  }

  export type FollowshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which followship to aggregate.
     */
    where?: followshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followships to fetch.
     */
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: followshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned followships
    **/
    _count?: true | FollowshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowshipMaxAggregateInputType
  }

  export type GetFollowshipAggregateType<T extends FollowshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowship[P]>
      : GetScalarType<T[P], AggregateFollowship[P]>
  }




  export type followshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followshipWhereInput
    orderBy?: followshipOrderByWithAggregationInput | followshipOrderByWithAggregationInput[]
    by: FollowshipScalarFieldEnum[] | FollowshipScalarFieldEnum
    having?: followshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowshipCountAggregateInputType | true
    _min?: FollowshipMinAggregateInputType
    _max?: FollowshipMaxAggregateInputType
  }

  export type FollowshipGroupByOutputType = {
    id: string
    created_at: Date
    followedId: string | null
    followerId: string | null
    _count: FollowshipCountAggregateOutputType | null
    _min: FollowshipMinAggregateOutputType | null
    _max: FollowshipMaxAggregateOutputType | null
  }

  type GetFollowshipGroupByPayload<T extends followshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowshipGroupByOutputType[P]>
            : GetScalarType<T[P], FollowshipGroupByOutputType[P]>
        }
      >
    >


  export type followshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    followedId?: boolean
    followerId?: boolean
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["followship"]>

  export type followshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    followedId?: boolean
    followerId?: boolean
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["followship"]>

  export type followshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    followedId?: boolean
    followerId?: boolean
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }, ExtArgs["result"]["followship"]>

  export type followshipSelectScalar = {
    id?: boolean
    created_at?: boolean
    followedId?: boolean
    followerId?: boolean
  }

  export type followshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "followedId" | "followerId", ExtArgs["result"]["followship"]>
  export type followshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }
  export type followshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }
  export type followshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_followship_followerIdTouser?: boolean | followship$user_followship_followerIdTouserArgs<ExtArgs>
    user_followship_followedIdTouser?: boolean | followship$user_followship_followedIdTouserArgs<ExtArgs>
  }

  export type $followshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "followship"
    objects: {
      user_followship_followerIdTouser: Prisma.$userPayload<ExtArgs> | null
      user_followship_followedIdTouser: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      followedId: string | null
      followerId: string | null
    }, ExtArgs["result"]["followship"]>
    composites: {}
  }

  type followshipGetPayload<S extends boolean | null | undefined | followshipDefaultArgs> = $Result.GetResult<Prisma.$followshipPayload, S>

  type followshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<followshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowshipCountAggregateInputType | true
    }

  export interface followshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['followship'], meta: { name: 'followship' } }
    /**
     * Find zero or one Followship that matches the filter.
     * @param {followshipFindUniqueArgs} args - Arguments to find a Followship
     * @example
     * // Get one Followship
     * const followship = await prisma.followship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends followshipFindUniqueArgs>(args: SelectSubset<T, followshipFindUniqueArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Followship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {followshipFindUniqueOrThrowArgs} args - Arguments to find a Followship
     * @example
     * // Get one Followship
     * const followship = await prisma.followship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends followshipFindUniqueOrThrowArgs>(args: SelectSubset<T, followshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipFindFirstArgs} args - Arguments to find a Followship
     * @example
     * // Get one Followship
     * const followship = await prisma.followship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends followshipFindFirstArgs>(args?: SelectSubset<T, followshipFindFirstArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Followship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipFindFirstOrThrowArgs} args - Arguments to find a Followship
     * @example
     * // Get one Followship
     * const followship = await prisma.followship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends followshipFindFirstOrThrowArgs>(args?: SelectSubset<T, followshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Followships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Followships
     * const followships = await prisma.followship.findMany()
     * 
     * // Get first 10 Followships
     * const followships = await prisma.followship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followshipWithIdOnly = await prisma.followship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends followshipFindManyArgs>(args?: SelectSubset<T, followshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Followship.
     * @param {followshipCreateArgs} args - Arguments to create a Followship.
     * @example
     * // Create one Followship
     * const Followship = await prisma.followship.create({
     *   data: {
     *     // ... data to create a Followship
     *   }
     * })
     * 
     */
    create<T extends followshipCreateArgs>(args: SelectSubset<T, followshipCreateArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Followships.
     * @param {followshipCreateManyArgs} args - Arguments to create many Followships.
     * @example
     * // Create many Followships
     * const followship = await prisma.followship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends followshipCreateManyArgs>(args?: SelectSubset<T, followshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Followships and returns the data saved in the database.
     * @param {followshipCreateManyAndReturnArgs} args - Arguments to create many Followships.
     * @example
     * // Create many Followships
     * const followship = await prisma.followship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Followships and only return the `id`
     * const followshipWithIdOnly = await prisma.followship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends followshipCreateManyAndReturnArgs>(args?: SelectSubset<T, followshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Followship.
     * @param {followshipDeleteArgs} args - Arguments to delete one Followship.
     * @example
     * // Delete one Followship
     * const Followship = await prisma.followship.delete({
     *   where: {
     *     // ... filter to delete one Followship
     *   }
     * })
     * 
     */
    delete<T extends followshipDeleteArgs>(args: SelectSubset<T, followshipDeleteArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Followship.
     * @param {followshipUpdateArgs} args - Arguments to update one Followship.
     * @example
     * // Update one Followship
     * const followship = await prisma.followship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends followshipUpdateArgs>(args: SelectSubset<T, followshipUpdateArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Followships.
     * @param {followshipDeleteManyArgs} args - Arguments to filter Followships to delete.
     * @example
     * // Delete a few Followships
     * const { count } = await prisma.followship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends followshipDeleteManyArgs>(args?: SelectSubset<T, followshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Followships
     * const followship = await prisma.followship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends followshipUpdateManyArgs>(args: SelectSubset<T, followshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Followships and returns the data updated in the database.
     * @param {followshipUpdateManyAndReturnArgs} args - Arguments to update many Followships.
     * @example
     * // Update many Followships
     * const followship = await prisma.followship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Followships and only return the `id`
     * const followshipWithIdOnly = await prisma.followship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends followshipUpdateManyAndReturnArgs>(args: SelectSubset<T, followshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Followship.
     * @param {followshipUpsertArgs} args - Arguments to update or create a Followship.
     * @example
     * // Update or create a Followship
     * const followship = await prisma.followship.upsert({
     *   create: {
     *     // ... data to create a Followship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Followship we want to update
     *   }
     * })
     */
    upsert<T extends followshipUpsertArgs>(args: SelectSubset<T, followshipUpsertArgs<ExtArgs>>): Prisma__followshipClient<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Followships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipCountArgs} args - Arguments to filter Followships to count.
     * @example
     * // Count the number of Followships
     * const count = await prisma.followship.count({
     *   where: {
     *     // ... the filter for the Followships we want to count
     *   }
     * })
    **/
    count<T extends followshipCountArgs>(
      args?: Subset<T, followshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Followship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowshipAggregateArgs>(args: Subset<T, FollowshipAggregateArgs>): Prisma.PrismaPromise<GetFollowshipAggregateType<T>>

    /**
     * Group by Followship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends followshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: followshipGroupByArgs['orderBy'] }
        : { orderBy?: followshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, followshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the followship model
   */
  readonly fields: followshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for followship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__followshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_followship_followerIdTouser<T extends followship$user_followship_followerIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, followship$user_followship_followerIdTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user_followship_followedIdTouser<T extends followship$user_followship_followedIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, followship$user_followship_followedIdTouserArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the followship model
   */
  interface followshipFieldRefs {
    readonly id: FieldRef<"followship", 'String'>
    readonly created_at: FieldRef<"followship", 'DateTime'>
    readonly followedId: FieldRef<"followship", 'String'>
    readonly followerId: FieldRef<"followship", 'String'>
  }
    

  // Custom InputTypes
  /**
   * followship findUnique
   */
  export type followshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter, which followship to fetch.
     */
    where: followshipWhereUniqueInput
  }

  /**
   * followship findUniqueOrThrow
   */
  export type followshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter, which followship to fetch.
     */
    where: followshipWhereUniqueInput
  }

  /**
   * followship findFirst
   */
  export type followshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter, which followship to fetch.
     */
    where?: followshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followships to fetch.
     */
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for followships.
     */
    cursor?: followshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of followships.
     */
    distinct?: FollowshipScalarFieldEnum | FollowshipScalarFieldEnum[]
  }

  /**
   * followship findFirstOrThrow
   */
  export type followshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter, which followship to fetch.
     */
    where?: followshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followships to fetch.
     */
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for followships.
     */
    cursor?: followshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of followships.
     */
    distinct?: FollowshipScalarFieldEnum | FollowshipScalarFieldEnum[]
  }

  /**
   * followship findMany
   */
  export type followshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter, which followships to fetch.
     */
    where?: followshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followships to fetch.
     */
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing followships.
     */
    cursor?: followshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followships.
     */
    skip?: number
    distinct?: FollowshipScalarFieldEnum | FollowshipScalarFieldEnum[]
  }

  /**
   * followship create
   */
  export type followshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * The data needed to create a followship.
     */
    data?: XOR<followshipCreateInput, followshipUncheckedCreateInput>
  }

  /**
   * followship createMany
   */
  export type followshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many followships.
     */
    data: followshipCreateManyInput | followshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * followship createManyAndReturn
   */
  export type followshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * The data used to create many followships.
     */
    data: followshipCreateManyInput | followshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * followship update
   */
  export type followshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * The data needed to update a followship.
     */
    data: XOR<followshipUpdateInput, followshipUncheckedUpdateInput>
    /**
     * Choose, which followship to update.
     */
    where: followshipWhereUniqueInput
  }

  /**
   * followship updateMany
   */
  export type followshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update followships.
     */
    data: XOR<followshipUpdateManyMutationInput, followshipUncheckedUpdateManyInput>
    /**
     * Filter which followships to update
     */
    where?: followshipWhereInput
    /**
     * Limit how many followships to update.
     */
    limit?: number
  }

  /**
   * followship updateManyAndReturn
   */
  export type followshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * The data used to update followships.
     */
    data: XOR<followshipUpdateManyMutationInput, followshipUncheckedUpdateManyInput>
    /**
     * Filter which followships to update
     */
    where?: followshipWhereInput
    /**
     * Limit how many followships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * followship upsert
   */
  export type followshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * The filter to search for the followship to update in case it exists.
     */
    where: followshipWhereUniqueInput
    /**
     * In case the followship found by the `where` argument doesn't exist, create a new followship with this data.
     */
    create: XOR<followshipCreateInput, followshipUncheckedCreateInput>
    /**
     * In case the followship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<followshipUpdateInput, followshipUncheckedUpdateInput>
  }

  /**
   * followship delete
   */
  export type followshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    /**
     * Filter which followship to delete.
     */
    where: followshipWhereUniqueInput
  }

  /**
   * followship deleteMany
   */
  export type followshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which followships to delete
     */
    where?: followshipWhereInput
    /**
     * Limit how many followships to delete.
     */
    limit?: number
  }

  /**
   * followship.user_followship_followerIdTouser
   */
  export type followship$user_followship_followerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * followship.user_followship_followedIdTouser
   */
  export type followship$user_followship_followedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * followship without action
   */
  export type followshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
  }


  /**
   * Model guest
   */

  export type AggregateGuest = {
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  export type GuestMinAggregateOutputType = {
    id: string | null
    password: string | null
    user_name: string | null
    avatar: string | null
    verify_photo: string | null
    verify: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    emailOTP: boolean | null
  }

  export type GuestMaxAggregateOutputType = {
    id: string | null
    password: string | null
    user_name: string | null
    avatar: string | null
    verify_photo: string | null
    verify: boolean | null
    created_at: Date | null
    updated_at: Date | null
    email: string | null
    emailOTP: boolean | null
  }

  export type GuestCountAggregateOutputType = {
    id: number
    password: number
    user_name: number
    avatar: number
    verify_photo: number
    verify: number
    created_at: number
    updated_at: number
    email: number
    emailOTP: number
    _all: number
  }


  export type GuestMinAggregateInputType = {
    id?: true
    password?: true
    user_name?: true
    avatar?: true
    verify_photo?: true
    verify?: true
    created_at?: true
    updated_at?: true
    email?: true
    emailOTP?: true
  }

  export type GuestMaxAggregateInputType = {
    id?: true
    password?: true
    user_name?: true
    avatar?: true
    verify_photo?: true
    verify?: true
    created_at?: true
    updated_at?: true
    email?: true
    emailOTP?: true
  }

  export type GuestCountAggregateInputType = {
    id?: true
    password?: true
    user_name?: true
    avatar?: true
    verify_photo?: true
    verify?: true
    created_at?: true
    updated_at?: true
    email?: true
    emailOTP?: true
    _all?: true
  }

  export type GuestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guest to aggregate.
     */
    where?: guestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guests to fetch.
     */
    orderBy?: guestOrderByWithRelationInput | guestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: guestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned guests
    **/
    _count?: true | GuestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GuestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GuestMaxAggregateInputType
  }

  export type GetGuestAggregateType<T extends GuestAggregateArgs> = {
        [P in keyof T & keyof AggregateGuest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGuest[P]>
      : GetScalarType<T[P], AggregateGuest[P]>
  }




  export type guestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: guestWhereInput
    orderBy?: guestOrderByWithAggregationInput | guestOrderByWithAggregationInput[]
    by: GuestScalarFieldEnum[] | GuestScalarFieldEnum
    having?: guestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GuestCountAggregateInputType | true
    _min?: GuestMinAggregateInputType
    _max?: GuestMaxAggregateInputType
  }

  export type GuestGroupByOutputType = {
    id: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at: Date
    updated_at: Date
    email: string
    emailOTP: boolean
    _count: GuestCountAggregateOutputType | null
    _min: GuestMinAggregateOutputType | null
    _max: GuestMaxAggregateOutputType | null
  }

  type GetGuestGroupByPayload<T extends guestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GuestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GuestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GuestGroupByOutputType[P]>
            : GetScalarType<T[P], GuestGroupByOutputType[P]>
        }
      >
    >


  export type guestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    user_name?: boolean
    avatar?: boolean
    verify_photo?: boolean
    verify?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: boolean | guest$activity_activity_subscriberIdToguestArgs<ExtArgs>
    activity_activity_guestIdToguest?: boolean | guest$activity_activity_guestIdToguestArgs<ExtArgs>
    invite_invite_invitedIdToguest?: boolean | guest$invite_invite_invitedIdToguestArgs<ExtArgs>
    invite_invite_inviterIdToguest?: boolean | guest$invite_invite_inviterIdToguestArgs<ExtArgs>
    praise?: boolean | guest$praiseArgs<ExtArgs>
    reward?: boolean | guest$rewardArgs<ExtArgs>
    user?: boolean | guest$userArgs<ExtArgs>
    warning?: boolean | guest$warningArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["guest"]>

  export type guestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    user_name?: boolean
    avatar?: boolean
    verify_photo?: boolean
    verify?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    emailOTP?: boolean
  }, ExtArgs["result"]["guest"]>

  export type guestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    password?: boolean
    user_name?: boolean
    avatar?: boolean
    verify_photo?: boolean
    verify?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    emailOTP?: boolean
  }, ExtArgs["result"]["guest"]>

  export type guestSelectScalar = {
    id?: boolean
    password?: boolean
    user_name?: boolean
    avatar?: boolean
    verify_photo?: boolean
    verify?: boolean
    created_at?: boolean
    updated_at?: boolean
    email?: boolean
    emailOTP?: boolean
  }

  export type guestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "password" | "user_name" | "avatar" | "verify_photo" | "verify" | "created_at" | "updated_at" | "email" | "emailOTP", ExtArgs["result"]["guest"]>
  export type guestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    activity_activity_subscriberIdToguest?: boolean | guest$activity_activity_subscriberIdToguestArgs<ExtArgs>
    activity_activity_guestIdToguest?: boolean | guest$activity_activity_guestIdToguestArgs<ExtArgs>
    invite_invite_invitedIdToguest?: boolean | guest$invite_invite_invitedIdToguestArgs<ExtArgs>
    invite_invite_inviterIdToguest?: boolean | guest$invite_invite_inviterIdToguestArgs<ExtArgs>
    praise?: boolean | guest$praiseArgs<ExtArgs>
    reward?: boolean | guest$rewardArgs<ExtArgs>
    user?: boolean | guest$userArgs<ExtArgs>
    warning?: boolean | guest$warningArgs<ExtArgs>
    _count?: boolean | GuestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type guestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type guestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $guestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "guest"
    objects: {
      activity_activity_subscriberIdToguest: Prisma.$activityPayload<ExtArgs>[]
      activity_activity_guestIdToguest: Prisma.$activityPayload<ExtArgs>[]
      invite_invite_invitedIdToguest: Prisma.$invitePayload<ExtArgs> | null
      invite_invite_inviterIdToguest: Prisma.$invitePayload<ExtArgs>[]
      praise: Prisma.$praisePayload<ExtArgs>[]
      reward: Prisma.$rewardPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
      warning: Prisma.$warningPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      password: string
      user_name: string
      avatar: string
      verify_photo: string
      verify: boolean
      created_at: Date
      updated_at: Date
      email: string
      emailOTP: boolean
    }, ExtArgs["result"]["guest"]>
    composites: {}
  }

  type guestGetPayload<S extends boolean | null | undefined | guestDefaultArgs> = $Result.GetResult<Prisma.$guestPayload, S>

  type guestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<guestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GuestCountAggregateInputType | true
    }

  export interface guestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['guest'], meta: { name: 'guest' } }
    /**
     * Find zero or one Guest that matches the filter.
     * @param {guestFindUniqueArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends guestFindUniqueArgs>(args: SelectSubset<T, guestFindUniqueArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Guest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {guestFindUniqueOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends guestFindUniqueOrThrowArgs>(args: SelectSubset<T, guestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestFindFirstArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends guestFindFirstArgs>(args?: SelectSubset<T, guestFindFirstArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Guest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestFindFirstOrThrowArgs} args - Arguments to find a Guest
     * @example
     * // Get one Guest
     * const guest = await prisma.guest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends guestFindFirstOrThrowArgs>(args?: SelectSubset<T, guestFindFirstOrThrowArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Guests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Guests
     * const guests = await prisma.guest.findMany()
     * 
     * // Get first 10 Guests
     * const guests = await prisma.guest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const guestWithIdOnly = await prisma.guest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends guestFindManyArgs>(args?: SelectSubset<T, guestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Guest.
     * @param {guestCreateArgs} args - Arguments to create a Guest.
     * @example
     * // Create one Guest
     * const Guest = await prisma.guest.create({
     *   data: {
     *     // ... data to create a Guest
     *   }
     * })
     * 
     */
    create<T extends guestCreateArgs>(args: SelectSubset<T, guestCreateArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Guests.
     * @param {guestCreateManyArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends guestCreateManyArgs>(args?: SelectSubset<T, guestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Guests and returns the data saved in the database.
     * @param {guestCreateManyAndReturnArgs} args - Arguments to create many Guests.
     * @example
     * // Create many Guests
     * const guest = await prisma.guest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends guestCreateManyAndReturnArgs>(args?: SelectSubset<T, guestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Guest.
     * @param {guestDeleteArgs} args - Arguments to delete one Guest.
     * @example
     * // Delete one Guest
     * const Guest = await prisma.guest.delete({
     *   where: {
     *     // ... filter to delete one Guest
     *   }
     * })
     * 
     */
    delete<T extends guestDeleteArgs>(args: SelectSubset<T, guestDeleteArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Guest.
     * @param {guestUpdateArgs} args - Arguments to update one Guest.
     * @example
     * // Update one Guest
     * const guest = await prisma.guest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends guestUpdateArgs>(args: SelectSubset<T, guestUpdateArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Guests.
     * @param {guestDeleteManyArgs} args - Arguments to filter Guests to delete.
     * @example
     * // Delete a few Guests
     * const { count } = await prisma.guest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends guestDeleteManyArgs>(args?: SelectSubset<T, guestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends guestUpdateManyArgs>(args: SelectSubset<T, guestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Guests and returns the data updated in the database.
     * @param {guestUpdateManyAndReturnArgs} args - Arguments to update many Guests.
     * @example
     * // Update many Guests
     * const guest = await prisma.guest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Guests and only return the `id`
     * const guestWithIdOnly = await prisma.guest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends guestUpdateManyAndReturnArgs>(args: SelectSubset<T, guestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Guest.
     * @param {guestUpsertArgs} args - Arguments to update or create a Guest.
     * @example
     * // Update or create a Guest
     * const guest = await prisma.guest.upsert({
     *   create: {
     *     // ... data to create a Guest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Guest we want to update
     *   }
     * })
     */
    upsert<T extends guestUpsertArgs>(args: SelectSubset<T, guestUpsertArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Guests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestCountArgs} args - Arguments to filter Guests to count.
     * @example
     * // Count the number of Guests
     * const count = await prisma.guest.count({
     *   where: {
     *     // ... the filter for the Guests we want to count
     *   }
     * })
    **/
    count<T extends guestCountArgs>(
      args?: Subset<T, guestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GuestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GuestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GuestAggregateArgs>(args: Subset<T, GuestAggregateArgs>): Prisma.PrismaPromise<GetGuestAggregateType<T>>

    /**
     * Group by Guest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {guestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends guestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: guestGroupByArgs['orderBy'] }
        : { orderBy?: guestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, guestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGuestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the guest model
   */
  readonly fields: guestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for guest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__guestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    activity_activity_subscriberIdToguest<T extends guest$activity_activity_subscriberIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, guest$activity_activity_subscriberIdToguestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activity_activity_guestIdToguest<T extends guest$activity_activity_guestIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, guest$activity_activity_guestIdToguestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$activityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invite_invite_invitedIdToguest<T extends guest$invite_invite_invitedIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, guest$invite_invite_invitedIdToguestArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    invite_invite_inviterIdToguest<T extends guest$invite_invite_inviterIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, guest$invite_invite_inviterIdToguestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    praise<T extends guest$praiseArgs<ExtArgs> = {}>(args?: Subset<T, guest$praiseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reward<T extends guest$rewardArgs<ExtArgs> = {}>(args?: Subset<T, guest$rewardArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends guest$userArgs<ExtArgs> = {}>(args?: Subset<T, guest$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    warning<T extends guest$warningArgs<ExtArgs> = {}>(args?: Subset<T, guest$warningArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the guest model
   */
  interface guestFieldRefs {
    readonly id: FieldRef<"guest", 'String'>
    readonly password: FieldRef<"guest", 'String'>
    readonly user_name: FieldRef<"guest", 'String'>
    readonly avatar: FieldRef<"guest", 'String'>
    readonly verify_photo: FieldRef<"guest", 'String'>
    readonly verify: FieldRef<"guest", 'Boolean'>
    readonly created_at: FieldRef<"guest", 'DateTime'>
    readonly updated_at: FieldRef<"guest", 'DateTime'>
    readonly email: FieldRef<"guest", 'String'>
    readonly emailOTP: FieldRef<"guest", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * guest findUnique
   */
  export type guestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter, which guest to fetch.
     */
    where: guestWhereUniqueInput
  }

  /**
   * guest findUniqueOrThrow
   */
  export type guestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter, which guest to fetch.
     */
    where: guestWhereUniqueInput
  }

  /**
   * guest findFirst
   */
  export type guestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter, which guest to fetch.
     */
    where?: guestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guests to fetch.
     */
    orderBy?: guestOrderByWithRelationInput | guestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guests.
     */
    cursor?: guestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * guest findFirstOrThrow
   */
  export type guestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter, which guest to fetch.
     */
    where?: guestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guests to fetch.
     */
    orderBy?: guestOrderByWithRelationInput | guestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for guests.
     */
    cursor?: guestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of guests.
     */
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * guest findMany
   */
  export type guestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter, which guests to fetch.
     */
    where?: guestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of guests to fetch.
     */
    orderBy?: guestOrderByWithRelationInput | guestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing guests.
     */
    cursor?: guestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` guests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` guests.
     */
    skip?: number
    distinct?: GuestScalarFieldEnum | GuestScalarFieldEnum[]
  }

  /**
   * guest create
   */
  export type guestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * The data needed to create a guest.
     */
    data: XOR<guestCreateInput, guestUncheckedCreateInput>
  }

  /**
   * guest createMany
   */
  export type guestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many guests.
     */
    data: guestCreateManyInput | guestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guest createManyAndReturn
   */
  export type guestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * The data used to create many guests.
     */
    data: guestCreateManyInput | guestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * guest update
   */
  export type guestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * The data needed to update a guest.
     */
    data: XOR<guestUpdateInput, guestUncheckedUpdateInput>
    /**
     * Choose, which guest to update.
     */
    where: guestWhereUniqueInput
  }

  /**
   * guest updateMany
   */
  export type guestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update guests.
     */
    data: XOR<guestUpdateManyMutationInput, guestUncheckedUpdateManyInput>
    /**
     * Filter which guests to update
     */
    where?: guestWhereInput
    /**
     * Limit how many guests to update.
     */
    limit?: number
  }

  /**
   * guest updateManyAndReturn
   */
  export type guestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * The data used to update guests.
     */
    data: XOR<guestUpdateManyMutationInput, guestUncheckedUpdateManyInput>
    /**
     * Filter which guests to update
     */
    where?: guestWhereInput
    /**
     * Limit how many guests to update.
     */
    limit?: number
  }

  /**
   * guest upsert
   */
  export type guestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * The filter to search for the guest to update in case it exists.
     */
    where: guestWhereUniqueInput
    /**
     * In case the guest found by the `where` argument doesn't exist, create a new guest with this data.
     */
    create: XOR<guestCreateInput, guestUncheckedCreateInput>
    /**
     * In case the guest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<guestUpdateInput, guestUncheckedUpdateInput>
  }

  /**
   * guest delete
   */
  export type guestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    /**
     * Filter which guest to delete.
     */
    where: guestWhereUniqueInput
  }

  /**
   * guest deleteMany
   */
  export type guestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which guests to delete
     */
    where?: guestWhereInput
    /**
     * Limit how many guests to delete.
     */
    limit?: number
  }

  /**
   * guest.activity_activity_subscriberIdToguest
   */
  export type guest$activity_activity_subscriberIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    where?: activityWhereInput
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    cursor?: activityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * guest.activity_activity_guestIdToguest
   */
  export type guest$activity_activity_guestIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the activity
     */
    select?: activitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the activity
     */
    omit?: activityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: activityInclude<ExtArgs> | null
    where?: activityWhereInput
    orderBy?: activityOrderByWithRelationInput | activityOrderByWithRelationInput[]
    cursor?: activityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityScalarFieldEnum | ActivityScalarFieldEnum[]
  }

  /**
   * guest.invite_invite_invitedIdToguest
   */
  export type guest$invite_invite_invitedIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    where?: inviteWhereInput
  }

  /**
   * guest.invite_invite_inviterIdToguest
   */
  export type guest$invite_invite_inviterIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    where?: inviteWhereInput
    orderBy?: inviteOrderByWithRelationInput | inviteOrderByWithRelationInput[]
    cursor?: inviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * guest.praise
   */
  export type guest$praiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    where?: praiseWhereInput
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    cursor?: praiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PraiseScalarFieldEnum | PraiseScalarFieldEnum[]
  }

  /**
   * guest.reward
   */
  export type guest$rewardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    where?: rewardWhereInput
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    cursor?: rewardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * guest.user
   */
  export type guest$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * guest.warning
   */
  export type guest$warningArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    where?: warningWhereInput
  }

  /**
   * guest without action
   */
  export type guestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
  }


  /**
   * Model image_message
   */

  export type AggregateImage_message = {
    _count: Image_messageCountAggregateOutputType | null
    _min: Image_messageMinAggregateOutputType | null
    _max: Image_messageMaxAggregateOutputType | null
  }

  export type Image_messageMinAggregateOutputType = {
    id: string | null
    image: string | null
    created_at: Date | null
    updated_at: Date | null
    message_id: string | null
  }

  export type Image_messageMaxAggregateOutputType = {
    id: string | null
    image: string | null
    created_at: Date | null
    updated_at: Date | null
    message_id: string | null
  }

  export type Image_messageCountAggregateOutputType = {
    id: number
    image: number
    created_at: number
    updated_at: number
    message_id: number
    _all: number
  }


  export type Image_messageMinAggregateInputType = {
    id?: true
    image?: true
    created_at?: true
    updated_at?: true
    message_id?: true
  }

  export type Image_messageMaxAggregateInputType = {
    id?: true
    image?: true
    created_at?: true
    updated_at?: true
    message_id?: true
  }

  export type Image_messageCountAggregateInputType = {
    id?: true
    image?: true
    created_at?: true
    updated_at?: true
    message_id?: true
    _all?: true
  }

  export type Image_messageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which image_message to aggregate.
     */
    where?: image_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_messages to fetch.
     */
    orderBy?: image_messageOrderByWithRelationInput | image_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: image_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned image_messages
    **/
    _count?: true | Image_messageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Image_messageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Image_messageMaxAggregateInputType
  }

  export type GetImage_messageAggregateType<T extends Image_messageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage_message]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage_message[P]>
      : GetScalarType<T[P], AggregateImage_message[P]>
  }




  export type image_messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: image_messageWhereInput
    orderBy?: image_messageOrderByWithAggregationInput | image_messageOrderByWithAggregationInput[]
    by: Image_messageScalarFieldEnum[] | Image_messageScalarFieldEnum
    having?: image_messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Image_messageCountAggregateInputType | true
    _min?: Image_messageMinAggregateInputType
    _max?: Image_messageMaxAggregateInputType
  }

  export type Image_messageGroupByOutputType = {
    id: string
    image: string
    created_at: Date
    updated_at: Date
    message_id: string | null
    _count: Image_messageCountAggregateOutputType | null
    _min: Image_messageMinAggregateOutputType | null
    _max: Image_messageMaxAggregateOutputType | null
  }

  type GetImage_messageGroupByPayload<T extends image_messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Image_messageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Image_messageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Image_messageGroupByOutputType[P]>
            : GetScalarType<T[P], Image_messageGroupByOutputType[P]>
        }
      >
    >


  export type image_messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    message_id?: boolean
    message?: boolean | image_message$messageArgs<ExtArgs>
  }, ExtArgs["result"]["image_message"]>

  export type image_messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    message_id?: boolean
    message?: boolean | image_message$messageArgs<ExtArgs>
  }, ExtArgs["result"]["image_message"]>

  export type image_messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    message_id?: boolean
    message?: boolean | image_message$messageArgs<ExtArgs>
  }, ExtArgs["result"]["image_message"]>

  export type image_messageSelectScalar = {
    id?: boolean
    image?: boolean
    created_at?: boolean
    updated_at?: boolean
    message_id?: boolean
  }

  export type image_messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "image" | "created_at" | "updated_at" | "message_id", ExtArgs["result"]["image_message"]>
  export type image_messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | image_message$messageArgs<ExtArgs>
  }
  export type image_messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | image_message$messageArgs<ExtArgs>
  }
  export type image_messageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | image_message$messageArgs<ExtArgs>
  }

  export type $image_messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "image_message"
    objects: {
      message: Prisma.$messagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      image: string
      created_at: Date
      updated_at: Date
      message_id: string | null
    }, ExtArgs["result"]["image_message"]>
    composites: {}
  }

  type image_messageGetPayload<S extends boolean | null | undefined | image_messageDefaultArgs> = $Result.GetResult<Prisma.$image_messagePayload, S>

  type image_messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<image_messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Image_messageCountAggregateInputType | true
    }

  export interface image_messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['image_message'], meta: { name: 'image_message' } }
    /**
     * Find zero or one Image_message that matches the filter.
     * @param {image_messageFindUniqueArgs} args - Arguments to find a Image_message
     * @example
     * // Get one Image_message
     * const image_message = await prisma.image_message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends image_messageFindUniqueArgs>(args: SelectSubset<T, image_messageFindUniqueArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image_message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {image_messageFindUniqueOrThrowArgs} args - Arguments to find a Image_message
     * @example
     * // Get one Image_message
     * const image_message = await prisma.image_message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends image_messageFindUniqueOrThrowArgs>(args: SelectSubset<T, image_messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image_message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageFindFirstArgs} args - Arguments to find a Image_message
     * @example
     * // Get one Image_message
     * const image_message = await prisma.image_message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends image_messageFindFirstArgs>(args?: SelectSubset<T, image_messageFindFirstArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image_message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageFindFirstOrThrowArgs} args - Arguments to find a Image_message
     * @example
     * // Get one Image_message
     * const image_message = await prisma.image_message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends image_messageFindFirstOrThrowArgs>(args?: SelectSubset<T, image_messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Image_messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Image_messages
     * const image_messages = await prisma.image_message.findMany()
     * 
     * // Get first 10 Image_messages
     * const image_messages = await prisma.image_message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const image_messageWithIdOnly = await prisma.image_message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends image_messageFindManyArgs>(args?: SelectSubset<T, image_messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image_message.
     * @param {image_messageCreateArgs} args - Arguments to create a Image_message.
     * @example
     * // Create one Image_message
     * const Image_message = await prisma.image_message.create({
     *   data: {
     *     // ... data to create a Image_message
     *   }
     * })
     * 
     */
    create<T extends image_messageCreateArgs>(args: SelectSubset<T, image_messageCreateArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Image_messages.
     * @param {image_messageCreateManyArgs} args - Arguments to create many Image_messages.
     * @example
     * // Create many Image_messages
     * const image_message = await prisma.image_message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends image_messageCreateManyArgs>(args?: SelectSubset<T, image_messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Image_messages and returns the data saved in the database.
     * @param {image_messageCreateManyAndReturnArgs} args - Arguments to create many Image_messages.
     * @example
     * // Create many Image_messages
     * const image_message = await prisma.image_message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Image_messages and only return the `id`
     * const image_messageWithIdOnly = await prisma.image_message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends image_messageCreateManyAndReturnArgs>(args?: SelectSubset<T, image_messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image_message.
     * @param {image_messageDeleteArgs} args - Arguments to delete one Image_message.
     * @example
     * // Delete one Image_message
     * const Image_message = await prisma.image_message.delete({
     *   where: {
     *     // ... filter to delete one Image_message
     *   }
     * })
     * 
     */
    delete<T extends image_messageDeleteArgs>(args: SelectSubset<T, image_messageDeleteArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image_message.
     * @param {image_messageUpdateArgs} args - Arguments to update one Image_message.
     * @example
     * // Update one Image_message
     * const image_message = await prisma.image_message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends image_messageUpdateArgs>(args: SelectSubset<T, image_messageUpdateArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Image_messages.
     * @param {image_messageDeleteManyArgs} args - Arguments to filter Image_messages to delete.
     * @example
     * // Delete a few Image_messages
     * const { count } = await prisma.image_message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends image_messageDeleteManyArgs>(args?: SelectSubset<T, image_messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Image_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Image_messages
     * const image_message = await prisma.image_message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends image_messageUpdateManyArgs>(args: SelectSubset<T, image_messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Image_messages and returns the data updated in the database.
     * @param {image_messageUpdateManyAndReturnArgs} args - Arguments to update many Image_messages.
     * @example
     * // Update many Image_messages
     * const image_message = await prisma.image_message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Image_messages and only return the `id`
     * const image_messageWithIdOnly = await prisma.image_message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends image_messageUpdateManyAndReturnArgs>(args: SelectSubset<T, image_messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image_message.
     * @param {image_messageUpsertArgs} args - Arguments to update or create a Image_message.
     * @example
     * // Update or create a Image_message
     * const image_message = await prisma.image_message.upsert({
     *   create: {
     *     // ... data to create a Image_message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image_message we want to update
     *   }
     * })
     */
    upsert<T extends image_messageUpsertArgs>(args: SelectSubset<T, image_messageUpsertArgs<ExtArgs>>): Prisma__image_messageClient<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Image_messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageCountArgs} args - Arguments to filter Image_messages to count.
     * @example
     * // Count the number of Image_messages
     * const count = await prisma.image_message.count({
     *   where: {
     *     // ... the filter for the Image_messages we want to count
     *   }
     * })
    **/
    count<T extends image_messageCountArgs>(
      args?: Subset<T, image_messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Image_messageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Image_messageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Image_messageAggregateArgs>(args: Subset<T, Image_messageAggregateArgs>): Prisma.PrismaPromise<GetImage_messageAggregateType<T>>

    /**
     * Group by Image_message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {image_messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends image_messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: image_messageGroupByArgs['orderBy'] }
        : { orderBy?: image_messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, image_messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImage_messageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the image_message model
   */
  readonly fields: image_messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for image_message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__image_messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends image_message$messageArgs<ExtArgs> = {}>(args?: Subset<T, image_message$messageArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the image_message model
   */
  interface image_messageFieldRefs {
    readonly id: FieldRef<"image_message", 'String'>
    readonly image: FieldRef<"image_message", 'String'>
    readonly created_at: FieldRef<"image_message", 'DateTime'>
    readonly updated_at: FieldRef<"image_message", 'DateTime'>
    readonly message_id: FieldRef<"image_message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * image_message findUnique
   */
  export type image_messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter, which image_message to fetch.
     */
    where: image_messageWhereUniqueInput
  }

  /**
   * image_message findUniqueOrThrow
   */
  export type image_messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter, which image_message to fetch.
     */
    where: image_messageWhereUniqueInput
  }

  /**
   * image_message findFirst
   */
  export type image_messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter, which image_message to fetch.
     */
    where?: image_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_messages to fetch.
     */
    orderBy?: image_messageOrderByWithRelationInput | image_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for image_messages.
     */
    cursor?: image_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of image_messages.
     */
    distinct?: Image_messageScalarFieldEnum | Image_messageScalarFieldEnum[]
  }

  /**
   * image_message findFirstOrThrow
   */
  export type image_messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter, which image_message to fetch.
     */
    where?: image_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_messages to fetch.
     */
    orderBy?: image_messageOrderByWithRelationInput | image_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for image_messages.
     */
    cursor?: image_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of image_messages.
     */
    distinct?: Image_messageScalarFieldEnum | Image_messageScalarFieldEnum[]
  }

  /**
   * image_message findMany
   */
  export type image_messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter, which image_messages to fetch.
     */
    where?: image_messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of image_messages to fetch.
     */
    orderBy?: image_messageOrderByWithRelationInput | image_messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing image_messages.
     */
    cursor?: image_messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` image_messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` image_messages.
     */
    skip?: number
    distinct?: Image_messageScalarFieldEnum | Image_messageScalarFieldEnum[]
  }

  /**
   * image_message create
   */
  export type image_messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * The data needed to create a image_message.
     */
    data: XOR<image_messageCreateInput, image_messageUncheckedCreateInput>
  }

  /**
   * image_message createMany
   */
  export type image_messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many image_messages.
     */
    data: image_messageCreateManyInput | image_messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * image_message createManyAndReturn
   */
  export type image_messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * The data used to create many image_messages.
     */
    data: image_messageCreateManyInput | image_messageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * image_message update
   */
  export type image_messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * The data needed to update a image_message.
     */
    data: XOR<image_messageUpdateInput, image_messageUncheckedUpdateInput>
    /**
     * Choose, which image_message to update.
     */
    where: image_messageWhereUniqueInput
  }

  /**
   * image_message updateMany
   */
  export type image_messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update image_messages.
     */
    data: XOR<image_messageUpdateManyMutationInput, image_messageUncheckedUpdateManyInput>
    /**
     * Filter which image_messages to update
     */
    where?: image_messageWhereInput
    /**
     * Limit how many image_messages to update.
     */
    limit?: number
  }

  /**
   * image_message updateManyAndReturn
   */
  export type image_messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * The data used to update image_messages.
     */
    data: XOR<image_messageUpdateManyMutationInput, image_messageUncheckedUpdateManyInput>
    /**
     * Filter which image_messages to update
     */
    where?: image_messageWhereInput
    /**
     * Limit how many image_messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * image_message upsert
   */
  export type image_messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * The filter to search for the image_message to update in case it exists.
     */
    where: image_messageWhereUniqueInput
    /**
     * In case the image_message found by the `where` argument doesn't exist, create a new image_message with this data.
     */
    create: XOR<image_messageCreateInput, image_messageUncheckedCreateInput>
    /**
     * In case the image_message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<image_messageUpdateInput, image_messageUncheckedUpdateInput>
  }

  /**
   * image_message delete
   */
  export type image_messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    /**
     * Filter which image_message to delete.
     */
    where: image_messageWhereUniqueInput
  }

  /**
   * image_message deleteMany
   */
  export type image_messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which image_messages to delete
     */
    where?: image_messageWhereInput
    /**
     * Limit how many image_messages to delete.
     */
    limit?: number
  }

  /**
   * image_message.message
   */
  export type image_message$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
  }

  /**
   * image_message without action
   */
  export type image_messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
  }


  /**
   * Model invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteMinAggregateOutputType = {
    id: string | null
    created_at: Date | null
    inviterId: string | null
    invitedId: string | null
  }

  export type InviteMaxAggregateOutputType = {
    id: string | null
    created_at: Date | null
    inviterId: string | null
    invitedId: string | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    created_at: number
    inviterId: number
    invitedId: number
    _all: number
  }


  export type InviteMinAggregateInputType = {
    id?: true
    created_at?: true
    inviterId?: true
    invitedId?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    created_at?: true
    inviterId?: true
    invitedId?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    created_at?: true
    inviterId?: true
    invitedId?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invite to aggregate.
     */
    where?: inviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invites to fetch.
     */
    orderBy?: inviteOrderByWithRelationInput | inviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: inviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type inviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: inviteWhereInput
    orderBy?: inviteOrderByWithAggregationInput | inviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: inviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: string
    created_at: Date
    inviterId: string | null
    invitedId: string | null
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends inviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type inviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    inviterId?: boolean
    invitedId?: boolean
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type inviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    inviterId?: boolean
    invitedId?: boolean
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type inviteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    created_at?: boolean
    inviterId?: boolean
    invitedId?: boolean
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type inviteSelectScalar = {
    id?: boolean
    created_at?: boolean
    inviterId?: boolean
    invitedId?: boolean
  }

  export type inviteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "created_at" | "inviterId" | "invitedId", ExtArgs["result"]["invite"]>
  export type inviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }
  export type inviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }
  export type inviteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest_invite_invitedIdToguest?: boolean | invite$guest_invite_invitedIdToguestArgs<ExtArgs>
    guest_invite_inviterIdToguest?: boolean | invite$guest_invite_inviterIdToguestArgs<ExtArgs>
  }

  export type $invitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invite"
    objects: {
      guest_invite_invitedIdToguest: Prisma.$guestPayload<ExtArgs> | null
      guest_invite_inviterIdToguest: Prisma.$guestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      created_at: Date
      inviterId: string | null
      invitedId: string | null
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type inviteGetPayload<S extends boolean | null | undefined | inviteDefaultArgs> = $Result.GetResult<Prisma.$invitePayload, S>

  type inviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<inviteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface inviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invite'], meta: { name: 'invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {inviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends inviteFindUniqueArgs>(args: SelectSubset<T, inviteFindUniqueArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {inviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends inviteFindUniqueOrThrowArgs>(args: SelectSubset<T, inviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends inviteFindFirstArgs>(args?: SelectSubset<T, inviteFindFirstArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends inviteFindFirstOrThrowArgs>(args?: SelectSubset<T, inviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends inviteFindManyArgs>(args?: SelectSubset<T, inviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invite.
     * @param {inviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends inviteCreateArgs>(args: SelectSubset<T, inviteCreateArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invites.
     * @param {inviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends inviteCreateManyArgs>(args?: SelectSubset<T, inviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {inviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends inviteCreateManyAndReturnArgs>(args?: SelectSubset<T, inviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invite.
     * @param {inviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends inviteDeleteArgs>(args: SelectSubset<T, inviteDeleteArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invite.
     * @param {inviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends inviteUpdateArgs>(args: SelectSubset<T, inviteUpdateArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invites.
     * @param {inviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends inviteDeleteManyArgs>(args?: SelectSubset<T, inviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends inviteUpdateManyArgs>(args: SelectSubset<T, inviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites and returns the data updated in the database.
     * @param {inviteUpdateManyAndReturnArgs} args - Arguments to update many Invites.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends inviteUpdateManyAndReturnArgs>(args: SelectSubset<T, inviteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invite.
     * @param {inviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends inviteUpsertArgs>(args: SelectSubset<T, inviteUpsertArgs<ExtArgs>>): Prisma__inviteClient<$Result.GetResult<Prisma.$invitePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends inviteCountArgs>(
      args?: Subset<T, inviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {inviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends inviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: inviteGroupByArgs['orderBy'] }
        : { orderBy?: inviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, inviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invite model
   */
  readonly fields: inviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__inviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest_invite_invitedIdToguest<T extends invite$guest_invite_invitedIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, invite$guest_invite_invitedIdToguestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    guest_invite_inviterIdToguest<T extends invite$guest_invite_inviterIdToguestArgs<ExtArgs> = {}>(args?: Subset<T, invite$guest_invite_inviterIdToguestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invite model
   */
  interface inviteFieldRefs {
    readonly id: FieldRef<"invite", 'String'>
    readonly created_at: FieldRef<"invite", 'DateTime'>
    readonly inviterId: FieldRef<"invite", 'String'>
    readonly invitedId: FieldRef<"invite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * invite findUnique
   */
  export type inviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter, which invite to fetch.
     */
    where: inviteWhereUniqueInput
  }

  /**
   * invite findUniqueOrThrow
   */
  export type inviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter, which invite to fetch.
     */
    where: inviteWhereUniqueInput
  }

  /**
   * invite findFirst
   */
  export type inviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter, which invite to fetch.
     */
    where?: inviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invites to fetch.
     */
    orderBy?: inviteOrderByWithRelationInput | inviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invites.
     */
    cursor?: inviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * invite findFirstOrThrow
   */
  export type inviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter, which invite to fetch.
     */
    where?: inviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invites to fetch.
     */
    orderBy?: inviteOrderByWithRelationInput | inviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invites.
     */
    cursor?: inviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * invite findMany
   */
  export type inviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter, which invites to fetch.
     */
    where?: inviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invites to fetch.
     */
    orderBy?: inviteOrderByWithRelationInput | inviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invites.
     */
    cursor?: inviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * invite create
   */
  export type inviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * The data needed to create a invite.
     */
    data?: XOR<inviteCreateInput, inviteUncheckedCreateInput>
  }

  /**
   * invite createMany
   */
  export type inviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invites.
     */
    data: inviteCreateManyInput | inviteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * invite createManyAndReturn
   */
  export type inviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * The data used to create many invites.
     */
    data: inviteCreateManyInput | inviteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * invite update
   */
  export type inviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * The data needed to update a invite.
     */
    data: XOR<inviteUpdateInput, inviteUncheckedUpdateInput>
    /**
     * Choose, which invite to update.
     */
    where: inviteWhereUniqueInput
  }

  /**
   * invite updateMany
   */
  export type inviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invites.
     */
    data: XOR<inviteUpdateManyMutationInput, inviteUncheckedUpdateManyInput>
    /**
     * Filter which invites to update
     */
    where?: inviteWhereInput
    /**
     * Limit how many invites to update.
     */
    limit?: number
  }

  /**
   * invite updateManyAndReturn
   */
  export type inviteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * The data used to update invites.
     */
    data: XOR<inviteUpdateManyMutationInput, inviteUncheckedUpdateManyInput>
    /**
     * Filter which invites to update
     */
    where?: inviteWhereInput
    /**
     * Limit how many invites to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * invite upsert
   */
  export type inviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * The filter to search for the invite to update in case it exists.
     */
    where: inviteWhereUniqueInput
    /**
     * In case the invite found by the `where` argument doesn't exist, create a new invite with this data.
     */
    create: XOR<inviteCreateInput, inviteUncheckedCreateInput>
    /**
     * In case the invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<inviteUpdateInput, inviteUncheckedUpdateInput>
  }

  /**
   * invite delete
   */
  export type inviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
    /**
     * Filter which invite to delete.
     */
    where: inviteWhereUniqueInput
  }

  /**
   * invite deleteMany
   */
  export type inviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invites to delete
     */
    where?: inviteWhereInput
    /**
     * Limit how many invites to delete.
     */
    limit?: number
  }

  /**
   * invite.guest_invite_invitedIdToguest
   */
  export type invite$guest_invite_invitedIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * invite.guest_invite_inviterIdToguest
   */
  export type invite$guest_invite_inviterIdToguestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * invite without action
   */
  export type inviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invite
     */
    select?: inviteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the invite
     */
    omit?: inviteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: inviteInclude<ExtArgs> | null
  }


  /**
   * Model message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    order: number | null
  }

  export type MessageSumAggregateOutputType = {
    order: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    sender_id: string | null
    chatroom_id: string | null
    is_read: boolean | null
    order: number | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    message: string | null
    created_at: Date | null
    updated_at: Date | null
    sender_id: string | null
    chatroom_id: string | null
    is_read: boolean | null
    order: number | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    message: number
    created_at: number
    updated_at: number
    sender_id: number
    chatroom_id: number
    is_read: number
    order: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    order?: true
  }

  export type MessageSumAggregateInputType = {
    order?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    message?: true
    created_at?: true
    updated_at?: true
    sender_id?: true
    chatroom_id?: true
    is_read?: true
    order?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    message?: true
    created_at?: true
    updated_at?: true
    sender_id?: true
    chatroom_id?: true
    is_read?: true
    order?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    message?: true
    created_at?: true
    updated_at?: true
    sender_id?: true
    chatroom_id?: true
    is_read?: true
    order?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message to aggregate.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type messageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageWhereInput
    orderBy?: messageOrderByWithAggregationInput | messageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: messageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    message: string
    created_at: Date
    updated_at: Date
    sender_id: string | null
    chatroom_id: string | null
    is_read: boolean
    order: number
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends messageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type messageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    sender_id?: boolean
    chatroom_id?: boolean
    is_read?: boolean
    order?: boolean
    image_message?: boolean | message$image_messageArgs<ExtArgs>
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    sender_id?: boolean
    chatroom_id?: boolean
    is_read?: boolean
    order?: boolean
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    sender_id?: boolean
    chatroom_id?: boolean
    is_read?: boolean
    order?: boolean
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type messageSelectScalar = {
    id?: boolean
    message?: boolean
    created_at?: boolean
    updated_at?: boolean
    sender_id?: boolean
    chatroom_id?: boolean
    is_read?: boolean
    order?: boolean
  }

  export type messageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message" | "created_at" | "updated_at" | "sender_id" | "chatroom_id" | "is_read" | "order", ExtArgs["result"]["message"]>
  export type messageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image_message?: boolean | message$image_messageArgs<ExtArgs>
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type messageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }
  export type messageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatroom?: boolean | message$chatroomArgs<ExtArgs>
    user?: boolean | message$userArgs<ExtArgs>
  }

  export type $messagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message"
    objects: {
      image_message: Prisma.$image_messagePayload<ExtArgs>[]
      chatroom: Prisma.$chatroomPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      message: string
      created_at: Date
      updated_at: Date
      sender_id: string | null
      chatroom_id: string | null
      is_read: boolean
      order: number
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type messageGetPayload<S extends boolean | null | undefined | messageDefaultArgs> = $Result.GetResult<Prisma.$messagePayload, S>

  type messageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface messageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message'], meta: { name: 'message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {messageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageFindUniqueArgs>(args: SelectSubset<T, messageFindUniqueArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageFindUniqueOrThrowArgs>(args: SelectSubset<T, messageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageFindFirstArgs>(args?: SelectSubset<T, messageFindFirstArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageFindFirstOrThrowArgs>(args?: SelectSubset<T, messageFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageFindManyArgs>(args?: SelectSubset<T, messageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {messageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends messageCreateArgs>(args: SelectSubset<T, messageCreateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageCreateManyArgs>(args?: SelectSubset<T, messageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messageCreateManyAndReturnArgs>(args?: SelectSubset<T, messageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {messageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends messageDeleteArgs>(args: SelectSubset<T, messageDeleteArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {messageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageUpdateArgs>(args: SelectSubset<T, messageUpdateArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageDeleteManyArgs>(args?: SelectSubset<T, messageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageUpdateManyArgs>(args: SelectSubset<T, messageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messageUpdateManyAndReturnArgs>(args: SelectSubset<T, messageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {messageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends messageUpsertArgs>(args: SelectSubset<T, messageUpsertArgs<ExtArgs>>): Prisma__messageClient<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messageCountArgs>(
      args?: Subset<T, messageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageGroupByArgs['orderBy'] }
        : { orderBy?: messageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message model
   */
  readonly fields: messageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image_message<T extends message$image_messageArgs<ExtArgs> = {}>(args?: Subset<T, message$image_messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$image_messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatroom<T extends message$chatroomArgs<ExtArgs> = {}>(args?: Subset<T, message$chatroomArgs<ExtArgs>>): Prisma__chatroomClient<$Result.GetResult<Prisma.$chatroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends message$userArgs<ExtArgs> = {}>(args?: Subset<T, message$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message model
   */
  interface messageFieldRefs {
    readonly id: FieldRef<"message", 'String'>
    readonly message: FieldRef<"message", 'String'>
    readonly created_at: FieldRef<"message", 'DateTime'>
    readonly updated_at: FieldRef<"message", 'DateTime'>
    readonly sender_id: FieldRef<"message", 'String'>
    readonly chatroom_id: FieldRef<"message", 'String'>
    readonly is_read: FieldRef<"message", 'Boolean'>
    readonly order: FieldRef<"message", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * message findUnique
   */
  export type messageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findUniqueOrThrow
   */
  export type messageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message findFirst
   */
  export type messageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findFirstOrThrow
   */
  export type messageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which message to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message findMany
   */
  export type messageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * message create
   */
  export type messageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to create a message.
     */
    data?: XOR<messageCreateInput, messageUncheckedCreateInput>
  }

  /**
   * message createMany
   */
  export type messageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message createManyAndReturn
   */
  export type messageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messageCreateManyInput | messageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * message update
   */
  export type messageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The data needed to update a message.
     */
    data: XOR<messageUpdateInput, messageUncheckedUpdateInput>
    /**
     * Choose, which message to update.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message updateMany
   */
  export type messageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * message updateManyAndReturn
   */
  export type messageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * message upsert
   */
  export type messageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * The filter to search for the message to update in case it exists.
     */
    where: messageWhereUniqueInput
    /**
     * In case the message found by the `where` argument doesn't exist, create a new message with this data.
     */
    create: XOR<messageCreateInput, messageUncheckedCreateInput>
    /**
     * In case the message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageUpdateInput, messageUncheckedUpdateInput>
  }

  /**
   * message delete
   */
  export type messageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    /**
     * Filter which message to delete.
     */
    where: messageWhereUniqueInput
  }

  /**
   * message deleteMany
   */
  export type messageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messageWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * message.image_message
   */
  export type message$image_messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the image_message
     */
    select?: image_messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the image_message
     */
    omit?: image_messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: image_messageInclude<ExtArgs> | null
    where?: image_messageWhereInput
    orderBy?: image_messageOrderByWithRelationInput | image_messageOrderByWithRelationInput[]
    cursor?: image_messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Image_messageScalarFieldEnum | Image_messageScalarFieldEnum[]
  }

  /**
   * message.chatroom
   */
  export type message$chatroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom
     */
    select?: chatroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom
     */
    omit?: chatroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroomInclude<ExtArgs> | null
    where?: chatroomWhereInput
  }

  /**
   * message.user
   */
  export type message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * message without action
   */
  export type messageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    timestamp: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    timestamp: bigint | null
    name: string | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    timestamp: number
    name: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    timestamp?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    timestamp?: true
    name?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    timestamp: bigint
    name: string
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    timestamp?: boolean
    name?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "timestamp" | "name", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      timestamp: bigint
      name: string
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly timestamp: FieldRef<"migrations", 'BigInt'>
    readonly name: FieldRef<"migrations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    picture: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    picture: string | null
    content: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    picture: number
    content: number
    created_at: number
    updated_at: number
    user_id: number
    _all: number
  }


  export type PostMinAggregateInputType = {
    id?: true
    picture?: true
    content?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    picture?: true
    content?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    picture?: true
    content?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post to aggregate.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type postGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: postWhereInput
    orderBy?: postOrderByWithAggregationInput | postOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: postScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    picture: string
    content: string
    created_at: Date
    updated_at: Date
    user_id: string | null
    _count: PostCountAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends postGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type postSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    combo?: boolean | post$comboArgs<ExtArgs>
    comment?: boolean | post$commentArgs<ExtArgs>
    user?: boolean | post$userArgs<ExtArgs>
    post_like?: boolean | post$post_likeArgs<ExtArgs>
    report_post?: boolean | post$report_postArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | post$userArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    picture?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    user?: boolean | post$userArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type postSelectScalar = {
    id?: boolean
    picture?: boolean
    content?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
  }

  export type postOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "picture" | "content" | "created_at" | "updated_at" | "user_id", ExtArgs["result"]["post"]>
  export type postInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    combo?: boolean | post$comboArgs<ExtArgs>
    comment?: boolean | post$commentArgs<ExtArgs>
    user?: boolean | post$userArgs<ExtArgs>
    post_like?: boolean | post$post_likeArgs<ExtArgs>
    report_post?: boolean | post$report_postArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type postIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | post$userArgs<ExtArgs>
  }
  export type postIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | post$userArgs<ExtArgs>
  }

  export type $postPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post"
    objects: {
      combo: Prisma.$comboPayload<ExtArgs>[]
      comment: Prisma.$commentPayload<ExtArgs>[]
      user: Prisma.$userPayload<ExtArgs> | null
      post_like: Prisma.$post_likePayload<ExtArgs>[]
      report_post: Prisma.$report_postPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      picture: string
      content: string
      created_at: Date
      updated_at: Date
      user_id: string | null
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type postGetPayload<S extends boolean | null | undefined | postDefaultArgs> = $Result.GetResult<Prisma.$postPayload, S>

  type postCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<postFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface postDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post'], meta: { name: 'post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {postFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends postFindUniqueArgs>(args: SelectSubset<T, postFindUniqueArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {postFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends postFindUniqueOrThrowArgs>(args: SelectSubset<T, postFindUniqueOrThrowArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends postFindFirstArgs>(args?: SelectSubset<T, postFindFirstArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends postFindFirstOrThrowArgs>(args?: SelectSubset<T, postFindFirstOrThrowArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends postFindManyArgs>(args?: SelectSubset<T, postFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {postCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends postCreateArgs>(args: SelectSubset<T, postCreateArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {postCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends postCreateManyArgs>(args?: SelectSubset<T, postCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {postCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends postCreateManyAndReturnArgs>(args?: SelectSubset<T, postCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {postDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends postDeleteArgs>(args: SelectSubset<T, postDeleteArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {postUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends postUpdateArgs>(args: SelectSubset<T, postUpdateArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {postDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends postDeleteManyArgs>(args?: SelectSubset<T, postDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends postUpdateManyArgs>(args: SelectSubset<T, postUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {postUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends postUpdateManyAndReturnArgs>(args: SelectSubset<T, postUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {postUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends postUpsertArgs>(args: SelectSubset<T, postUpsertArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends postCountArgs>(
      args?: Subset<T, postCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {postGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends postGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: postGroupByArgs['orderBy'] }
        : { orderBy?: postGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, postGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post model
   */
  readonly fields: postFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__postClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    combo<T extends post$comboArgs<ExtArgs> = {}>(args?: Subset<T, post$comboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comment<T extends post$commentArgs<ExtArgs> = {}>(args?: Subset<T, post$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends post$userArgs<ExtArgs> = {}>(args?: Subset<T, post$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post_like<T extends post$post_likeArgs<ExtArgs> = {}>(args?: Subset<T, post$post_likeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    report_post<T extends post$report_postArgs<ExtArgs> = {}>(args?: Subset<T, post$report_postArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post model
   */
  interface postFieldRefs {
    readonly id: FieldRef<"post", 'String'>
    readonly picture: FieldRef<"post", 'String'>
    readonly content: FieldRef<"post", 'String'>
    readonly created_at: FieldRef<"post", 'DateTime'>
    readonly updated_at: FieldRef<"post", 'DateTime'>
    readonly user_id: FieldRef<"post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * post findUnique
   */
  export type postFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where: postWhereUniqueInput
  }

  /**
   * post findUniqueOrThrow
   */
  export type postFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where: postWhereUniqueInput
  }

  /**
   * post findFirst
   */
  export type postFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post findFirstOrThrow
   */
  export type postFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which post to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post findMany
   */
  export type postFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter, which posts to fetch.
     */
    where?: postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of posts to fetch.
     */
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing posts.
     */
    cursor?: postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * post create
   */
  export type postCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The data needed to create a post.
     */
    data: XOR<postCreateInput, postUncheckedCreateInput>
  }

  /**
   * post createMany
   */
  export type postCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many posts.
     */
    data: postCreateManyInput | postCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post createManyAndReturn
   */
  export type postCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * The data used to create many posts.
     */
    data: postCreateManyInput | postCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * post update
   */
  export type postUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The data needed to update a post.
     */
    data: XOR<postUpdateInput, postUncheckedUpdateInput>
    /**
     * Choose, which post to update.
     */
    where: postWhereUniqueInput
  }

  /**
   * post updateMany
   */
  export type postUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update posts.
     */
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
  }

  /**
   * post updateManyAndReturn
   */
  export type postUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * The data used to update posts.
     */
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyInput>
    /**
     * Filter which posts to update
     */
    where?: postWhereInput
    /**
     * Limit how many posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * post upsert
   */
  export type postUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * The filter to search for the post to update in case it exists.
     */
    where: postWhereUniqueInput
    /**
     * In case the post found by the `where` argument doesn't exist, create a new post with this data.
     */
    create: XOR<postCreateInput, postUncheckedCreateInput>
    /**
     * In case the post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<postUpdateInput, postUncheckedUpdateInput>
  }

  /**
   * post delete
   */
  export type postDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    /**
     * Filter which post to delete.
     */
    where: postWhereUniqueInput
  }

  /**
   * post deleteMany
   */
  export type postDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which posts to delete
     */
    where?: postWhereInput
    /**
     * Limit how many posts to delete.
     */
    limit?: number
  }

  /**
   * post.combo
   */
  export type post$comboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    where?: comboWhereInput
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    cursor?: comboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }

  /**
   * post.comment
   */
  export type post$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * post.user
   */
  export type post$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * post.post_like
   */
  export type post$post_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    where?: post_likeWhereInput
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    cursor?: post_likeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Post_likeScalarFieldEnum | Post_likeScalarFieldEnum[]
  }

  /**
   * post.report_post
   */
  export type post$report_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    where?: report_postWhereInput
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    cursor?: report_postWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Report_postScalarFieldEnum | Report_postScalarFieldEnum[]
  }

  /**
   * post without action
   */
  export type postDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
  }


  /**
   * Model post_like
   */

  export type AggregatePost_like = {
    _count: Post_likeCountAggregateOutputType | null
    _min: Post_likeMinAggregateOutputType | null
    _max: Post_likeMaxAggregateOutputType | null
  }

  export type Post_likeMinAggregateOutputType = {
    id: string | null
    post_id: string | null
    user_id: string | null
  }

  export type Post_likeMaxAggregateOutputType = {
    id: string | null
    post_id: string | null
    user_id: string | null
  }

  export type Post_likeCountAggregateOutputType = {
    id: number
    post_id: number
    user_id: number
    _all: number
  }


  export type Post_likeMinAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type Post_likeMaxAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
  }

  export type Post_likeCountAggregateInputType = {
    id?: true
    post_id?: true
    user_id?: true
    _all?: true
  }

  export type Post_likeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_like to aggregate.
     */
    where?: post_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_likes to fetch.
     */
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: post_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned post_likes
    **/
    _count?: true | Post_likeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Post_likeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Post_likeMaxAggregateInputType
  }

  export type GetPost_likeAggregateType<T extends Post_likeAggregateArgs> = {
        [P in keyof T & keyof AggregatePost_like]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost_like[P]>
      : GetScalarType<T[P], AggregatePost_like[P]>
  }




  export type post_likeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: post_likeWhereInput
    orderBy?: post_likeOrderByWithAggregationInput | post_likeOrderByWithAggregationInput[]
    by: Post_likeScalarFieldEnum[] | Post_likeScalarFieldEnum
    having?: post_likeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Post_likeCountAggregateInputType | true
    _min?: Post_likeMinAggregateInputType
    _max?: Post_likeMaxAggregateInputType
  }

  export type Post_likeGroupByOutputType = {
    id: string
    post_id: string | null
    user_id: string | null
    _count: Post_likeCountAggregateOutputType | null
    _min: Post_likeMinAggregateOutputType | null
    _max: Post_likeMaxAggregateOutputType | null
  }

  type GetPost_likeGroupByPayload<T extends post_likeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Post_likeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Post_likeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Post_likeGroupByOutputType[P]>
            : GetScalarType<T[P], Post_likeGroupByOutputType[P]>
        }
      >
    >


  export type post_likeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }, ExtArgs["result"]["post_like"]>

  export type post_likeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }, ExtArgs["result"]["post_like"]>

  export type post_likeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    post_id?: boolean
    user_id?: boolean
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }, ExtArgs["result"]["post_like"]>

  export type post_likeSelectScalar = {
    id?: boolean
    post_id?: boolean
    user_id?: boolean
  }

  export type post_likeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "post_id" | "user_id", ExtArgs["result"]["post_like"]>
  export type post_likeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }
  export type post_likeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }
  export type post_likeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | post_like$postArgs<ExtArgs>
    user?: boolean | post_like$userArgs<ExtArgs>
  }

  export type $post_likePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "post_like"
    objects: {
      post: Prisma.$postPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      post_id: string | null
      user_id: string | null
    }, ExtArgs["result"]["post_like"]>
    composites: {}
  }

  type post_likeGetPayload<S extends boolean | null | undefined | post_likeDefaultArgs> = $Result.GetResult<Prisma.$post_likePayload, S>

  type post_likeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<post_likeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Post_likeCountAggregateInputType | true
    }

  export interface post_likeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['post_like'], meta: { name: 'post_like' } }
    /**
     * Find zero or one Post_like that matches the filter.
     * @param {post_likeFindUniqueArgs} args - Arguments to find a Post_like
     * @example
     * // Get one Post_like
     * const post_like = await prisma.post_like.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends post_likeFindUniqueArgs>(args: SelectSubset<T, post_likeFindUniqueArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post_like that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {post_likeFindUniqueOrThrowArgs} args - Arguments to find a Post_like
     * @example
     * // Get one Post_like
     * const post_like = await prisma.post_like.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends post_likeFindUniqueOrThrowArgs>(args: SelectSubset<T, post_likeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_like that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeFindFirstArgs} args - Arguments to find a Post_like
     * @example
     * // Get one Post_like
     * const post_like = await prisma.post_like.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends post_likeFindFirstArgs>(args?: SelectSubset<T, post_likeFindFirstArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post_like that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeFindFirstOrThrowArgs} args - Arguments to find a Post_like
     * @example
     * // Get one Post_like
     * const post_like = await prisma.post_like.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends post_likeFindFirstOrThrowArgs>(args?: SelectSubset<T, post_likeFindFirstOrThrowArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Post_likes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Post_likes
     * const post_likes = await prisma.post_like.findMany()
     * 
     * // Get first 10 Post_likes
     * const post_likes = await prisma.post_like.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const post_likeWithIdOnly = await prisma.post_like.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends post_likeFindManyArgs>(args?: SelectSubset<T, post_likeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post_like.
     * @param {post_likeCreateArgs} args - Arguments to create a Post_like.
     * @example
     * // Create one Post_like
     * const Post_like = await prisma.post_like.create({
     *   data: {
     *     // ... data to create a Post_like
     *   }
     * })
     * 
     */
    create<T extends post_likeCreateArgs>(args: SelectSubset<T, post_likeCreateArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Post_likes.
     * @param {post_likeCreateManyArgs} args - Arguments to create many Post_likes.
     * @example
     * // Create many Post_likes
     * const post_like = await prisma.post_like.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends post_likeCreateManyArgs>(args?: SelectSubset<T, post_likeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Post_likes and returns the data saved in the database.
     * @param {post_likeCreateManyAndReturnArgs} args - Arguments to create many Post_likes.
     * @example
     * // Create many Post_likes
     * const post_like = await prisma.post_like.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Post_likes and only return the `id`
     * const post_likeWithIdOnly = await prisma.post_like.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends post_likeCreateManyAndReturnArgs>(args?: SelectSubset<T, post_likeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post_like.
     * @param {post_likeDeleteArgs} args - Arguments to delete one Post_like.
     * @example
     * // Delete one Post_like
     * const Post_like = await prisma.post_like.delete({
     *   where: {
     *     // ... filter to delete one Post_like
     *   }
     * })
     * 
     */
    delete<T extends post_likeDeleteArgs>(args: SelectSubset<T, post_likeDeleteArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post_like.
     * @param {post_likeUpdateArgs} args - Arguments to update one Post_like.
     * @example
     * // Update one Post_like
     * const post_like = await prisma.post_like.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends post_likeUpdateArgs>(args: SelectSubset<T, post_likeUpdateArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Post_likes.
     * @param {post_likeDeleteManyArgs} args - Arguments to filter Post_likes to delete.
     * @example
     * // Delete a few Post_likes
     * const { count } = await prisma.post_like.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends post_likeDeleteManyArgs>(args?: SelectSubset<T, post_likeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Post_likes
     * const post_like = await prisma.post_like.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends post_likeUpdateManyArgs>(args: SelectSubset<T, post_likeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Post_likes and returns the data updated in the database.
     * @param {post_likeUpdateManyAndReturnArgs} args - Arguments to update many Post_likes.
     * @example
     * // Update many Post_likes
     * const post_like = await prisma.post_like.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Post_likes and only return the `id`
     * const post_likeWithIdOnly = await prisma.post_like.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends post_likeUpdateManyAndReturnArgs>(args: SelectSubset<T, post_likeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post_like.
     * @param {post_likeUpsertArgs} args - Arguments to update or create a Post_like.
     * @example
     * // Update or create a Post_like
     * const post_like = await prisma.post_like.upsert({
     *   create: {
     *     // ... data to create a Post_like
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post_like we want to update
     *   }
     * })
     */
    upsert<T extends post_likeUpsertArgs>(args: SelectSubset<T, post_likeUpsertArgs<ExtArgs>>): Prisma__post_likeClient<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Post_likes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeCountArgs} args - Arguments to filter Post_likes to count.
     * @example
     * // Count the number of Post_likes
     * const count = await prisma.post_like.count({
     *   where: {
     *     // ... the filter for the Post_likes we want to count
     *   }
     * })
    **/
    count<T extends post_likeCountArgs>(
      args?: Subset<T, post_likeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Post_likeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Post_likeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Post_likeAggregateArgs>(args: Subset<T, Post_likeAggregateArgs>): Prisma.PrismaPromise<GetPost_likeAggregateType<T>>

    /**
     * Group by Post_like.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {post_likeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends post_likeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: post_likeGroupByArgs['orderBy'] }
        : { orderBy?: post_likeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, post_likeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPost_likeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the post_like model
   */
  readonly fields: post_likeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for post_like.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__post_likeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends post_like$postArgs<ExtArgs> = {}>(args?: Subset<T, post_like$postArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends post_like$userArgs<ExtArgs> = {}>(args?: Subset<T, post_like$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the post_like model
   */
  interface post_likeFieldRefs {
    readonly id: FieldRef<"post_like", 'String'>
    readonly post_id: FieldRef<"post_like", 'String'>
    readonly user_id: FieldRef<"post_like", 'String'>
  }
    

  // Custom InputTypes
  /**
   * post_like findUnique
   */
  export type post_likeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter, which post_like to fetch.
     */
    where: post_likeWhereUniqueInput
  }

  /**
   * post_like findUniqueOrThrow
   */
  export type post_likeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter, which post_like to fetch.
     */
    where: post_likeWhereUniqueInput
  }

  /**
   * post_like findFirst
   */
  export type post_likeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter, which post_like to fetch.
     */
    where?: post_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_likes to fetch.
     */
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_likes.
     */
    cursor?: post_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_likes.
     */
    distinct?: Post_likeScalarFieldEnum | Post_likeScalarFieldEnum[]
  }

  /**
   * post_like findFirstOrThrow
   */
  export type post_likeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter, which post_like to fetch.
     */
    where?: post_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_likes to fetch.
     */
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for post_likes.
     */
    cursor?: post_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_likes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of post_likes.
     */
    distinct?: Post_likeScalarFieldEnum | Post_likeScalarFieldEnum[]
  }

  /**
   * post_like findMany
   */
  export type post_likeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter, which post_likes to fetch.
     */
    where?: post_likeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of post_likes to fetch.
     */
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing post_likes.
     */
    cursor?: post_likeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` post_likes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` post_likes.
     */
    skip?: number
    distinct?: Post_likeScalarFieldEnum | Post_likeScalarFieldEnum[]
  }

  /**
   * post_like create
   */
  export type post_likeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * The data needed to create a post_like.
     */
    data?: XOR<post_likeCreateInput, post_likeUncheckedCreateInput>
  }

  /**
   * post_like createMany
   */
  export type post_likeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many post_likes.
     */
    data: post_likeCreateManyInput | post_likeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * post_like createManyAndReturn
   */
  export type post_likeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * The data used to create many post_likes.
     */
    data: post_likeCreateManyInput | post_likeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * post_like update
   */
  export type post_likeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * The data needed to update a post_like.
     */
    data: XOR<post_likeUpdateInput, post_likeUncheckedUpdateInput>
    /**
     * Choose, which post_like to update.
     */
    where: post_likeWhereUniqueInput
  }

  /**
   * post_like updateMany
   */
  export type post_likeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update post_likes.
     */
    data: XOR<post_likeUpdateManyMutationInput, post_likeUncheckedUpdateManyInput>
    /**
     * Filter which post_likes to update
     */
    where?: post_likeWhereInput
    /**
     * Limit how many post_likes to update.
     */
    limit?: number
  }

  /**
   * post_like updateManyAndReturn
   */
  export type post_likeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * The data used to update post_likes.
     */
    data: XOR<post_likeUpdateManyMutationInput, post_likeUncheckedUpdateManyInput>
    /**
     * Filter which post_likes to update
     */
    where?: post_likeWhereInput
    /**
     * Limit how many post_likes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * post_like upsert
   */
  export type post_likeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * The filter to search for the post_like to update in case it exists.
     */
    where: post_likeWhereUniqueInput
    /**
     * In case the post_like found by the `where` argument doesn't exist, create a new post_like with this data.
     */
    create: XOR<post_likeCreateInput, post_likeUncheckedCreateInput>
    /**
     * In case the post_like was found with the provided `where` argument, update it with this data.
     */
    update: XOR<post_likeUpdateInput, post_likeUncheckedUpdateInput>
  }

  /**
   * post_like delete
   */
  export type post_likeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    /**
     * Filter which post_like to delete.
     */
    where: post_likeWhereUniqueInput
  }

  /**
   * post_like deleteMany
   */
  export type post_likeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which post_likes to delete
     */
    where?: post_likeWhereInput
    /**
     * Limit how many post_likes to delete.
     */
    limit?: number
  }

  /**
   * post_like.post
   */
  export type post_like$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    where?: postWhereInput
  }

  /**
   * post_like.user
   */
  export type post_like$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * post_like without action
   */
  export type post_likeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
  }


  /**
   * Model praise
   */

  export type AggregatePraise = {
    _count: PraiseCountAggregateOutputType | null
    _min: PraiseMinAggregateOutputType | null
    _max: PraiseMaxAggregateOutputType | null
  }

  export type PraiseMinAggregateOutputType = {
    id: string | null
    is_like: boolean | null
    user_id: string | null
    guest_id: string | null
    created_at: Date | null
  }

  export type PraiseMaxAggregateOutputType = {
    id: string | null
    is_like: boolean | null
    user_id: string | null
    guest_id: string | null
    created_at: Date | null
  }

  export type PraiseCountAggregateOutputType = {
    id: number
    is_like: number
    user_id: number
    guest_id: number
    created_at: number
    _all: number
  }


  export type PraiseMinAggregateInputType = {
    id?: true
    is_like?: true
    user_id?: true
    guest_id?: true
    created_at?: true
  }

  export type PraiseMaxAggregateInputType = {
    id?: true
    is_like?: true
    user_id?: true
    guest_id?: true
    created_at?: true
  }

  export type PraiseCountAggregateInputType = {
    id?: true
    is_like?: true
    user_id?: true
    guest_id?: true
    created_at?: true
    _all?: true
  }

  export type PraiseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which praise to aggregate.
     */
    where?: praiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praises to fetch.
     */
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: praiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned praises
    **/
    _count?: true | PraiseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PraiseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PraiseMaxAggregateInputType
  }

  export type GetPraiseAggregateType<T extends PraiseAggregateArgs> = {
        [P in keyof T & keyof AggregatePraise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePraise[P]>
      : GetScalarType<T[P], AggregatePraise[P]>
  }




  export type praiseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: praiseWhereInput
    orderBy?: praiseOrderByWithAggregationInput | praiseOrderByWithAggregationInput[]
    by: PraiseScalarFieldEnum[] | PraiseScalarFieldEnum
    having?: praiseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PraiseCountAggregateInputType | true
    _min?: PraiseMinAggregateInputType
    _max?: PraiseMaxAggregateInputType
  }

  export type PraiseGroupByOutputType = {
    id: string
    is_like: boolean
    user_id: string | null
    guest_id: string | null
    created_at: Date
    _count: PraiseCountAggregateOutputType | null
    _min: PraiseMinAggregateOutputType | null
    _max: PraiseMaxAggregateOutputType | null
  }

  type GetPraiseGroupByPayload<T extends praiseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PraiseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PraiseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PraiseGroupByOutputType[P]>
            : GetScalarType<T[P], PraiseGroupByOutputType[P]>
        }
      >
    >


  export type praiseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    is_like?: boolean
    user_id?: boolean
    guest_id?: boolean
    created_at?: boolean
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }, ExtArgs["result"]["praise"]>

  export type praiseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    is_like?: boolean
    user_id?: boolean
    guest_id?: boolean
    created_at?: boolean
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }, ExtArgs["result"]["praise"]>

  export type praiseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    is_like?: boolean
    user_id?: boolean
    guest_id?: boolean
    created_at?: boolean
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }, ExtArgs["result"]["praise"]>

  export type praiseSelectScalar = {
    id?: boolean
    is_like?: boolean
    user_id?: boolean
    guest_id?: boolean
    created_at?: boolean
  }

  export type praiseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "is_like" | "user_id" | "guest_id" | "created_at", ExtArgs["result"]["praise"]>
  export type praiseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }
  export type praiseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }
  export type praiseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | praise$guestArgs<ExtArgs>
    user?: boolean | praise$userArgs<ExtArgs>
  }

  export type $praisePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "praise"
    objects: {
      guest: Prisma.$guestPayload<ExtArgs> | null
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      is_like: boolean
      user_id: string | null
      guest_id: string | null
      created_at: Date
    }, ExtArgs["result"]["praise"]>
    composites: {}
  }

  type praiseGetPayload<S extends boolean | null | undefined | praiseDefaultArgs> = $Result.GetResult<Prisma.$praisePayload, S>

  type praiseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<praiseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PraiseCountAggregateInputType | true
    }

  export interface praiseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['praise'], meta: { name: 'praise' } }
    /**
     * Find zero or one Praise that matches the filter.
     * @param {praiseFindUniqueArgs} args - Arguments to find a Praise
     * @example
     * // Get one Praise
     * const praise = await prisma.praise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends praiseFindUniqueArgs>(args: SelectSubset<T, praiseFindUniqueArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Praise that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {praiseFindUniqueOrThrowArgs} args - Arguments to find a Praise
     * @example
     * // Get one Praise
     * const praise = await prisma.praise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends praiseFindUniqueOrThrowArgs>(args: SelectSubset<T, praiseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Praise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseFindFirstArgs} args - Arguments to find a Praise
     * @example
     * // Get one Praise
     * const praise = await prisma.praise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends praiseFindFirstArgs>(args?: SelectSubset<T, praiseFindFirstArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Praise that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseFindFirstOrThrowArgs} args - Arguments to find a Praise
     * @example
     * // Get one Praise
     * const praise = await prisma.praise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends praiseFindFirstOrThrowArgs>(args?: SelectSubset<T, praiseFindFirstOrThrowArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Praises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Praises
     * const praises = await prisma.praise.findMany()
     * 
     * // Get first 10 Praises
     * const praises = await prisma.praise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const praiseWithIdOnly = await prisma.praise.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends praiseFindManyArgs>(args?: SelectSubset<T, praiseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Praise.
     * @param {praiseCreateArgs} args - Arguments to create a Praise.
     * @example
     * // Create one Praise
     * const Praise = await prisma.praise.create({
     *   data: {
     *     // ... data to create a Praise
     *   }
     * })
     * 
     */
    create<T extends praiseCreateArgs>(args: SelectSubset<T, praiseCreateArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Praises.
     * @param {praiseCreateManyArgs} args - Arguments to create many Praises.
     * @example
     * // Create many Praises
     * const praise = await prisma.praise.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends praiseCreateManyArgs>(args?: SelectSubset<T, praiseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Praises and returns the data saved in the database.
     * @param {praiseCreateManyAndReturnArgs} args - Arguments to create many Praises.
     * @example
     * // Create many Praises
     * const praise = await prisma.praise.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Praises and only return the `id`
     * const praiseWithIdOnly = await prisma.praise.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends praiseCreateManyAndReturnArgs>(args?: SelectSubset<T, praiseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Praise.
     * @param {praiseDeleteArgs} args - Arguments to delete one Praise.
     * @example
     * // Delete one Praise
     * const Praise = await prisma.praise.delete({
     *   where: {
     *     // ... filter to delete one Praise
     *   }
     * })
     * 
     */
    delete<T extends praiseDeleteArgs>(args: SelectSubset<T, praiseDeleteArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Praise.
     * @param {praiseUpdateArgs} args - Arguments to update one Praise.
     * @example
     * // Update one Praise
     * const praise = await prisma.praise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends praiseUpdateArgs>(args: SelectSubset<T, praiseUpdateArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Praises.
     * @param {praiseDeleteManyArgs} args - Arguments to filter Praises to delete.
     * @example
     * // Delete a few Praises
     * const { count } = await prisma.praise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends praiseDeleteManyArgs>(args?: SelectSubset<T, praiseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Praises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Praises
     * const praise = await prisma.praise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends praiseUpdateManyArgs>(args: SelectSubset<T, praiseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Praises and returns the data updated in the database.
     * @param {praiseUpdateManyAndReturnArgs} args - Arguments to update many Praises.
     * @example
     * // Update many Praises
     * const praise = await prisma.praise.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Praises and only return the `id`
     * const praiseWithIdOnly = await prisma.praise.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends praiseUpdateManyAndReturnArgs>(args: SelectSubset<T, praiseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Praise.
     * @param {praiseUpsertArgs} args - Arguments to update or create a Praise.
     * @example
     * // Update or create a Praise
     * const praise = await prisma.praise.upsert({
     *   create: {
     *     // ... data to create a Praise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Praise we want to update
     *   }
     * })
     */
    upsert<T extends praiseUpsertArgs>(args: SelectSubset<T, praiseUpsertArgs<ExtArgs>>): Prisma__praiseClient<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Praises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseCountArgs} args - Arguments to filter Praises to count.
     * @example
     * // Count the number of Praises
     * const count = await prisma.praise.count({
     *   where: {
     *     // ... the filter for the Praises we want to count
     *   }
     * })
    **/
    count<T extends praiseCountArgs>(
      args?: Subset<T, praiseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PraiseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Praise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PraiseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PraiseAggregateArgs>(args: Subset<T, PraiseAggregateArgs>): Prisma.PrismaPromise<GetPraiseAggregateType<T>>

    /**
     * Group by Praise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {praiseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends praiseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: praiseGroupByArgs['orderBy'] }
        : { orderBy?: praiseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, praiseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPraiseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the praise model
   */
  readonly fields: praiseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for praise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__praiseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest<T extends praise$guestArgs<ExtArgs> = {}>(args?: Subset<T, praise$guestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends praise$userArgs<ExtArgs> = {}>(args?: Subset<T, praise$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the praise model
   */
  interface praiseFieldRefs {
    readonly id: FieldRef<"praise", 'String'>
    readonly is_like: FieldRef<"praise", 'Boolean'>
    readonly user_id: FieldRef<"praise", 'String'>
    readonly guest_id: FieldRef<"praise", 'String'>
    readonly created_at: FieldRef<"praise", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * praise findUnique
   */
  export type praiseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter, which praise to fetch.
     */
    where: praiseWhereUniqueInput
  }

  /**
   * praise findUniqueOrThrow
   */
  export type praiseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter, which praise to fetch.
     */
    where: praiseWhereUniqueInput
  }

  /**
   * praise findFirst
   */
  export type praiseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter, which praise to fetch.
     */
    where?: praiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praises to fetch.
     */
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for praises.
     */
    cursor?: praiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of praises.
     */
    distinct?: PraiseScalarFieldEnum | PraiseScalarFieldEnum[]
  }

  /**
   * praise findFirstOrThrow
   */
  export type praiseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter, which praise to fetch.
     */
    where?: praiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praises to fetch.
     */
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for praises.
     */
    cursor?: praiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of praises.
     */
    distinct?: PraiseScalarFieldEnum | PraiseScalarFieldEnum[]
  }

  /**
   * praise findMany
   */
  export type praiseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter, which praises to fetch.
     */
    where?: praiseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of praises to fetch.
     */
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing praises.
     */
    cursor?: praiseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` praises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` praises.
     */
    skip?: number
    distinct?: PraiseScalarFieldEnum | PraiseScalarFieldEnum[]
  }

  /**
   * praise create
   */
  export type praiseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * The data needed to create a praise.
     */
    data: XOR<praiseCreateInput, praiseUncheckedCreateInput>
  }

  /**
   * praise createMany
   */
  export type praiseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many praises.
     */
    data: praiseCreateManyInput | praiseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * praise createManyAndReturn
   */
  export type praiseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * The data used to create many praises.
     */
    data: praiseCreateManyInput | praiseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * praise update
   */
  export type praiseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * The data needed to update a praise.
     */
    data: XOR<praiseUpdateInput, praiseUncheckedUpdateInput>
    /**
     * Choose, which praise to update.
     */
    where: praiseWhereUniqueInput
  }

  /**
   * praise updateMany
   */
  export type praiseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update praises.
     */
    data: XOR<praiseUpdateManyMutationInput, praiseUncheckedUpdateManyInput>
    /**
     * Filter which praises to update
     */
    where?: praiseWhereInput
    /**
     * Limit how many praises to update.
     */
    limit?: number
  }

  /**
   * praise updateManyAndReturn
   */
  export type praiseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * The data used to update praises.
     */
    data: XOR<praiseUpdateManyMutationInput, praiseUncheckedUpdateManyInput>
    /**
     * Filter which praises to update
     */
    where?: praiseWhereInput
    /**
     * Limit how many praises to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * praise upsert
   */
  export type praiseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * The filter to search for the praise to update in case it exists.
     */
    where: praiseWhereUniqueInput
    /**
     * In case the praise found by the `where` argument doesn't exist, create a new praise with this data.
     */
    create: XOR<praiseCreateInput, praiseUncheckedCreateInput>
    /**
     * In case the praise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<praiseUpdateInput, praiseUncheckedUpdateInput>
  }

  /**
   * praise delete
   */
  export type praiseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    /**
     * Filter which praise to delete.
     */
    where: praiseWhereUniqueInput
  }

  /**
   * praise deleteMany
   */
  export type praiseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which praises to delete
     */
    where?: praiseWhereInput
    /**
     * Limit how many praises to delete.
     */
    limit?: number
  }

  /**
   * praise.guest
   */
  export type praise$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * praise.user
   */
  export type praise$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * praise without action
   */
  export type praiseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
  }


  /**
   * Model recycle_account
   */

  export type AggregateRecycle_account = {
    _count: Recycle_accountCountAggregateOutputType | null
    _min: Recycle_accountMinAggregateOutputType | null
    _max: Recycle_accountMaxAggregateOutputType | null
  }

  export type Recycle_accountMinAggregateOutputType = {
    id: string | null
    delete_time: Date | null
    user_id: string | null
  }

  export type Recycle_accountMaxAggregateOutputType = {
    id: string | null
    delete_time: Date | null
    user_id: string | null
  }

  export type Recycle_accountCountAggregateOutputType = {
    id: number
    delete_time: number
    user_id: number
    _all: number
  }


  export type Recycle_accountMinAggregateInputType = {
    id?: true
    delete_time?: true
    user_id?: true
  }

  export type Recycle_accountMaxAggregateInputType = {
    id?: true
    delete_time?: true
    user_id?: true
  }

  export type Recycle_accountCountAggregateInputType = {
    id?: true
    delete_time?: true
    user_id?: true
    _all?: true
  }

  export type Recycle_accountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recycle_account to aggregate.
     */
    where?: recycle_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recycle_accounts to fetch.
     */
    orderBy?: recycle_accountOrderByWithRelationInput | recycle_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recycle_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recycle_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recycle_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned recycle_accounts
    **/
    _count?: true | Recycle_accountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Recycle_accountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Recycle_accountMaxAggregateInputType
  }

  export type GetRecycle_accountAggregateType<T extends Recycle_accountAggregateArgs> = {
        [P in keyof T & keyof AggregateRecycle_account]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecycle_account[P]>
      : GetScalarType<T[P], AggregateRecycle_account[P]>
  }




  export type recycle_accountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recycle_accountWhereInput
    orderBy?: recycle_accountOrderByWithAggregationInput | recycle_accountOrderByWithAggregationInput[]
    by: Recycle_accountScalarFieldEnum[] | Recycle_accountScalarFieldEnum
    having?: recycle_accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Recycle_accountCountAggregateInputType | true
    _min?: Recycle_accountMinAggregateInputType
    _max?: Recycle_accountMaxAggregateInputType
  }

  export type Recycle_accountGroupByOutputType = {
    id: string
    delete_time: Date
    user_id: string | null
    _count: Recycle_accountCountAggregateOutputType | null
    _min: Recycle_accountMinAggregateOutputType | null
    _max: Recycle_accountMaxAggregateOutputType | null
  }

  type GetRecycle_accountGroupByPayload<T extends recycle_accountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Recycle_accountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Recycle_accountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Recycle_accountGroupByOutputType[P]>
            : GetScalarType<T[P], Recycle_accountGroupByOutputType[P]>
        }
      >
    >


  export type recycle_accountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delete_time?: boolean
    user_id?: boolean
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }, ExtArgs["result"]["recycle_account"]>

  export type recycle_accountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delete_time?: boolean
    user_id?: boolean
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }, ExtArgs["result"]["recycle_account"]>

  export type recycle_accountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    delete_time?: boolean
    user_id?: boolean
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }, ExtArgs["result"]["recycle_account"]>

  export type recycle_accountSelectScalar = {
    id?: boolean
    delete_time?: boolean
    user_id?: boolean
  }

  export type recycle_accountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "delete_time" | "user_id", ExtArgs["result"]["recycle_account"]>
  export type recycle_accountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }
  export type recycle_accountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }
  export type recycle_accountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | recycle_account$userArgs<ExtArgs>
  }

  export type $recycle_accountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "recycle_account"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      delete_time: Date
      user_id: string | null
    }, ExtArgs["result"]["recycle_account"]>
    composites: {}
  }

  type recycle_accountGetPayload<S extends boolean | null | undefined | recycle_accountDefaultArgs> = $Result.GetResult<Prisma.$recycle_accountPayload, S>

  type recycle_accountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recycle_accountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Recycle_accountCountAggregateInputType | true
    }

  export interface recycle_accountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['recycle_account'], meta: { name: 'recycle_account' } }
    /**
     * Find zero or one Recycle_account that matches the filter.
     * @param {recycle_accountFindUniqueArgs} args - Arguments to find a Recycle_account
     * @example
     * // Get one Recycle_account
     * const recycle_account = await prisma.recycle_account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recycle_accountFindUniqueArgs>(args: SelectSubset<T, recycle_accountFindUniqueArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Recycle_account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recycle_accountFindUniqueOrThrowArgs} args - Arguments to find a Recycle_account
     * @example
     * // Get one Recycle_account
     * const recycle_account = await prisma.recycle_account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recycle_accountFindUniqueOrThrowArgs>(args: SelectSubset<T, recycle_accountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recycle_account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountFindFirstArgs} args - Arguments to find a Recycle_account
     * @example
     * // Get one Recycle_account
     * const recycle_account = await prisma.recycle_account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recycle_accountFindFirstArgs>(args?: SelectSubset<T, recycle_accountFindFirstArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Recycle_account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountFindFirstOrThrowArgs} args - Arguments to find a Recycle_account
     * @example
     * // Get one Recycle_account
     * const recycle_account = await prisma.recycle_account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recycle_accountFindFirstOrThrowArgs>(args?: SelectSubset<T, recycle_accountFindFirstOrThrowArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Recycle_accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Recycle_accounts
     * const recycle_accounts = await prisma.recycle_account.findMany()
     * 
     * // Get first 10 Recycle_accounts
     * const recycle_accounts = await prisma.recycle_account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recycle_accountWithIdOnly = await prisma.recycle_account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends recycle_accountFindManyArgs>(args?: SelectSubset<T, recycle_accountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Recycle_account.
     * @param {recycle_accountCreateArgs} args - Arguments to create a Recycle_account.
     * @example
     * // Create one Recycle_account
     * const Recycle_account = await prisma.recycle_account.create({
     *   data: {
     *     // ... data to create a Recycle_account
     *   }
     * })
     * 
     */
    create<T extends recycle_accountCreateArgs>(args: SelectSubset<T, recycle_accountCreateArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Recycle_accounts.
     * @param {recycle_accountCreateManyArgs} args - Arguments to create many Recycle_accounts.
     * @example
     * // Create many Recycle_accounts
     * const recycle_account = await prisma.recycle_account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recycle_accountCreateManyArgs>(args?: SelectSubset<T, recycle_accountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Recycle_accounts and returns the data saved in the database.
     * @param {recycle_accountCreateManyAndReturnArgs} args - Arguments to create many Recycle_accounts.
     * @example
     * // Create many Recycle_accounts
     * const recycle_account = await prisma.recycle_account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Recycle_accounts and only return the `id`
     * const recycle_accountWithIdOnly = await prisma.recycle_account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recycle_accountCreateManyAndReturnArgs>(args?: SelectSubset<T, recycle_accountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Recycle_account.
     * @param {recycle_accountDeleteArgs} args - Arguments to delete one Recycle_account.
     * @example
     * // Delete one Recycle_account
     * const Recycle_account = await prisma.recycle_account.delete({
     *   where: {
     *     // ... filter to delete one Recycle_account
     *   }
     * })
     * 
     */
    delete<T extends recycle_accountDeleteArgs>(args: SelectSubset<T, recycle_accountDeleteArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Recycle_account.
     * @param {recycle_accountUpdateArgs} args - Arguments to update one Recycle_account.
     * @example
     * // Update one Recycle_account
     * const recycle_account = await prisma.recycle_account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recycle_accountUpdateArgs>(args: SelectSubset<T, recycle_accountUpdateArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Recycle_accounts.
     * @param {recycle_accountDeleteManyArgs} args - Arguments to filter Recycle_accounts to delete.
     * @example
     * // Delete a few Recycle_accounts
     * const { count } = await prisma.recycle_account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recycle_accountDeleteManyArgs>(args?: SelectSubset<T, recycle_accountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recycle_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Recycle_accounts
     * const recycle_account = await prisma.recycle_account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recycle_accountUpdateManyArgs>(args: SelectSubset<T, recycle_accountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Recycle_accounts and returns the data updated in the database.
     * @param {recycle_accountUpdateManyAndReturnArgs} args - Arguments to update many Recycle_accounts.
     * @example
     * // Update many Recycle_accounts
     * const recycle_account = await prisma.recycle_account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Recycle_accounts and only return the `id`
     * const recycle_accountWithIdOnly = await prisma.recycle_account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recycle_accountUpdateManyAndReturnArgs>(args: SelectSubset<T, recycle_accountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Recycle_account.
     * @param {recycle_accountUpsertArgs} args - Arguments to update or create a Recycle_account.
     * @example
     * // Update or create a Recycle_account
     * const recycle_account = await prisma.recycle_account.upsert({
     *   create: {
     *     // ... data to create a Recycle_account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Recycle_account we want to update
     *   }
     * })
     */
    upsert<T extends recycle_accountUpsertArgs>(args: SelectSubset<T, recycle_accountUpsertArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Recycle_accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountCountArgs} args - Arguments to filter Recycle_accounts to count.
     * @example
     * // Count the number of Recycle_accounts
     * const count = await prisma.recycle_account.count({
     *   where: {
     *     // ... the filter for the Recycle_accounts we want to count
     *   }
     * })
    **/
    count<T extends recycle_accountCountArgs>(
      args?: Subset<T, recycle_accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Recycle_accountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Recycle_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Recycle_accountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Recycle_accountAggregateArgs>(args: Subset<T, Recycle_accountAggregateArgs>): Prisma.PrismaPromise<GetRecycle_accountAggregateType<T>>

    /**
     * Group by Recycle_account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recycle_accountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recycle_accountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recycle_accountGroupByArgs['orderBy'] }
        : { orderBy?: recycle_accountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recycle_accountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecycle_accountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the recycle_account model
   */
  readonly fields: recycle_accountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for recycle_account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recycle_accountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends recycle_account$userArgs<ExtArgs> = {}>(args?: Subset<T, recycle_account$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the recycle_account model
   */
  interface recycle_accountFieldRefs {
    readonly id: FieldRef<"recycle_account", 'String'>
    readonly delete_time: FieldRef<"recycle_account", 'DateTime'>
    readonly user_id: FieldRef<"recycle_account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * recycle_account findUnique
   */
  export type recycle_accountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter, which recycle_account to fetch.
     */
    where: recycle_accountWhereUniqueInput
  }

  /**
   * recycle_account findUniqueOrThrow
   */
  export type recycle_accountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter, which recycle_account to fetch.
     */
    where: recycle_accountWhereUniqueInput
  }

  /**
   * recycle_account findFirst
   */
  export type recycle_accountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter, which recycle_account to fetch.
     */
    where?: recycle_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recycle_accounts to fetch.
     */
    orderBy?: recycle_accountOrderByWithRelationInput | recycle_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recycle_accounts.
     */
    cursor?: recycle_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recycle_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recycle_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recycle_accounts.
     */
    distinct?: Recycle_accountScalarFieldEnum | Recycle_accountScalarFieldEnum[]
  }

  /**
   * recycle_account findFirstOrThrow
   */
  export type recycle_accountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter, which recycle_account to fetch.
     */
    where?: recycle_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recycle_accounts to fetch.
     */
    orderBy?: recycle_accountOrderByWithRelationInput | recycle_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for recycle_accounts.
     */
    cursor?: recycle_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recycle_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recycle_accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of recycle_accounts.
     */
    distinct?: Recycle_accountScalarFieldEnum | Recycle_accountScalarFieldEnum[]
  }

  /**
   * recycle_account findMany
   */
  export type recycle_accountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter, which recycle_accounts to fetch.
     */
    where?: recycle_accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of recycle_accounts to fetch.
     */
    orderBy?: recycle_accountOrderByWithRelationInput | recycle_accountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing recycle_accounts.
     */
    cursor?: recycle_accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` recycle_accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` recycle_accounts.
     */
    skip?: number
    distinct?: Recycle_accountScalarFieldEnum | Recycle_accountScalarFieldEnum[]
  }

  /**
   * recycle_account create
   */
  export type recycle_accountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * The data needed to create a recycle_account.
     */
    data: XOR<recycle_accountCreateInput, recycle_accountUncheckedCreateInput>
  }

  /**
   * recycle_account createMany
   */
  export type recycle_accountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many recycle_accounts.
     */
    data: recycle_accountCreateManyInput | recycle_accountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * recycle_account createManyAndReturn
   */
  export type recycle_accountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * The data used to create many recycle_accounts.
     */
    data: recycle_accountCreateManyInput | recycle_accountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * recycle_account update
   */
  export type recycle_accountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * The data needed to update a recycle_account.
     */
    data: XOR<recycle_accountUpdateInput, recycle_accountUncheckedUpdateInput>
    /**
     * Choose, which recycle_account to update.
     */
    where: recycle_accountWhereUniqueInput
  }

  /**
   * recycle_account updateMany
   */
  export type recycle_accountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update recycle_accounts.
     */
    data: XOR<recycle_accountUpdateManyMutationInput, recycle_accountUncheckedUpdateManyInput>
    /**
     * Filter which recycle_accounts to update
     */
    where?: recycle_accountWhereInput
    /**
     * Limit how many recycle_accounts to update.
     */
    limit?: number
  }

  /**
   * recycle_account updateManyAndReturn
   */
  export type recycle_accountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * The data used to update recycle_accounts.
     */
    data: XOR<recycle_accountUpdateManyMutationInput, recycle_accountUncheckedUpdateManyInput>
    /**
     * Filter which recycle_accounts to update
     */
    where?: recycle_accountWhereInput
    /**
     * Limit how many recycle_accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * recycle_account upsert
   */
  export type recycle_accountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * The filter to search for the recycle_account to update in case it exists.
     */
    where: recycle_accountWhereUniqueInput
    /**
     * In case the recycle_account found by the `where` argument doesn't exist, create a new recycle_account with this data.
     */
    create: XOR<recycle_accountCreateInput, recycle_accountUncheckedCreateInput>
    /**
     * In case the recycle_account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recycle_accountUpdateInput, recycle_accountUncheckedUpdateInput>
  }

  /**
   * recycle_account delete
   */
  export type recycle_accountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    /**
     * Filter which recycle_account to delete.
     */
    where: recycle_accountWhereUniqueInput
  }

  /**
   * recycle_account deleteMany
   */
  export type recycle_accountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which recycle_accounts to delete
     */
    where?: recycle_accountWhereInput
    /**
     * Limit how many recycle_accounts to delete.
     */
    limit?: number
  }

  /**
   * recycle_account.user
   */
  export type recycle_account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * recycle_account without action
   */
  export type recycle_accountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
  }


  /**
   * Model report_post
   */

  export type AggregateReport_post = {
    _count: Report_postCountAggregateOutputType | null
    _min: Report_postMinAggregateOutputType | null
    _max: Report_postMaxAggregateOutputType | null
  }

  export type Report_postMinAggregateOutputType = {
    id: string | null
    report_type: string | null
    content: string | null
    created_at: Date | null
    post_id: string | null
    user_id: string | null
  }

  export type Report_postMaxAggregateOutputType = {
    id: string | null
    report_type: string | null
    content: string | null
    created_at: Date | null
    post_id: string | null
    user_id: string | null
  }

  export type Report_postCountAggregateOutputType = {
    id: number
    report_type: number
    content: number
    created_at: number
    post_id: number
    user_id: number
    _all: number
  }


  export type Report_postMinAggregateInputType = {
    id?: true
    report_type?: true
    content?: true
    created_at?: true
    post_id?: true
    user_id?: true
  }

  export type Report_postMaxAggregateInputType = {
    id?: true
    report_type?: true
    content?: true
    created_at?: true
    post_id?: true
    user_id?: true
  }

  export type Report_postCountAggregateInputType = {
    id?: true
    report_type?: true
    content?: true
    created_at?: true
    post_id?: true
    user_id?: true
    _all?: true
  }

  export type Report_postAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_post to aggregate.
     */
    where?: report_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_posts to fetch.
     */
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: report_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned report_posts
    **/
    _count?: true | Report_postCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Report_postMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Report_postMaxAggregateInputType
  }

  export type GetReport_postAggregateType<T extends Report_postAggregateArgs> = {
        [P in keyof T & keyof AggregateReport_post]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport_post[P]>
      : GetScalarType<T[P], AggregateReport_post[P]>
  }




  export type report_postGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: report_postWhereInput
    orderBy?: report_postOrderByWithAggregationInput | report_postOrderByWithAggregationInput[]
    by: Report_postScalarFieldEnum[] | Report_postScalarFieldEnum
    having?: report_postScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Report_postCountAggregateInputType | true
    _min?: Report_postMinAggregateInputType
    _max?: Report_postMaxAggregateInputType
  }

  export type Report_postGroupByOutputType = {
    id: string
    report_type: string
    content: string | null
    created_at: Date
    post_id: string | null
    user_id: string | null
    _count: Report_postCountAggregateOutputType | null
    _min: Report_postMinAggregateOutputType | null
    _max: Report_postMaxAggregateOutputType | null
  }

  type GetReport_postGroupByPayload<T extends report_postGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Report_postGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Report_postGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Report_postGroupByOutputType[P]>
            : GetScalarType<T[P], Report_postGroupByOutputType[P]>
        }
      >
    >


  export type report_postSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    content?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }, ExtArgs["result"]["report_post"]>

  export type report_postSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    content?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }, ExtArgs["result"]["report_post"]>

  export type report_postSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    report_type?: boolean
    content?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }, ExtArgs["result"]["report_post"]>

  export type report_postSelectScalar = {
    id?: boolean
    report_type?: boolean
    content?: boolean
    created_at?: boolean
    post_id?: boolean
    user_id?: boolean
  }

  export type report_postOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "report_type" | "content" | "created_at" | "post_id" | "user_id", ExtArgs["result"]["report_post"]>
  export type report_postInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }
  export type report_postIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }
  export type report_postIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | report_post$userArgs<ExtArgs>
    post?: boolean | report_post$postArgs<ExtArgs>
  }

  export type $report_postPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "report_post"
    objects: {
      user: Prisma.$userPayload<ExtArgs> | null
      post: Prisma.$postPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      report_type: string
      content: string | null
      created_at: Date
      post_id: string | null
      user_id: string | null
    }, ExtArgs["result"]["report_post"]>
    composites: {}
  }

  type report_postGetPayload<S extends boolean | null | undefined | report_postDefaultArgs> = $Result.GetResult<Prisma.$report_postPayload, S>

  type report_postCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<report_postFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Report_postCountAggregateInputType | true
    }

  export interface report_postDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['report_post'], meta: { name: 'report_post' } }
    /**
     * Find zero or one Report_post that matches the filter.
     * @param {report_postFindUniqueArgs} args - Arguments to find a Report_post
     * @example
     * // Get one Report_post
     * const report_post = await prisma.report_post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends report_postFindUniqueArgs>(args: SelectSubset<T, report_postFindUniqueArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Report_post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {report_postFindUniqueOrThrowArgs} args - Arguments to find a Report_post
     * @example
     * // Get one Report_post
     * const report_post = await prisma.report_post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends report_postFindUniqueOrThrowArgs>(args: SelectSubset<T, report_postFindUniqueOrThrowArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postFindFirstArgs} args - Arguments to find a Report_post
     * @example
     * // Get one Report_post
     * const report_post = await prisma.report_post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends report_postFindFirstArgs>(args?: SelectSubset<T, report_postFindFirstArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Report_post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postFindFirstOrThrowArgs} args - Arguments to find a Report_post
     * @example
     * // Get one Report_post
     * const report_post = await prisma.report_post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends report_postFindFirstOrThrowArgs>(args?: SelectSubset<T, report_postFindFirstOrThrowArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Report_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Report_posts
     * const report_posts = await prisma.report_post.findMany()
     * 
     * // Get first 10 Report_posts
     * const report_posts = await prisma.report_post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const report_postWithIdOnly = await prisma.report_post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends report_postFindManyArgs>(args?: SelectSubset<T, report_postFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Report_post.
     * @param {report_postCreateArgs} args - Arguments to create a Report_post.
     * @example
     * // Create one Report_post
     * const Report_post = await prisma.report_post.create({
     *   data: {
     *     // ... data to create a Report_post
     *   }
     * })
     * 
     */
    create<T extends report_postCreateArgs>(args: SelectSubset<T, report_postCreateArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Report_posts.
     * @param {report_postCreateManyArgs} args - Arguments to create many Report_posts.
     * @example
     * // Create many Report_posts
     * const report_post = await prisma.report_post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends report_postCreateManyArgs>(args?: SelectSubset<T, report_postCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Report_posts and returns the data saved in the database.
     * @param {report_postCreateManyAndReturnArgs} args - Arguments to create many Report_posts.
     * @example
     * // Create many Report_posts
     * const report_post = await prisma.report_post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Report_posts and only return the `id`
     * const report_postWithIdOnly = await prisma.report_post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends report_postCreateManyAndReturnArgs>(args?: SelectSubset<T, report_postCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Report_post.
     * @param {report_postDeleteArgs} args - Arguments to delete one Report_post.
     * @example
     * // Delete one Report_post
     * const Report_post = await prisma.report_post.delete({
     *   where: {
     *     // ... filter to delete one Report_post
     *   }
     * })
     * 
     */
    delete<T extends report_postDeleteArgs>(args: SelectSubset<T, report_postDeleteArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Report_post.
     * @param {report_postUpdateArgs} args - Arguments to update one Report_post.
     * @example
     * // Update one Report_post
     * const report_post = await prisma.report_post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends report_postUpdateArgs>(args: SelectSubset<T, report_postUpdateArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Report_posts.
     * @param {report_postDeleteManyArgs} args - Arguments to filter Report_posts to delete.
     * @example
     * // Delete a few Report_posts
     * const { count } = await prisma.report_post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends report_postDeleteManyArgs>(args?: SelectSubset<T, report_postDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Report_posts
     * const report_post = await prisma.report_post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends report_postUpdateManyArgs>(args: SelectSubset<T, report_postUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Report_posts and returns the data updated in the database.
     * @param {report_postUpdateManyAndReturnArgs} args - Arguments to update many Report_posts.
     * @example
     * // Update many Report_posts
     * const report_post = await prisma.report_post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Report_posts and only return the `id`
     * const report_postWithIdOnly = await prisma.report_post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends report_postUpdateManyAndReturnArgs>(args: SelectSubset<T, report_postUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Report_post.
     * @param {report_postUpsertArgs} args - Arguments to update or create a Report_post.
     * @example
     * // Update or create a Report_post
     * const report_post = await prisma.report_post.upsert({
     *   create: {
     *     // ... data to create a Report_post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report_post we want to update
     *   }
     * })
     */
    upsert<T extends report_postUpsertArgs>(args: SelectSubset<T, report_postUpsertArgs<ExtArgs>>): Prisma__report_postClient<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Report_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postCountArgs} args - Arguments to filter Report_posts to count.
     * @example
     * // Count the number of Report_posts
     * const count = await prisma.report_post.count({
     *   where: {
     *     // ... the filter for the Report_posts we want to count
     *   }
     * })
    **/
    count<T extends report_postCountArgs>(
      args?: Subset<T, report_postCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Report_postCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report_post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Report_postAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Report_postAggregateArgs>(args: Subset<T, Report_postAggregateArgs>): Prisma.PrismaPromise<GetReport_postAggregateType<T>>

    /**
     * Group by Report_post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {report_postGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends report_postGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: report_postGroupByArgs['orderBy'] }
        : { orderBy?: report_postGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, report_postGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReport_postGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the report_post model
   */
  readonly fields: report_postFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for report_post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__report_postClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends report_post$userArgs<ExtArgs> = {}>(args?: Subset<T, report_post$userArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post<T extends report_post$postArgs<ExtArgs> = {}>(args?: Subset<T, report_post$postArgs<ExtArgs>>): Prisma__postClient<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the report_post model
   */
  interface report_postFieldRefs {
    readonly id: FieldRef<"report_post", 'String'>
    readonly report_type: FieldRef<"report_post", 'String'>
    readonly content: FieldRef<"report_post", 'String'>
    readonly created_at: FieldRef<"report_post", 'DateTime'>
    readonly post_id: FieldRef<"report_post", 'String'>
    readonly user_id: FieldRef<"report_post", 'String'>
  }
    

  // Custom InputTypes
  /**
   * report_post findUnique
   */
  export type report_postFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter, which report_post to fetch.
     */
    where: report_postWhereUniqueInput
  }

  /**
   * report_post findUniqueOrThrow
   */
  export type report_postFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter, which report_post to fetch.
     */
    where: report_postWhereUniqueInput
  }

  /**
   * report_post findFirst
   */
  export type report_postFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter, which report_post to fetch.
     */
    where?: report_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_posts to fetch.
     */
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_posts.
     */
    cursor?: report_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_posts.
     */
    distinct?: Report_postScalarFieldEnum | Report_postScalarFieldEnum[]
  }

  /**
   * report_post findFirstOrThrow
   */
  export type report_postFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter, which report_post to fetch.
     */
    where?: report_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_posts to fetch.
     */
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for report_posts.
     */
    cursor?: report_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of report_posts.
     */
    distinct?: Report_postScalarFieldEnum | Report_postScalarFieldEnum[]
  }

  /**
   * report_post findMany
   */
  export type report_postFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter, which report_posts to fetch.
     */
    where?: report_postWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of report_posts to fetch.
     */
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing report_posts.
     */
    cursor?: report_postWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` report_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` report_posts.
     */
    skip?: number
    distinct?: Report_postScalarFieldEnum | Report_postScalarFieldEnum[]
  }

  /**
   * report_post create
   */
  export type report_postCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * The data needed to create a report_post.
     */
    data: XOR<report_postCreateInput, report_postUncheckedCreateInput>
  }

  /**
   * report_post createMany
   */
  export type report_postCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many report_posts.
     */
    data: report_postCreateManyInput | report_postCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * report_post createManyAndReturn
   */
  export type report_postCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * The data used to create many report_posts.
     */
    data: report_postCreateManyInput | report_postCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_post update
   */
  export type report_postUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * The data needed to update a report_post.
     */
    data: XOR<report_postUpdateInput, report_postUncheckedUpdateInput>
    /**
     * Choose, which report_post to update.
     */
    where: report_postWhereUniqueInput
  }

  /**
   * report_post updateMany
   */
  export type report_postUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update report_posts.
     */
    data: XOR<report_postUpdateManyMutationInput, report_postUncheckedUpdateManyInput>
    /**
     * Filter which report_posts to update
     */
    where?: report_postWhereInput
    /**
     * Limit how many report_posts to update.
     */
    limit?: number
  }

  /**
   * report_post updateManyAndReturn
   */
  export type report_postUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * The data used to update report_posts.
     */
    data: XOR<report_postUpdateManyMutationInput, report_postUncheckedUpdateManyInput>
    /**
     * Filter which report_posts to update
     */
    where?: report_postWhereInput
    /**
     * Limit how many report_posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * report_post upsert
   */
  export type report_postUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * The filter to search for the report_post to update in case it exists.
     */
    where: report_postWhereUniqueInput
    /**
     * In case the report_post found by the `where` argument doesn't exist, create a new report_post with this data.
     */
    create: XOR<report_postCreateInput, report_postUncheckedCreateInput>
    /**
     * In case the report_post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<report_postUpdateInput, report_postUncheckedUpdateInput>
  }

  /**
   * report_post delete
   */
  export type report_postDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    /**
     * Filter which report_post to delete.
     */
    where: report_postWhereUniqueInput
  }

  /**
   * report_post deleteMany
   */
  export type report_postDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which report_posts to delete
     */
    where?: report_postWhereInput
    /**
     * Limit how many report_posts to delete.
     */
    limit?: number
  }

  /**
   * report_post.user
   */
  export type report_post$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    where?: userWhereInput
  }

  /**
   * report_post.post
   */
  export type report_post$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    where?: postWhereInput
  }

  /**
   * report_post without action
   */
  export type report_postDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
  }


  /**
   * Model reset_password
   */

  export type AggregateReset_password = {
    _count: Reset_passwordCountAggregateOutputType | null
    _min: Reset_passwordMinAggregateOutputType | null
    _max: Reset_passwordMaxAggregateOutputType | null
  }

  export type Reset_passwordMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expired_at: Date | null
    last_request_at: Date | null
  }

  export type Reset_passwordMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    expired_at: Date | null
    last_request_at: Date | null
  }

  export type Reset_passwordCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    expired_at: number
    last_request_at: number
    _all: number
  }


  export type Reset_passwordMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
  }

  export type Reset_passwordMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
  }

  export type Reset_passwordCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    expired_at?: true
    last_request_at?: true
    _all?: true
  }

  export type Reset_passwordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reset_password to aggregate.
     */
    where?: reset_passwordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reset_passwords to fetch.
     */
    orderBy?: reset_passwordOrderByWithRelationInput | reset_passwordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reset_passwordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reset_passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reset_passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reset_passwords
    **/
    _count?: true | Reset_passwordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Reset_passwordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Reset_passwordMaxAggregateInputType
  }

  export type GetReset_passwordAggregateType<T extends Reset_passwordAggregateArgs> = {
        [P in keyof T & keyof AggregateReset_password]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReset_password[P]>
      : GetScalarType<T[P], AggregateReset_password[P]>
  }




  export type reset_passwordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: reset_passwordWhereInput
    orderBy?: reset_passwordOrderByWithAggregationInput | reset_passwordOrderByWithAggregationInput[]
    by: Reset_passwordScalarFieldEnum[] | Reset_passwordScalarFieldEnum
    having?: reset_passwordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Reset_passwordCountAggregateInputType | true
    _min?: Reset_passwordMinAggregateInputType
    _max?: Reset_passwordMaxAggregateInputType
  }

  export type Reset_passwordGroupByOutputType = {
    id: string
    userId: string
    otp: string
    expired_at: Date
    last_request_at: Date
    _count: Reset_passwordCountAggregateOutputType | null
    _min: Reset_passwordMinAggregateOutputType | null
    _max: Reset_passwordMaxAggregateOutputType | null
  }

  type GetReset_passwordGroupByPayload<T extends reset_passwordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Reset_passwordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Reset_passwordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Reset_passwordGroupByOutputType[P]>
            : GetScalarType<T[P], Reset_passwordGroupByOutputType[P]>
        }
      >
    >


  export type reset_passwordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["reset_password"]>

  export type reset_passwordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["reset_password"]>

  export type reset_passwordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }, ExtArgs["result"]["reset_password"]>

  export type reset_passwordSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    expired_at?: boolean
    last_request_at?: boolean
  }

  export type reset_passwordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "otp" | "expired_at" | "last_request_at", ExtArgs["result"]["reset_password"]>

  export type $reset_passwordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reset_password"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otp: string
      expired_at: Date
      last_request_at: Date
    }, ExtArgs["result"]["reset_password"]>
    composites: {}
  }

  type reset_passwordGetPayload<S extends boolean | null | undefined | reset_passwordDefaultArgs> = $Result.GetResult<Prisma.$reset_passwordPayload, S>

  type reset_passwordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<reset_passwordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Reset_passwordCountAggregateInputType | true
    }

  export interface reset_passwordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reset_password'], meta: { name: 'reset_password' } }
    /**
     * Find zero or one Reset_password that matches the filter.
     * @param {reset_passwordFindUniqueArgs} args - Arguments to find a Reset_password
     * @example
     * // Get one Reset_password
     * const reset_password = await prisma.reset_password.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends reset_passwordFindUniqueArgs>(args: SelectSubset<T, reset_passwordFindUniqueArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reset_password that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {reset_passwordFindUniqueOrThrowArgs} args - Arguments to find a Reset_password
     * @example
     * // Get one Reset_password
     * const reset_password = await prisma.reset_password.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends reset_passwordFindUniqueOrThrowArgs>(args: SelectSubset<T, reset_passwordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reset_password that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordFindFirstArgs} args - Arguments to find a Reset_password
     * @example
     * // Get one Reset_password
     * const reset_password = await prisma.reset_password.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends reset_passwordFindFirstArgs>(args?: SelectSubset<T, reset_passwordFindFirstArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reset_password that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordFindFirstOrThrowArgs} args - Arguments to find a Reset_password
     * @example
     * // Get one Reset_password
     * const reset_password = await prisma.reset_password.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends reset_passwordFindFirstOrThrowArgs>(args?: SelectSubset<T, reset_passwordFindFirstOrThrowArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reset_passwords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reset_passwords
     * const reset_passwords = await prisma.reset_password.findMany()
     * 
     * // Get first 10 Reset_passwords
     * const reset_passwords = await prisma.reset_password.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reset_passwordWithIdOnly = await prisma.reset_password.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends reset_passwordFindManyArgs>(args?: SelectSubset<T, reset_passwordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reset_password.
     * @param {reset_passwordCreateArgs} args - Arguments to create a Reset_password.
     * @example
     * // Create one Reset_password
     * const Reset_password = await prisma.reset_password.create({
     *   data: {
     *     // ... data to create a Reset_password
     *   }
     * })
     * 
     */
    create<T extends reset_passwordCreateArgs>(args: SelectSubset<T, reset_passwordCreateArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reset_passwords.
     * @param {reset_passwordCreateManyArgs} args - Arguments to create many Reset_passwords.
     * @example
     * // Create many Reset_passwords
     * const reset_password = await prisma.reset_password.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends reset_passwordCreateManyArgs>(args?: SelectSubset<T, reset_passwordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reset_passwords and returns the data saved in the database.
     * @param {reset_passwordCreateManyAndReturnArgs} args - Arguments to create many Reset_passwords.
     * @example
     * // Create many Reset_passwords
     * const reset_password = await prisma.reset_password.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reset_passwords and only return the `id`
     * const reset_passwordWithIdOnly = await prisma.reset_password.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends reset_passwordCreateManyAndReturnArgs>(args?: SelectSubset<T, reset_passwordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reset_password.
     * @param {reset_passwordDeleteArgs} args - Arguments to delete one Reset_password.
     * @example
     * // Delete one Reset_password
     * const Reset_password = await prisma.reset_password.delete({
     *   where: {
     *     // ... filter to delete one Reset_password
     *   }
     * })
     * 
     */
    delete<T extends reset_passwordDeleteArgs>(args: SelectSubset<T, reset_passwordDeleteArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reset_password.
     * @param {reset_passwordUpdateArgs} args - Arguments to update one Reset_password.
     * @example
     * // Update one Reset_password
     * const reset_password = await prisma.reset_password.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends reset_passwordUpdateArgs>(args: SelectSubset<T, reset_passwordUpdateArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reset_passwords.
     * @param {reset_passwordDeleteManyArgs} args - Arguments to filter Reset_passwords to delete.
     * @example
     * // Delete a few Reset_passwords
     * const { count } = await prisma.reset_password.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends reset_passwordDeleteManyArgs>(args?: SelectSubset<T, reset_passwordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reset_passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reset_passwords
     * const reset_password = await prisma.reset_password.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends reset_passwordUpdateManyArgs>(args: SelectSubset<T, reset_passwordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reset_passwords and returns the data updated in the database.
     * @param {reset_passwordUpdateManyAndReturnArgs} args - Arguments to update many Reset_passwords.
     * @example
     * // Update many Reset_passwords
     * const reset_password = await prisma.reset_password.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reset_passwords and only return the `id`
     * const reset_passwordWithIdOnly = await prisma.reset_password.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends reset_passwordUpdateManyAndReturnArgs>(args: SelectSubset<T, reset_passwordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reset_password.
     * @param {reset_passwordUpsertArgs} args - Arguments to update or create a Reset_password.
     * @example
     * // Update or create a Reset_password
     * const reset_password = await prisma.reset_password.upsert({
     *   create: {
     *     // ... data to create a Reset_password
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reset_password we want to update
     *   }
     * })
     */
    upsert<T extends reset_passwordUpsertArgs>(args: SelectSubset<T, reset_passwordUpsertArgs<ExtArgs>>): Prisma__reset_passwordClient<$Result.GetResult<Prisma.$reset_passwordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reset_passwords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordCountArgs} args - Arguments to filter Reset_passwords to count.
     * @example
     * // Count the number of Reset_passwords
     * const count = await prisma.reset_password.count({
     *   where: {
     *     // ... the filter for the Reset_passwords we want to count
     *   }
     * })
    **/
    count<T extends reset_passwordCountArgs>(
      args?: Subset<T, reset_passwordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Reset_passwordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reset_password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Reset_passwordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Reset_passwordAggregateArgs>(args: Subset<T, Reset_passwordAggregateArgs>): Prisma.PrismaPromise<GetReset_passwordAggregateType<T>>

    /**
     * Group by Reset_password.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reset_passwordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends reset_passwordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: reset_passwordGroupByArgs['orderBy'] }
        : { orderBy?: reset_passwordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, reset_passwordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReset_passwordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reset_password model
   */
  readonly fields: reset_passwordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reset_password.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__reset_passwordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reset_password model
   */
  interface reset_passwordFieldRefs {
    readonly id: FieldRef<"reset_password", 'String'>
    readonly userId: FieldRef<"reset_password", 'String'>
    readonly otp: FieldRef<"reset_password", 'String'>
    readonly expired_at: FieldRef<"reset_password", 'DateTime'>
    readonly last_request_at: FieldRef<"reset_password", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * reset_password findUnique
   */
  export type reset_passwordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter, which reset_password to fetch.
     */
    where: reset_passwordWhereUniqueInput
  }

  /**
   * reset_password findUniqueOrThrow
   */
  export type reset_passwordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter, which reset_password to fetch.
     */
    where: reset_passwordWhereUniqueInput
  }

  /**
   * reset_password findFirst
   */
  export type reset_passwordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter, which reset_password to fetch.
     */
    where?: reset_passwordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reset_passwords to fetch.
     */
    orderBy?: reset_passwordOrderByWithRelationInput | reset_passwordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reset_passwords.
     */
    cursor?: reset_passwordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reset_passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reset_passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reset_passwords.
     */
    distinct?: Reset_passwordScalarFieldEnum | Reset_passwordScalarFieldEnum[]
  }

  /**
   * reset_password findFirstOrThrow
   */
  export type reset_passwordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter, which reset_password to fetch.
     */
    where?: reset_passwordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reset_passwords to fetch.
     */
    orderBy?: reset_passwordOrderByWithRelationInput | reset_passwordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reset_passwords.
     */
    cursor?: reset_passwordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reset_passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reset_passwords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reset_passwords.
     */
    distinct?: Reset_passwordScalarFieldEnum | Reset_passwordScalarFieldEnum[]
  }

  /**
   * reset_password findMany
   */
  export type reset_passwordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter, which reset_passwords to fetch.
     */
    where?: reset_passwordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reset_passwords to fetch.
     */
    orderBy?: reset_passwordOrderByWithRelationInput | reset_passwordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reset_passwords.
     */
    cursor?: reset_passwordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reset_passwords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reset_passwords.
     */
    skip?: number
    distinct?: Reset_passwordScalarFieldEnum | Reset_passwordScalarFieldEnum[]
  }

  /**
   * reset_password create
   */
  export type reset_passwordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * The data needed to create a reset_password.
     */
    data: XOR<reset_passwordCreateInput, reset_passwordUncheckedCreateInput>
  }

  /**
   * reset_password createMany
   */
  export type reset_passwordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many reset_passwords.
     */
    data: reset_passwordCreateManyInput | reset_passwordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reset_password createManyAndReturn
   */
  export type reset_passwordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * The data used to create many reset_passwords.
     */
    data: reset_passwordCreateManyInput | reset_passwordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reset_password update
   */
  export type reset_passwordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * The data needed to update a reset_password.
     */
    data: XOR<reset_passwordUpdateInput, reset_passwordUncheckedUpdateInput>
    /**
     * Choose, which reset_password to update.
     */
    where: reset_passwordWhereUniqueInput
  }

  /**
   * reset_password updateMany
   */
  export type reset_passwordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update reset_passwords.
     */
    data: XOR<reset_passwordUpdateManyMutationInput, reset_passwordUncheckedUpdateManyInput>
    /**
     * Filter which reset_passwords to update
     */
    where?: reset_passwordWhereInput
    /**
     * Limit how many reset_passwords to update.
     */
    limit?: number
  }

  /**
   * reset_password updateManyAndReturn
   */
  export type reset_passwordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * The data used to update reset_passwords.
     */
    data: XOR<reset_passwordUpdateManyMutationInput, reset_passwordUncheckedUpdateManyInput>
    /**
     * Filter which reset_passwords to update
     */
    where?: reset_passwordWhereInput
    /**
     * Limit how many reset_passwords to update.
     */
    limit?: number
  }

  /**
   * reset_password upsert
   */
  export type reset_passwordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * The filter to search for the reset_password to update in case it exists.
     */
    where: reset_passwordWhereUniqueInput
    /**
     * In case the reset_password found by the `where` argument doesn't exist, create a new reset_password with this data.
     */
    create: XOR<reset_passwordCreateInput, reset_passwordUncheckedCreateInput>
    /**
     * In case the reset_password was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reset_passwordUpdateInput, reset_passwordUncheckedUpdateInput>
  }

  /**
   * reset_password delete
   */
  export type reset_passwordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
    /**
     * Filter which reset_password to delete.
     */
    where: reset_passwordWhereUniqueInput
  }

  /**
   * reset_password deleteMany
   */
  export type reset_passwordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reset_passwords to delete
     */
    where?: reset_passwordWhereInput
    /**
     * Limit how many reset_passwords to delete.
     */
    limit?: number
  }

  /**
   * reset_password without action
   */
  export type reset_passwordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reset_password
     */
    select?: reset_passwordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reset_password
     */
    omit?: reset_passwordOmit<ExtArgs> | null
  }


  /**
   * Model reward
   */

  export type AggregateReward = {
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  export type RewardAvgAggregateOutputType = {
    amount: number | null
  }

  export type RewardSumAggregateOutputType = {
    amount: number | null
  }

  export type RewardMinAggregateOutputType = {
    id: string | null
    amount: number | null
    created_at: Date | null
    updated_at: Date | null
    guest_id: string | null
  }

  export type RewardMaxAggregateOutputType = {
    id: string | null
    amount: number | null
    created_at: Date | null
    updated_at: Date | null
    guest_id: string | null
  }

  export type RewardCountAggregateOutputType = {
    id: number
    amount: number
    created_at: number
    updated_at: number
    guest_id: number
    _all: number
  }


  export type RewardAvgAggregateInputType = {
    amount?: true
  }

  export type RewardSumAggregateInputType = {
    amount?: true
  }

  export type RewardMinAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    guest_id?: true
  }

  export type RewardMaxAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    guest_id?: true
  }

  export type RewardCountAggregateInputType = {
    id?: true
    amount?: true
    created_at?: true
    updated_at?: true
    guest_id?: true
    _all?: true
  }

  export type RewardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which reward to aggregate.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rewards
    **/
    _count?: true | RewardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RewardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RewardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RewardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RewardMaxAggregateInputType
  }

  export type GetRewardAggregateType<T extends RewardAggregateArgs> = {
        [P in keyof T & keyof AggregateReward]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReward[P]>
      : GetScalarType<T[P], AggregateReward[P]>
  }




  export type rewardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rewardWhereInput
    orderBy?: rewardOrderByWithAggregationInput | rewardOrderByWithAggregationInput[]
    by: RewardScalarFieldEnum[] | RewardScalarFieldEnum
    having?: rewardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RewardCountAggregateInputType | true
    _avg?: RewardAvgAggregateInputType
    _sum?: RewardSumAggregateInputType
    _min?: RewardMinAggregateInputType
    _max?: RewardMaxAggregateInputType
  }

  export type RewardGroupByOutputType = {
    id: string
    amount: number
    created_at: Date
    updated_at: Date
    guest_id: string | null
    _count: RewardCountAggregateOutputType | null
    _avg: RewardAvgAggregateOutputType | null
    _sum: RewardSumAggregateOutputType | null
    _min: RewardMinAggregateOutputType | null
    _max: RewardMaxAggregateOutputType | null
  }

  type GetRewardGroupByPayload<T extends rewardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RewardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RewardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RewardGroupByOutputType[P]>
            : GetScalarType<T[P], RewardGroupByOutputType[P]>
        }
      >
    >


  export type rewardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    guest_id?: boolean
    guest?: boolean | reward$guestArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    guest_id?: boolean
    guest?: boolean | reward$guestArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    guest_id?: boolean
    guest?: boolean | reward$guestArgs<ExtArgs>
  }, ExtArgs["result"]["reward"]>

  export type rewardSelectScalar = {
    id?: boolean
    amount?: boolean
    created_at?: boolean
    updated_at?: boolean
    guest_id?: boolean
  }

  export type rewardOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "created_at" | "updated_at" | "guest_id", ExtArgs["result"]["reward"]>
  export type rewardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | reward$guestArgs<ExtArgs>
  }
  export type rewardIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | reward$guestArgs<ExtArgs>
  }
  export type rewardIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | reward$guestArgs<ExtArgs>
  }

  export type $rewardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "reward"
    objects: {
      guest: Prisma.$guestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: number
      created_at: Date
      updated_at: Date
      guest_id: string | null
    }, ExtArgs["result"]["reward"]>
    composites: {}
  }

  type rewardGetPayload<S extends boolean | null | undefined | rewardDefaultArgs> = $Result.GetResult<Prisma.$rewardPayload, S>

  type rewardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rewardFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RewardCountAggregateInputType | true
    }

  export interface rewardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['reward'], meta: { name: 'reward' } }
    /**
     * Find zero or one Reward that matches the filter.
     * @param {rewardFindUniqueArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rewardFindUniqueArgs>(args: SelectSubset<T, rewardFindUniqueArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reward that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rewardFindUniqueOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rewardFindUniqueOrThrowArgs>(args: SelectSubset<T, rewardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindFirstArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rewardFindFirstArgs>(args?: SelectSubset<T, rewardFindFirstArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reward that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindFirstOrThrowArgs} args - Arguments to find a Reward
     * @example
     * // Get one Reward
     * const reward = await prisma.reward.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rewardFindFirstOrThrowArgs>(args?: SelectSubset<T, rewardFindFirstOrThrowArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rewards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rewards
     * const rewards = await prisma.reward.findMany()
     * 
     * // Get first 10 Rewards
     * const rewards = await prisma.reward.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rewardWithIdOnly = await prisma.reward.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rewardFindManyArgs>(args?: SelectSubset<T, rewardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reward.
     * @param {rewardCreateArgs} args - Arguments to create a Reward.
     * @example
     * // Create one Reward
     * const Reward = await prisma.reward.create({
     *   data: {
     *     // ... data to create a Reward
     *   }
     * })
     * 
     */
    create<T extends rewardCreateArgs>(args: SelectSubset<T, rewardCreateArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rewards.
     * @param {rewardCreateManyArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rewardCreateManyArgs>(args?: SelectSubset<T, rewardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rewards and returns the data saved in the database.
     * @param {rewardCreateManyAndReturnArgs} args - Arguments to create many Rewards.
     * @example
     * // Create many Rewards
     * const reward = await prisma.reward.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rewardCreateManyAndReturnArgs>(args?: SelectSubset<T, rewardCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reward.
     * @param {rewardDeleteArgs} args - Arguments to delete one Reward.
     * @example
     * // Delete one Reward
     * const Reward = await prisma.reward.delete({
     *   where: {
     *     // ... filter to delete one Reward
     *   }
     * })
     * 
     */
    delete<T extends rewardDeleteArgs>(args: SelectSubset<T, rewardDeleteArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reward.
     * @param {rewardUpdateArgs} args - Arguments to update one Reward.
     * @example
     * // Update one Reward
     * const reward = await prisma.reward.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rewardUpdateArgs>(args: SelectSubset<T, rewardUpdateArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rewards.
     * @param {rewardDeleteManyArgs} args - Arguments to filter Rewards to delete.
     * @example
     * // Delete a few Rewards
     * const { count } = await prisma.reward.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rewardDeleteManyArgs>(args?: SelectSubset<T, rewardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rewardUpdateManyArgs>(args: SelectSubset<T, rewardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rewards and returns the data updated in the database.
     * @param {rewardUpdateManyAndReturnArgs} args - Arguments to update many Rewards.
     * @example
     * // Update many Rewards
     * const reward = await prisma.reward.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rewards and only return the `id`
     * const rewardWithIdOnly = await prisma.reward.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rewardUpdateManyAndReturnArgs>(args: SelectSubset<T, rewardUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reward.
     * @param {rewardUpsertArgs} args - Arguments to update or create a Reward.
     * @example
     * // Update or create a Reward
     * const reward = await prisma.reward.upsert({
     *   create: {
     *     // ... data to create a Reward
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reward we want to update
     *   }
     * })
     */
    upsert<T extends rewardUpsertArgs>(args: SelectSubset<T, rewardUpsertArgs<ExtArgs>>): Prisma__rewardClient<$Result.GetResult<Prisma.$rewardPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rewards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardCountArgs} args - Arguments to filter Rewards to count.
     * @example
     * // Count the number of Rewards
     * const count = await prisma.reward.count({
     *   where: {
     *     // ... the filter for the Rewards we want to count
     *   }
     * })
    **/
    count<T extends rewardCountArgs>(
      args?: Subset<T, rewardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RewardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RewardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RewardAggregateArgs>(args: Subset<T, RewardAggregateArgs>): Prisma.PrismaPromise<GetRewardAggregateType<T>>

    /**
     * Group by Reward.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rewardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rewardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rewardGroupByArgs['orderBy'] }
        : { orderBy?: rewardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rewardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRewardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the reward model
   */
  readonly fields: rewardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for reward.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rewardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest<T extends reward$guestArgs<ExtArgs> = {}>(args?: Subset<T, reward$guestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the reward model
   */
  interface rewardFieldRefs {
    readonly id: FieldRef<"reward", 'String'>
    readonly amount: FieldRef<"reward", 'Int'>
    readonly created_at: FieldRef<"reward", 'DateTime'>
    readonly updated_at: FieldRef<"reward", 'DateTime'>
    readonly guest_id: FieldRef<"reward", 'String'>
  }
    

  // Custom InputTypes
  /**
   * reward findUnique
   */
  export type rewardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward findUniqueOrThrow
   */
  export type rewardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward findFirst
   */
  export type rewardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward findFirstOrThrow
   */
  export type rewardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter, which reward to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rewards.
     */
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward findMany
   */
  export type rewardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter, which rewards to fetch.
     */
    where?: rewardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rewards to fetch.
     */
    orderBy?: rewardOrderByWithRelationInput | rewardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rewards.
     */
    cursor?: rewardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rewards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rewards.
     */
    skip?: number
    distinct?: RewardScalarFieldEnum | RewardScalarFieldEnum[]
  }

  /**
   * reward create
   */
  export type rewardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * The data needed to create a reward.
     */
    data: XOR<rewardCreateInput, rewardUncheckedCreateInput>
  }

  /**
   * reward createMany
   */
  export type rewardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rewards.
     */
    data: rewardCreateManyInput | rewardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * reward createManyAndReturn
   */
  export type rewardCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data used to create many rewards.
     */
    data: rewardCreateManyInput | rewardCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * reward update
   */
  export type rewardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * The data needed to update a reward.
     */
    data: XOR<rewardUpdateInput, rewardUncheckedUpdateInput>
    /**
     * Choose, which reward to update.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward updateMany
   */
  export type rewardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardUpdateManyMutationInput, rewardUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to update.
     */
    limit?: number
  }

  /**
   * reward updateManyAndReturn
   */
  export type rewardUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * The data used to update rewards.
     */
    data: XOR<rewardUpdateManyMutationInput, rewardUncheckedUpdateManyInput>
    /**
     * Filter which rewards to update
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * reward upsert
   */
  export type rewardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * The filter to search for the reward to update in case it exists.
     */
    where: rewardWhereUniqueInput
    /**
     * In case the reward found by the `where` argument doesn't exist, create a new reward with this data.
     */
    create: XOR<rewardCreateInput, rewardUncheckedCreateInput>
    /**
     * In case the reward was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rewardUpdateInput, rewardUncheckedUpdateInput>
  }

  /**
   * reward delete
   */
  export type rewardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
    /**
     * Filter which reward to delete.
     */
    where: rewardWhereUniqueInput
  }

  /**
   * reward deleteMany
   */
  export type rewardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rewards to delete
     */
    where?: rewardWhereInput
    /**
     * Limit how many rewards to delete.
     */
    limit?: number
  }

  /**
   * reward.guest
   */
  export type reward$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * reward without action
   */
  export type rewardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the reward
     */
    select?: rewardSelect<ExtArgs> | null
    /**
     * Omit specific fields from the reward
     */
    omit?: rewardOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rewardInclude<ExtArgs> | null
  }


  /**
   * Model user
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    legal_name: string | null
    phone_number: string | null
    created_at: Date | null
    updated_at: Date | null
    user_name: string | null
    introduction: string | null
    guestId: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    legal_name: string | null
    phone_number: string | null
    created_at: Date | null
    updated_at: Date | null
    user_name: string | null
    introduction: string | null
    guestId: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    legal_name: number
    phone_number: number
    created_at: number
    updated_at: number
    user_name: number
    introduction: number
    guestId: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    legal_name?: true
    phone_number?: true
    created_at?: true
    updated_at?: true
    user_name?: true
    introduction?: true
    guestId?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    legal_name?: true
    phone_number?: true
    created_at?: true
    updated_at?: true
    user_name?: true
    introduction?: true
    guestId?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    legal_name?: true
    phone_number?: true
    created_at?: true
    updated_at?: true
    user_name?: true
    introduction?: true
    guestId?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type userGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userWhereInput
    orderBy?: userOrderByWithAggregationInput | userOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    legal_name: string
    phone_number: string
    created_at: Date
    updated_at: Date
    user_name: string | null
    introduction: string | null
    guestId: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends userGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legal_name?: boolean
    phone_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_name?: boolean
    introduction?: boolean
    guestId?: boolean
    block_user_block_user_blockerIdTouser?: boolean | user$block_user_block_user_blockerIdTouserArgs<ExtArgs>
    block_user_block_user_blockedIdTouser?: boolean | user$block_user_block_user_blockedIdTouserArgs<ExtArgs>
    chatroom_member?: boolean | user$chatroom_memberArgs<ExtArgs>
    combo?: boolean | user$comboArgs<ExtArgs>
    comment?: boolean | user$commentArgs<ExtArgs>
    followship_followship_followerIdTouser?: boolean | user$followship_followship_followerIdTouserArgs<ExtArgs>
    followship_followship_followedIdTouser?: boolean | user$followship_followship_followedIdTouserArgs<ExtArgs>
    message?: boolean | user$messageArgs<ExtArgs>
    post?: boolean | user$postArgs<ExtArgs>
    post_like?: boolean | user$post_likeArgs<ExtArgs>
    praise?: boolean | user$praiseArgs<ExtArgs>
    recycle_account?: boolean | user$recycle_accountArgs<ExtArgs>
    report_post?: boolean | user$report_postArgs<ExtArgs>
    guest?: boolean | user$guestArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legal_name?: boolean
    phone_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_name?: boolean
    introduction?: boolean
    guestId?: boolean
    guest?: boolean | user$guestArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    legal_name?: boolean
    phone_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_name?: boolean
    introduction?: boolean
    guestId?: boolean
    guest?: boolean | user$guestArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type userSelectScalar = {
    id?: boolean
    legal_name?: boolean
    phone_number?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_name?: boolean
    introduction?: boolean
    guestId?: boolean
  }

  export type userOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "legal_name" | "phone_number" | "created_at" | "updated_at" | "user_name" | "introduction" | "guestId", ExtArgs["result"]["user"]>
  export type userInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    block_user_block_user_blockerIdTouser?: boolean | user$block_user_block_user_blockerIdTouserArgs<ExtArgs>
    block_user_block_user_blockedIdTouser?: boolean | user$block_user_block_user_blockedIdTouserArgs<ExtArgs>
    chatroom_member?: boolean | user$chatroom_memberArgs<ExtArgs>
    combo?: boolean | user$comboArgs<ExtArgs>
    comment?: boolean | user$commentArgs<ExtArgs>
    followship_followship_followerIdTouser?: boolean | user$followship_followship_followerIdTouserArgs<ExtArgs>
    followship_followship_followedIdTouser?: boolean | user$followship_followship_followedIdTouserArgs<ExtArgs>
    message?: boolean | user$messageArgs<ExtArgs>
    post?: boolean | user$postArgs<ExtArgs>
    post_like?: boolean | user$post_likeArgs<ExtArgs>
    praise?: boolean | user$praiseArgs<ExtArgs>
    recycle_account?: boolean | user$recycle_accountArgs<ExtArgs>
    report_post?: boolean | user$report_postArgs<ExtArgs>
    guest?: boolean | user$guestArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type userIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | user$guestArgs<ExtArgs>
  }
  export type userIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | user$guestArgs<ExtArgs>
  }

  export type $userPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user"
    objects: {
      block_user_block_user_blockerIdTouser: Prisma.$block_userPayload<ExtArgs>[]
      block_user_block_user_blockedIdTouser: Prisma.$block_userPayload<ExtArgs>[]
      chatroom_member: Prisma.$chatroom_memberPayload<ExtArgs>[]
      combo: Prisma.$comboPayload<ExtArgs>[]
      comment: Prisma.$commentPayload<ExtArgs>[]
      followship_followship_followerIdTouser: Prisma.$followshipPayload<ExtArgs>[]
      followship_followship_followedIdTouser: Prisma.$followshipPayload<ExtArgs>[]
      message: Prisma.$messagePayload<ExtArgs>[]
      post: Prisma.$postPayload<ExtArgs>[]
      post_like: Prisma.$post_likePayload<ExtArgs>[]
      praise: Prisma.$praisePayload<ExtArgs>[]
      recycle_account: Prisma.$recycle_accountPayload<ExtArgs> | null
      report_post: Prisma.$report_postPayload<ExtArgs>[]
      guest: Prisma.$guestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      legal_name: string
      phone_number: string
      created_at: Date
      updated_at: Date
      user_name: string | null
      introduction: string | null
      guestId: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type userGetPayload<S extends boolean | null | undefined | userDefaultArgs> = $Result.GetResult<Prisma.$userPayload, S>

  type userCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user'], meta: { name: 'user' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userFindUniqueArgs>(args: SelectSubset<T, userFindUniqueArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(args: SelectSubset<T, userFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userFindFirstArgs>(args?: SelectSubset<T, userFindFirstArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(args?: SelectSubset<T, userFindFirstOrThrowArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userFindManyArgs>(args?: SelectSubset<T, userFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends userCreateArgs>(args: SelectSubset<T, userCreateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {userCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userCreateManyArgs>(args?: SelectSubset<T, userCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {userCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userCreateManyAndReturnArgs>(args?: SelectSubset<T, userCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends userDeleteArgs>(args: SelectSubset<T, userDeleteArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userUpdateArgs>(args: SelectSubset<T, userUpdateArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userDeleteManyArgs>(args?: SelectSubset<T, userDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userUpdateManyArgs>(args: SelectSubset<T, userUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {userUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userUpdateManyAndReturnArgs>(args: SelectSubset<T, userUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends userUpsertArgs>(args: SelectSubset<T, userUpsertArgs<ExtArgs>>): Prisma__userClient<$Result.GetResult<Prisma.$userPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userGroupByArgs['orderBy'] }
        : { orderBy?: userGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user model
   */
  readonly fields: userFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    block_user_block_user_blockerIdTouser<T extends user$block_user_block_user_blockerIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$block_user_block_user_blockerIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    block_user_block_user_blockedIdTouser<T extends user$block_user_block_user_blockedIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$block_user_block_user_blockedIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$block_userPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    chatroom_member<T extends user$chatroom_memberArgs<ExtArgs> = {}>(args?: Subset<T, user$chatroom_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatroom_memberPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    combo<T extends user$comboArgs<ExtArgs> = {}>(args?: Subset<T, user$comboArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$comboPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comment<T extends user$commentArgs<ExtArgs> = {}>(args?: Subset<T, user$commentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$commentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followship_followship_followerIdTouser<T extends user$followship_followship_followerIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$followship_followship_followerIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followship_followship_followedIdTouser<T extends user$followship_followship_followedIdTouserArgs<ExtArgs> = {}>(args?: Subset<T, user$followship_followship_followedIdTouserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    message<T extends user$messageArgs<ExtArgs> = {}>(args?: Subset<T, user$messageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    post<T extends user$postArgs<ExtArgs> = {}>(args?: Subset<T, user$postArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    post_like<T extends user$post_likeArgs<ExtArgs> = {}>(args?: Subset<T, user$post_likeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$post_likePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    praise<T extends user$praiseArgs<ExtArgs> = {}>(args?: Subset<T, user$praiseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$praisePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recycle_account<T extends user$recycle_accountArgs<ExtArgs> = {}>(args?: Subset<T, user$recycle_accountArgs<ExtArgs>>): Prisma__recycle_accountClient<$Result.GetResult<Prisma.$recycle_accountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    report_post<T extends user$report_postArgs<ExtArgs> = {}>(args?: Subset<T, user$report_postArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$report_postPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    guest<T extends user$guestArgs<ExtArgs> = {}>(args?: Subset<T, user$guestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user model
   */
  interface userFieldRefs {
    readonly id: FieldRef<"user", 'String'>
    readonly legal_name: FieldRef<"user", 'String'>
    readonly phone_number: FieldRef<"user", 'String'>
    readonly created_at: FieldRef<"user", 'DateTime'>
    readonly updated_at: FieldRef<"user", 'DateTime'>
    readonly user_name: FieldRef<"user", 'String'>
    readonly introduction: FieldRef<"user", 'String'>
    readonly guestId: FieldRef<"user", 'String'>
  }
    

  // Custom InputTypes
  /**
   * user findUnique
   */
  export type userFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findFirst
   */
  export type userFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user findMany
   */
  export type userFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: userOrderByWithRelationInput | userOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * user create
   */
  export type userCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }

  /**
   * user createMany
   */
  export type userCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user createManyAndReturn
   */
  export type userCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: userCreateManyInput | userCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user update
   */
  export type userUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }

  /**
   * user updateMany
   */
  export type userUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * user updateManyAndReturn
   */
  export type userUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user upsert
   */
  export type userUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }

  /**
   * user delete
   */
  export type userDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }

  /**
   * user deleteMany
   */
  export type userDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * user.block_user_block_user_blockerIdTouser
   */
  export type user$block_user_block_user_blockerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    where?: block_userWhereInput
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    cursor?: block_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Block_userScalarFieldEnum | Block_userScalarFieldEnum[]
  }

  /**
   * user.block_user_block_user_blockedIdTouser
   */
  export type user$block_user_block_user_blockedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the block_user
     */
    select?: block_userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the block_user
     */
    omit?: block_userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: block_userInclude<ExtArgs> | null
    where?: block_userWhereInput
    orderBy?: block_userOrderByWithRelationInput | block_userOrderByWithRelationInput[]
    cursor?: block_userWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Block_userScalarFieldEnum | Block_userScalarFieldEnum[]
  }

  /**
   * user.chatroom_member
   */
  export type user$chatroom_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatroom_member
     */
    select?: chatroom_memberSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatroom_member
     */
    omit?: chatroom_memberOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatroom_memberInclude<ExtArgs> | null
    where?: chatroom_memberWhereInput
    orderBy?: chatroom_memberOrderByWithRelationInput | chatroom_memberOrderByWithRelationInput[]
    cursor?: chatroom_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chatroom_memberScalarFieldEnum | Chatroom_memberScalarFieldEnum[]
  }

  /**
   * user.combo
   */
  export type user$comboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the combo
     */
    select?: comboSelect<ExtArgs> | null
    /**
     * Omit specific fields from the combo
     */
    omit?: comboOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: comboInclude<ExtArgs> | null
    where?: comboWhereInput
    orderBy?: comboOrderByWithRelationInput | comboOrderByWithRelationInput[]
    cursor?: comboWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboScalarFieldEnum | ComboScalarFieldEnum[]
  }

  /**
   * user.comment
   */
  export type user$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the comment
     */
    select?: commentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the comment
     */
    omit?: commentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: commentInclude<ExtArgs> | null
    where?: commentWhereInput
    orderBy?: commentOrderByWithRelationInput | commentOrderByWithRelationInput[]
    cursor?: commentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * user.followship_followship_followerIdTouser
   */
  export type user$followship_followship_followerIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    where?: followshipWhereInput
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    cursor?: followshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowshipScalarFieldEnum | FollowshipScalarFieldEnum[]
  }

  /**
   * user.followship_followship_followedIdTouser
   */
  export type user$followship_followship_followedIdTouserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followship
     */
    select?: followshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followship
     */
    omit?: followshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followshipInclude<ExtArgs> | null
    where?: followshipWhereInput
    orderBy?: followshipOrderByWithRelationInput | followshipOrderByWithRelationInput[]
    cursor?: followshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowshipScalarFieldEnum | FollowshipScalarFieldEnum[]
  }

  /**
   * user.message
   */
  export type user$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message
     */
    select?: messageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message
     */
    omit?: messageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messageInclude<ExtArgs> | null
    where?: messageWhereInput
    orderBy?: messageOrderByWithRelationInput | messageOrderByWithRelationInput[]
    cursor?: messageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * user.post
   */
  export type user$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post
     */
    select?: postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post
     */
    omit?: postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: postInclude<ExtArgs> | null
    where?: postWhereInput
    orderBy?: postOrderByWithRelationInput | postOrderByWithRelationInput[]
    cursor?: postWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * user.post_like
   */
  export type user$post_likeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the post_like
     */
    select?: post_likeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the post_like
     */
    omit?: post_likeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: post_likeInclude<ExtArgs> | null
    where?: post_likeWhereInput
    orderBy?: post_likeOrderByWithRelationInput | post_likeOrderByWithRelationInput[]
    cursor?: post_likeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Post_likeScalarFieldEnum | Post_likeScalarFieldEnum[]
  }

  /**
   * user.praise
   */
  export type user$praiseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the praise
     */
    select?: praiseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the praise
     */
    omit?: praiseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: praiseInclude<ExtArgs> | null
    where?: praiseWhereInput
    orderBy?: praiseOrderByWithRelationInput | praiseOrderByWithRelationInput[]
    cursor?: praiseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PraiseScalarFieldEnum | PraiseScalarFieldEnum[]
  }

  /**
   * user.recycle_account
   */
  export type user$recycle_accountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the recycle_account
     */
    select?: recycle_accountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the recycle_account
     */
    omit?: recycle_accountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recycle_accountInclude<ExtArgs> | null
    where?: recycle_accountWhereInput
  }

  /**
   * user.report_post
   */
  export type user$report_postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the report_post
     */
    select?: report_postSelect<ExtArgs> | null
    /**
     * Omit specific fields from the report_post
     */
    omit?: report_postOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: report_postInclude<ExtArgs> | null
    where?: report_postWhereInput
    orderBy?: report_postOrderByWithRelationInput | report_postOrderByWithRelationInput[]
    cursor?: report_postWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Report_postScalarFieldEnum | Report_postScalarFieldEnum[]
  }

  /**
   * user.guest
   */
  export type user$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * user without action
   */
  export type userDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user
     */
    omit?: userOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userInclude<ExtArgs> | null
  }


  /**
   * Model warning
   */

  export type AggregateWarning = {
    _count: WarningCountAggregateOutputType | null
    _min: WarningMinAggregateOutputType | null
    _max: WarningMaxAggregateOutputType | null
  }

  export type WarningMinAggregateOutputType = {
    id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    guestId: string | null
  }

  export type WarningMaxAggregateOutputType = {
    id: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
    guestId: string | null
  }

  export type WarningCountAggregateOutputType = {
    id: number
    status: number
    created_at: number
    updated_at: number
    guestId: number
    _all: number
  }


  export type WarningMinAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    updated_at?: true
    guestId?: true
  }

  export type WarningMaxAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    updated_at?: true
    guestId?: true
  }

  export type WarningCountAggregateInputType = {
    id?: true
    status?: true
    created_at?: true
    updated_at?: true
    guestId?: true
    _all?: true
  }

  export type WarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warning to aggregate.
     */
    where?: warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warnings to fetch.
     */
    orderBy?: warningOrderByWithRelationInput | warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned warnings
    **/
    _count?: true | WarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WarningMaxAggregateInputType
  }

  export type GetWarningAggregateType<T extends WarningAggregateArgs> = {
        [P in keyof T & keyof AggregateWarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWarning[P]>
      : GetScalarType<T[P], AggregateWarning[P]>
  }




  export type warningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: warningWhereInput
    orderBy?: warningOrderByWithAggregationInput | warningOrderByWithAggregationInput[]
    by: WarningScalarFieldEnum[] | WarningScalarFieldEnum
    having?: warningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WarningCountAggregateInputType | true
    _min?: WarningMinAggregateInputType
    _max?: WarningMaxAggregateInputType
  }

  export type WarningGroupByOutputType = {
    id: string
    status: string
    created_at: Date
    updated_at: Date
    guestId: string | null
    _count: WarningCountAggregateOutputType | null
    _min: WarningMinAggregateOutputType | null
    _max: WarningMaxAggregateOutputType | null
  }

  type GetWarningGroupByPayload<T extends warningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WarningGroupByOutputType[P]>
            : GetScalarType<T[P], WarningGroupByOutputType[P]>
        }
      >
    >


  export type warningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    guestId?: boolean
    guest?: boolean | warning$guestArgs<ExtArgs>
  }, ExtArgs["result"]["warning"]>

  export type warningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    guestId?: boolean
    guest?: boolean | warning$guestArgs<ExtArgs>
  }, ExtArgs["result"]["warning"]>

  export type warningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    guestId?: boolean
    guest?: boolean | warning$guestArgs<ExtArgs>
  }, ExtArgs["result"]["warning"]>

  export type warningSelectScalar = {
    id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    guestId?: boolean
  }

  export type warningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "status" | "created_at" | "updated_at" | "guestId", ExtArgs["result"]["warning"]>
  export type warningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | warning$guestArgs<ExtArgs>
  }
  export type warningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | warning$guestArgs<ExtArgs>
  }
  export type warningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    guest?: boolean | warning$guestArgs<ExtArgs>
  }

  export type $warningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "warning"
    objects: {
      guest: Prisma.$guestPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: string
      created_at: Date
      updated_at: Date
      guestId: string | null
    }, ExtArgs["result"]["warning"]>
    composites: {}
  }

  type warningGetPayload<S extends boolean | null | undefined | warningDefaultArgs> = $Result.GetResult<Prisma.$warningPayload, S>

  type warningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<warningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WarningCountAggregateInputType | true
    }

  export interface warningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['warning'], meta: { name: 'warning' } }
    /**
     * Find zero or one Warning that matches the filter.
     * @param {warningFindUniqueArgs} args - Arguments to find a Warning
     * @example
     * // Get one Warning
     * const warning = await prisma.warning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends warningFindUniqueArgs>(args: SelectSubset<T, warningFindUniqueArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Warning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {warningFindUniqueOrThrowArgs} args - Arguments to find a Warning
     * @example
     * // Get one Warning
     * const warning = await prisma.warning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends warningFindUniqueOrThrowArgs>(args: SelectSubset<T, warningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningFindFirstArgs} args - Arguments to find a Warning
     * @example
     * // Get one Warning
     * const warning = await prisma.warning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends warningFindFirstArgs>(args?: SelectSubset<T, warningFindFirstArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Warning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningFindFirstOrThrowArgs} args - Arguments to find a Warning
     * @example
     * // Get one Warning
     * const warning = await prisma.warning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends warningFindFirstOrThrowArgs>(args?: SelectSubset<T, warningFindFirstOrThrowArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Warnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Warnings
     * const warnings = await prisma.warning.findMany()
     * 
     * // Get first 10 Warnings
     * const warnings = await prisma.warning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const warningWithIdOnly = await prisma.warning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends warningFindManyArgs>(args?: SelectSubset<T, warningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Warning.
     * @param {warningCreateArgs} args - Arguments to create a Warning.
     * @example
     * // Create one Warning
     * const Warning = await prisma.warning.create({
     *   data: {
     *     // ... data to create a Warning
     *   }
     * })
     * 
     */
    create<T extends warningCreateArgs>(args: SelectSubset<T, warningCreateArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Warnings.
     * @param {warningCreateManyArgs} args - Arguments to create many Warnings.
     * @example
     * // Create many Warnings
     * const warning = await prisma.warning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends warningCreateManyArgs>(args?: SelectSubset<T, warningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Warnings and returns the data saved in the database.
     * @param {warningCreateManyAndReturnArgs} args - Arguments to create many Warnings.
     * @example
     * // Create many Warnings
     * const warning = await prisma.warning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Warnings and only return the `id`
     * const warningWithIdOnly = await prisma.warning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends warningCreateManyAndReturnArgs>(args?: SelectSubset<T, warningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Warning.
     * @param {warningDeleteArgs} args - Arguments to delete one Warning.
     * @example
     * // Delete one Warning
     * const Warning = await prisma.warning.delete({
     *   where: {
     *     // ... filter to delete one Warning
     *   }
     * })
     * 
     */
    delete<T extends warningDeleteArgs>(args: SelectSubset<T, warningDeleteArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Warning.
     * @param {warningUpdateArgs} args - Arguments to update one Warning.
     * @example
     * // Update one Warning
     * const warning = await prisma.warning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends warningUpdateArgs>(args: SelectSubset<T, warningUpdateArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Warnings.
     * @param {warningDeleteManyArgs} args - Arguments to filter Warnings to delete.
     * @example
     * // Delete a few Warnings
     * const { count } = await prisma.warning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends warningDeleteManyArgs>(args?: SelectSubset<T, warningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Warnings
     * const warning = await prisma.warning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends warningUpdateManyArgs>(args: SelectSubset<T, warningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Warnings and returns the data updated in the database.
     * @param {warningUpdateManyAndReturnArgs} args - Arguments to update many Warnings.
     * @example
     * // Update many Warnings
     * const warning = await prisma.warning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Warnings and only return the `id`
     * const warningWithIdOnly = await prisma.warning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends warningUpdateManyAndReturnArgs>(args: SelectSubset<T, warningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Warning.
     * @param {warningUpsertArgs} args - Arguments to update or create a Warning.
     * @example
     * // Update or create a Warning
     * const warning = await prisma.warning.upsert({
     *   create: {
     *     // ... data to create a Warning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Warning we want to update
     *   }
     * })
     */
    upsert<T extends warningUpsertArgs>(args: SelectSubset<T, warningUpsertArgs<ExtArgs>>): Prisma__warningClient<$Result.GetResult<Prisma.$warningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Warnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningCountArgs} args - Arguments to filter Warnings to count.
     * @example
     * // Count the number of Warnings
     * const count = await prisma.warning.count({
     *   where: {
     *     // ... the filter for the Warnings we want to count
     *   }
     * })
    **/
    count<T extends warningCountArgs>(
      args?: Subset<T, warningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Warning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WarningAggregateArgs>(args: Subset<T, WarningAggregateArgs>): Prisma.PrismaPromise<GetWarningAggregateType<T>>

    /**
     * Group by Warning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {warningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends warningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: warningGroupByArgs['orderBy'] }
        : { orderBy?: warningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, warningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the warning model
   */
  readonly fields: warningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for warning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__warningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    guest<T extends warning$guestArgs<ExtArgs> = {}>(args?: Subset<T, warning$guestArgs<ExtArgs>>): Prisma__guestClient<$Result.GetResult<Prisma.$guestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the warning model
   */
  interface warningFieldRefs {
    readonly id: FieldRef<"warning", 'String'>
    readonly status: FieldRef<"warning", 'String'>
    readonly created_at: FieldRef<"warning", 'DateTime'>
    readonly updated_at: FieldRef<"warning", 'DateTime'>
    readonly guestId: FieldRef<"warning", 'String'>
  }
    

  // Custom InputTypes
  /**
   * warning findUnique
   */
  export type warningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter, which warning to fetch.
     */
    where: warningWhereUniqueInput
  }

  /**
   * warning findUniqueOrThrow
   */
  export type warningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter, which warning to fetch.
     */
    where: warningWhereUniqueInput
  }

  /**
   * warning findFirst
   */
  export type warningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter, which warning to fetch.
     */
    where?: warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warnings to fetch.
     */
    orderBy?: warningOrderByWithRelationInput | warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warnings.
     */
    cursor?: warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warnings.
     */
    distinct?: WarningScalarFieldEnum | WarningScalarFieldEnum[]
  }

  /**
   * warning findFirstOrThrow
   */
  export type warningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter, which warning to fetch.
     */
    where?: warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warnings to fetch.
     */
    orderBy?: warningOrderByWithRelationInput | warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for warnings.
     */
    cursor?: warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of warnings.
     */
    distinct?: WarningScalarFieldEnum | WarningScalarFieldEnum[]
  }

  /**
   * warning findMany
   */
  export type warningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter, which warnings to fetch.
     */
    where?: warningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of warnings to fetch.
     */
    orderBy?: warningOrderByWithRelationInput | warningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing warnings.
     */
    cursor?: warningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` warnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` warnings.
     */
    skip?: number
    distinct?: WarningScalarFieldEnum | WarningScalarFieldEnum[]
  }

  /**
   * warning create
   */
  export type warningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * The data needed to create a warning.
     */
    data?: XOR<warningCreateInput, warningUncheckedCreateInput>
  }

  /**
   * warning createMany
   */
  export type warningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many warnings.
     */
    data: warningCreateManyInput | warningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * warning createManyAndReturn
   */
  export type warningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * The data used to create many warnings.
     */
    data: warningCreateManyInput | warningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * warning update
   */
  export type warningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * The data needed to update a warning.
     */
    data: XOR<warningUpdateInput, warningUncheckedUpdateInput>
    /**
     * Choose, which warning to update.
     */
    where: warningWhereUniqueInput
  }

  /**
   * warning updateMany
   */
  export type warningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update warnings.
     */
    data: XOR<warningUpdateManyMutationInput, warningUncheckedUpdateManyInput>
    /**
     * Filter which warnings to update
     */
    where?: warningWhereInput
    /**
     * Limit how many warnings to update.
     */
    limit?: number
  }

  /**
   * warning updateManyAndReturn
   */
  export type warningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * The data used to update warnings.
     */
    data: XOR<warningUpdateManyMutationInput, warningUncheckedUpdateManyInput>
    /**
     * Filter which warnings to update
     */
    where?: warningWhereInput
    /**
     * Limit how many warnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * warning upsert
   */
  export type warningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * The filter to search for the warning to update in case it exists.
     */
    where: warningWhereUniqueInput
    /**
     * In case the warning found by the `where` argument doesn't exist, create a new warning with this data.
     */
    create: XOR<warningCreateInput, warningUncheckedCreateInput>
    /**
     * In case the warning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<warningUpdateInput, warningUncheckedUpdateInput>
  }

  /**
   * warning delete
   */
  export type warningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
    /**
     * Filter which warning to delete.
     */
    where: warningWhereUniqueInput
  }

  /**
   * warning deleteMany
   */
  export type warningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which warnings to delete
     */
    where?: warningWhereInput
    /**
     * Limit how many warnings to delete.
     */
    limit?: number
  }

  /**
   * warning.guest
   */
  export type warning$guestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the guest
     */
    select?: guestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the guest
     */
    omit?: guestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: guestInclude<ExtArgs> | null
    where?: guestWhereInput
  }

  /**
   * warning without action
   */
  export type warningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the warning
     */
    select?: warningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the warning
     */
    omit?: warningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: warningInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ActivityScalarFieldEnum: {
    id: 'id',
    content: 'content',
    route: 'route',
    param: 'param',
    subscriber_avatar: 'subscriber_avatar',
    post_image: 'post_image',
    type: 'type',
    created_at: 'created_at',
    guestId: 'guestId',
    subscriberId: 'subscriberId'
  };

  export type ActivityScalarFieldEnum = (typeof ActivityScalarFieldEnum)[keyof typeof ActivityScalarFieldEnum]


  export const Block_userScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    blockerId: 'blockerId',
    blockedId: 'blockedId'
  };

  export type Block_userScalarFieldEnum = (typeof Block_userScalarFieldEnum)[keyof typeof Block_userScalarFieldEnum]


  export const ChatroomScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ChatroomScalarFieldEnum = (typeof ChatroomScalarFieldEnum)[keyof typeof ChatroomScalarFieldEnum]


  export const Chatroom_memberScalarFieldEnum: {
    chatroomId: 'chatroomId',
    userId: 'userId'
  };

  export type Chatroom_memberScalarFieldEnum = (typeof Chatroom_memberScalarFieldEnum)[keyof typeof Chatroom_memberScalarFieldEnum]


  export const ComboScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    post_id: 'post_id',
    count: 'count',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComboScalarFieldEnum = (typeof ComboScalarFieldEnum)[keyof typeof ComboScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    comment: 'comment',
    created_at: 'created_at',
    post_id: 'post_id',
    user_id: 'user_id'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ConfigScalarFieldEnum: {
    id: 'id',
    verify_amount: 'verify_amount'
  };

  export type ConfigScalarFieldEnum = (typeof ConfigScalarFieldEnum)[keyof typeof ConfigScalarFieldEnum]


  export const Email_otpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    expired_at: 'expired_at',
    last_request_at: 'last_request_at'
  };

  export type Email_otpScalarFieldEnum = (typeof Email_otpScalarFieldEnum)[keyof typeof Email_otpScalarFieldEnum]


  export const FollowshipScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    followedId: 'followedId',
    followerId: 'followerId'
  };

  export type FollowshipScalarFieldEnum = (typeof FollowshipScalarFieldEnum)[keyof typeof FollowshipScalarFieldEnum]


  export const GuestScalarFieldEnum: {
    id: 'id',
    password: 'password',
    user_name: 'user_name',
    avatar: 'avatar',
    verify_photo: 'verify_photo',
    verify: 'verify',
    created_at: 'created_at',
    updated_at: 'updated_at',
    email: 'email',
    emailOTP: 'emailOTP'
  };

  export type GuestScalarFieldEnum = (typeof GuestScalarFieldEnum)[keyof typeof GuestScalarFieldEnum]


  export const Image_messageScalarFieldEnum: {
    id: 'id',
    image: 'image',
    created_at: 'created_at',
    updated_at: 'updated_at',
    message_id: 'message_id'
  };

  export type Image_messageScalarFieldEnum = (typeof Image_messageScalarFieldEnum)[keyof typeof Image_messageScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    created_at: 'created_at',
    inviterId: 'inviterId',
    invitedId: 'invitedId'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    message: 'message',
    created_at: 'created_at',
    updated_at: 'updated_at',
    sender_id: 'sender_id',
    chatroom_id: 'chatroom_id',
    is_read: 'is_read',
    order: 'order'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    timestamp: 'timestamp',
    name: 'name'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    picture: 'picture',
    content: 'content',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const Post_likeScalarFieldEnum: {
    id: 'id',
    post_id: 'post_id',
    user_id: 'user_id'
  };

  export type Post_likeScalarFieldEnum = (typeof Post_likeScalarFieldEnum)[keyof typeof Post_likeScalarFieldEnum]


  export const PraiseScalarFieldEnum: {
    id: 'id',
    is_like: 'is_like',
    user_id: 'user_id',
    guest_id: 'guest_id',
    created_at: 'created_at'
  };

  export type PraiseScalarFieldEnum = (typeof PraiseScalarFieldEnum)[keyof typeof PraiseScalarFieldEnum]


  export const Recycle_accountScalarFieldEnum: {
    id: 'id',
    delete_time: 'delete_time',
    user_id: 'user_id'
  };

  export type Recycle_accountScalarFieldEnum = (typeof Recycle_accountScalarFieldEnum)[keyof typeof Recycle_accountScalarFieldEnum]


  export const Report_postScalarFieldEnum: {
    id: 'id',
    report_type: 'report_type',
    content: 'content',
    created_at: 'created_at',
    post_id: 'post_id',
    user_id: 'user_id'
  };

  export type Report_postScalarFieldEnum = (typeof Report_postScalarFieldEnum)[keyof typeof Report_postScalarFieldEnum]


  export const Reset_passwordScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    expired_at: 'expired_at',
    last_request_at: 'last_request_at'
  };

  export type Reset_passwordScalarFieldEnum = (typeof Reset_passwordScalarFieldEnum)[keyof typeof Reset_passwordScalarFieldEnum]


  export const RewardScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    created_at: 'created_at',
    updated_at: 'updated_at',
    guest_id: 'guest_id'
  };

  export type RewardScalarFieldEnum = (typeof RewardScalarFieldEnum)[keyof typeof RewardScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    legal_name: 'legal_name',
    phone_number: 'phone_number',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_name: 'user_name',
    introduction: 'introduction',
    guestId: 'guestId'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WarningScalarFieldEnum: {
    id: 'id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at',
    guestId: 'guestId'
  };

  export type WarningScalarFieldEnum = (typeof WarningScalarFieldEnum)[keyof typeof WarningScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type activityWhereInput = {
    AND?: activityWhereInput | activityWhereInput[]
    OR?: activityWhereInput[]
    NOT?: activityWhereInput | activityWhereInput[]
    id?: UuidFilter<"activity"> | string
    content?: StringFilter<"activity"> | string
    route?: StringFilter<"activity"> | string
    param?: StringFilter<"activity"> | string
    subscriber_avatar?: StringFilter<"activity"> | string
    post_image?: StringFilter<"activity"> | string
    type?: StringFilter<"activity"> | string
    created_at?: DateTimeFilter<"activity"> | Date | string
    guestId?: UuidNullableFilter<"activity"> | string | null
    subscriberId?: UuidNullableFilter<"activity"> | string | null
    guest_activity_subscriberIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    guest_activity_guestIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }

  export type activityOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    route?: SortOrder
    param?: SortOrder
    subscriber_avatar?: SortOrder
    post_image?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    guestId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    guest_activity_subscriberIdToguest?: guestOrderByWithRelationInput
    guest_activity_guestIdToguest?: guestOrderByWithRelationInput
  }

  export type activityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: activityWhereInput | activityWhereInput[]
    OR?: activityWhereInput[]
    NOT?: activityWhereInput | activityWhereInput[]
    content?: StringFilter<"activity"> | string
    route?: StringFilter<"activity"> | string
    param?: StringFilter<"activity"> | string
    subscriber_avatar?: StringFilter<"activity"> | string
    post_image?: StringFilter<"activity"> | string
    type?: StringFilter<"activity"> | string
    created_at?: DateTimeFilter<"activity"> | Date | string
    guestId?: UuidNullableFilter<"activity"> | string | null
    subscriberId?: UuidNullableFilter<"activity"> | string | null
    guest_activity_subscriberIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    guest_activity_guestIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }, "id">

  export type activityOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    route?: SortOrder
    param?: SortOrder
    subscriber_avatar?: SortOrder
    post_image?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    guestId?: SortOrderInput | SortOrder
    subscriberId?: SortOrderInput | SortOrder
    _count?: activityCountOrderByAggregateInput
    _max?: activityMaxOrderByAggregateInput
    _min?: activityMinOrderByAggregateInput
  }

  export type activityScalarWhereWithAggregatesInput = {
    AND?: activityScalarWhereWithAggregatesInput | activityScalarWhereWithAggregatesInput[]
    OR?: activityScalarWhereWithAggregatesInput[]
    NOT?: activityScalarWhereWithAggregatesInput | activityScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"activity"> | string
    content?: StringWithAggregatesFilter<"activity"> | string
    route?: StringWithAggregatesFilter<"activity"> | string
    param?: StringWithAggregatesFilter<"activity"> | string
    subscriber_avatar?: StringWithAggregatesFilter<"activity"> | string
    post_image?: StringWithAggregatesFilter<"activity"> | string
    type?: StringWithAggregatesFilter<"activity"> | string
    created_at?: DateTimeWithAggregatesFilter<"activity"> | Date | string
    guestId?: UuidNullableWithAggregatesFilter<"activity"> | string | null
    subscriberId?: UuidNullableWithAggregatesFilter<"activity"> | string | null
  }

  export type block_userWhereInput = {
    AND?: block_userWhereInput | block_userWhereInput[]
    OR?: block_userWhereInput[]
    NOT?: block_userWhereInput | block_userWhereInput[]
    id?: UuidFilter<"block_user"> | string
    created_at?: DateTimeFilter<"block_user"> | Date | string
    blockerId?: UuidNullableFilter<"block_user"> | string | null
    blockedId?: UuidNullableFilter<"block_user"> | string | null
    user_block_user_blockerIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_block_user_blockedIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type block_userOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    blockerId?: SortOrderInput | SortOrder
    blockedId?: SortOrderInput | SortOrder
    user_block_user_blockerIdTouser?: userOrderByWithRelationInput
    user_block_user_blockedIdTouser?: userOrderByWithRelationInput
  }

  export type block_userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: block_userWhereInput | block_userWhereInput[]
    OR?: block_userWhereInput[]
    NOT?: block_userWhereInput | block_userWhereInput[]
    created_at?: DateTimeFilter<"block_user"> | Date | string
    blockerId?: UuidNullableFilter<"block_user"> | string | null
    blockedId?: UuidNullableFilter<"block_user"> | string | null
    user_block_user_blockerIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_block_user_blockedIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type block_userOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    blockerId?: SortOrderInput | SortOrder
    blockedId?: SortOrderInput | SortOrder
    _count?: block_userCountOrderByAggregateInput
    _max?: block_userMaxOrderByAggregateInput
    _min?: block_userMinOrderByAggregateInput
  }

  export type block_userScalarWhereWithAggregatesInput = {
    AND?: block_userScalarWhereWithAggregatesInput | block_userScalarWhereWithAggregatesInput[]
    OR?: block_userScalarWhereWithAggregatesInput[]
    NOT?: block_userScalarWhereWithAggregatesInput | block_userScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"block_user"> | string
    created_at?: DateTimeWithAggregatesFilter<"block_user"> | Date | string
    blockerId?: UuidNullableWithAggregatesFilter<"block_user"> | string | null
    blockedId?: UuidNullableWithAggregatesFilter<"block_user"> | string | null
  }

  export type chatroomWhereInput = {
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    id?: UuidFilter<"chatroom"> | string
    created_at?: DateTimeFilter<"chatroom"> | Date | string
    updated_at?: DateTimeFilter<"chatroom"> | Date | string
    chatroom_member?: Chatroom_memberListRelationFilter
    message?: MessageListRelationFilter
  }

  export type chatroomOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    chatroom_member?: chatroom_memberOrderByRelationAggregateInput
    message?: messageOrderByRelationAggregateInput
  }

  export type chatroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatroomWhereInput | chatroomWhereInput[]
    OR?: chatroomWhereInput[]
    NOT?: chatroomWhereInput | chatroomWhereInput[]
    created_at?: DateTimeFilter<"chatroom"> | Date | string
    updated_at?: DateTimeFilter<"chatroom"> | Date | string
    chatroom_member?: Chatroom_memberListRelationFilter
    message?: MessageListRelationFilter
  }, "id">

  export type chatroomOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: chatroomCountOrderByAggregateInput
    _max?: chatroomMaxOrderByAggregateInput
    _min?: chatroomMinOrderByAggregateInput
  }

  export type chatroomScalarWhereWithAggregatesInput = {
    AND?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    OR?: chatroomScalarWhereWithAggregatesInput[]
    NOT?: chatroomScalarWhereWithAggregatesInput | chatroomScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"chatroom"> | string
    created_at?: DateTimeWithAggregatesFilter<"chatroom"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"chatroom"> | Date | string
  }

  export type chatroom_memberWhereInput = {
    AND?: chatroom_memberWhereInput | chatroom_memberWhereInput[]
    OR?: chatroom_memberWhereInput[]
    NOT?: chatroom_memberWhereInput | chatroom_memberWhereInput[]
    chatroomId?: UuidFilter<"chatroom_member"> | string
    userId?: UuidFilter<"chatroom_member"> | string
    chatroom?: XOR<ChatroomScalarRelationFilter, chatroomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type chatroom_memberOrderByWithRelationInput = {
    chatroomId?: SortOrder
    userId?: SortOrder
    chatroom?: chatroomOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type chatroom_memberWhereUniqueInput = Prisma.AtLeast<{
    chatroomId_userId?: chatroom_memberChatroomIdUserIdCompoundUniqueInput
    AND?: chatroom_memberWhereInput | chatroom_memberWhereInput[]
    OR?: chatroom_memberWhereInput[]
    NOT?: chatroom_memberWhereInput | chatroom_memberWhereInput[]
    chatroomId?: UuidFilter<"chatroom_member"> | string
    userId?: UuidFilter<"chatroom_member"> | string
    chatroom?: XOR<ChatroomScalarRelationFilter, chatroomWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "chatroomId_userId">

  export type chatroom_memberOrderByWithAggregationInput = {
    chatroomId?: SortOrder
    userId?: SortOrder
    _count?: chatroom_memberCountOrderByAggregateInput
    _max?: chatroom_memberMaxOrderByAggregateInput
    _min?: chatroom_memberMinOrderByAggregateInput
  }

  export type chatroom_memberScalarWhereWithAggregatesInput = {
    AND?: chatroom_memberScalarWhereWithAggregatesInput | chatroom_memberScalarWhereWithAggregatesInput[]
    OR?: chatroom_memberScalarWhereWithAggregatesInput[]
    NOT?: chatroom_memberScalarWhereWithAggregatesInput | chatroom_memberScalarWhereWithAggregatesInput[]
    chatroomId?: UuidWithAggregatesFilter<"chatroom_member"> | string
    userId?: UuidWithAggregatesFilter<"chatroom_member"> | string
  }

  export type comboWhereInput = {
    AND?: comboWhereInput | comboWhereInput[]
    OR?: comboWhereInput[]
    NOT?: comboWhereInput | comboWhereInput[]
    id?: UuidFilter<"combo"> | string
    user_id?: UuidFilter<"combo"> | string
    post_id?: UuidFilter<"combo"> | string
    count?: IntFilter<"combo"> | number
    created_at?: DateTimeFilter<"combo"> | Date | string
    updated_at?: DateTimeFilter<"combo"> | Date | string
    post?: XOR<PostScalarRelationFilter, postWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }

  export type comboOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    post_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    post?: postOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type comboWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: comboWhereInput | comboWhereInput[]
    OR?: comboWhereInput[]
    NOT?: comboWhereInput | comboWhereInput[]
    user_id?: UuidFilter<"combo"> | string
    post_id?: UuidFilter<"combo"> | string
    count?: IntFilter<"combo"> | number
    created_at?: DateTimeFilter<"combo"> | Date | string
    updated_at?: DateTimeFilter<"combo"> | Date | string
    post?: XOR<PostScalarRelationFilter, postWhereInput>
    user?: XOR<UserScalarRelationFilter, userWhereInput>
  }, "id">

  export type comboOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    post_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: comboCountOrderByAggregateInput
    _avg?: comboAvgOrderByAggregateInput
    _max?: comboMaxOrderByAggregateInput
    _min?: comboMinOrderByAggregateInput
    _sum?: comboSumOrderByAggregateInput
  }

  export type comboScalarWhereWithAggregatesInput = {
    AND?: comboScalarWhereWithAggregatesInput | comboScalarWhereWithAggregatesInput[]
    OR?: comboScalarWhereWithAggregatesInput[]
    NOT?: comboScalarWhereWithAggregatesInput | comboScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"combo"> | string
    user_id?: UuidWithAggregatesFilter<"combo"> | string
    post_id?: UuidWithAggregatesFilter<"combo"> | string
    count?: IntWithAggregatesFilter<"combo"> | number
    created_at?: DateTimeWithAggregatesFilter<"combo"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"combo"> | Date | string
  }

  export type commentWhereInput = {
    AND?: commentWhereInput | commentWhereInput[]
    OR?: commentWhereInput[]
    NOT?: commentWhereInput | commentWhereInput[]
    id?: UuidFilter<"comment"> | string
    comment?: StringFilter<"comment"> | string
    created_at?: DateTimeFilter<"comment"> | Date | string
    post_id?: UuidNullableFilter<"comment"> | string | null
    user_id?: UuidNullableFilter<"comment"> | string | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type commentOrderByWithRelationInput = {
    id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    post?: postOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type commentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: commentWhereInput | commentWhereInput[]
    OR?: commentWhereInput[]
    NOT?: commentWhereInput | commentWhereInput[]
    comment?: StringFilter<"comment"> | string
    created_at?: DateTimeFilter<"comment"> | Date | string
    post_id?: UuidNullableFilter<"comment"> | string | null
    user_id?: UuidNullableFilter<"comment"> | string | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type commentOrderByWithAggregationInput = {
    id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: commentCountOrderByAggregateInput
    _max?: commentMaxOrderByAggregateInput
    _min?: commentMinOrderByAggregateInput
  }

  export type commentScalarWhereWithAggregatesInput = {
    AND?: commentScalarWhereWithAggregatesInput | commentScalarWhereWithAggregatesInput[]
    OR?: commentScalarWhereWithAggregatesInput[]
    NOT?: commentScalarWhereWithAggregatesInput | commentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"comment"> | string
    comment?: StringWithAggregatesFilter<"comment"> | string
    created_at?: DateTimeWithAggregatesFilter<"comment"> | Date | string
    post_id?: UuidNullableWithAggregatesFilter<"comment"> | string | null
    user_id?: UuidNullableWithAggregatesFilter<"comment"> | string | null
  }

  export type configWhereInput = {
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    id?: UuidFilter<"config"> | string
    verify_amount?: IntFilter<"config"> | number
  }

  export type configOrderByWithRelationInput = {
    id?: SortOrder
    verify_amount?: SortOrder
  }

  export type configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: configWhereInput | configWhereInput[]
    OR?: configWhereInput[]
    NOT?: configWhereInput | configWhereInput[]
    verify_amount?: IntFilter<"config"> | number
  }, "id">

  export type configOrderByWithAggregationInput = {
    id?: SortOrder
    verify_amount?: SortOrder
    _count?: configCountOrderByAggregateInput
    _avg?: configAvgOrderByAggregateInput
    _max?: configMaxOrderByAggregateInput
    _min?: configMinOrderByAggregateInput
    _sum?: configSumOrderByAggregateInput
  }

  export type configScalarWhereWithAggregatesInput = {
    AND?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    OR?: configScalarWhereWithAggregatesInput[]
    NOT?: configScalarWhereWithAggregatesInput | configScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"config"> | string
    verify_amount?: IntWithAggregatesFilter<"config"> | number
  }

  export type email_otpWhereInput = {
    AND?: email_otpWhereInput | email_otpWhereInput[]
    OR?: email_otpWhereInput[]
    NOT?: email_otpWhereInput | email_otpWhereInput[]
    id?: UuidFilter<"email_otp"> | string
    userId?: StringFilter<"email_otp"> | string
    otp?: StringFilter<"email_otp"> | string
    expired_at?: DateTimeFilter<"email_otp"> | Date | string
    last_request_at?: DateTimeFilter<"email_otp"> | Date | string
  }

  export type email_otpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type email_otpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: email_otpWhereInput | email_otpWhereInput[]
    OR?: email_otpWhereInput[]
    NOT?: email_otpWhereInput | email_otpWhereInput[]
    userId?: StringFilter<"email_otp"> | string
    otp?: StringFilter<"email_otp"> | string
    expired_at?: DateTimeFilter<"email_otp"> | Date | string
    last_request_at?: DateTimeFilter<"email_otp"> | Date | string
  }, "id">

  export type email_otpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
    _count?: email_otpCountOrderByAggregateInput
    _max?: email_otpMaxOrderByAggregateInput
    _min?: email_otpMinOrderByAggregateInput
  }

  export type email_otpScalarWhereWithAggregatesInput = {
    AND?: email_otpScalarWhereWithAggregatesInput | email_otpScalarWhereWithAggregatesInput[]
    OR?: email_otpScalarWhereWithAggregatesInput[]
    NOT?: email_otpScalarWhereWithAggregatesInput | email_otpScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"email_otp"> | string
    userId?: StringWithAggregatesFilter<"email_otp"> | string
    otp?: StringWithAggregatesFilter<"email_otp"> | string
    expired_at?: DateTimeWithAggregatesFilter<"email_otp"> | Date | string
    last_request_at?: DateTimeWithAggregatesFilter<"email_otp"> | Date | string
  }

  export type followshipWhereInput = {
    AND?: followshipWhereInput | followshipWhereInput[]
    OR?: followshipWhereInput[]
    NOT?: followshipWhereInput | followshipWhereInput[]
    id?: UuidFilter<"followship"> | string
    created_at?: DateTimeFilter<"followship"> | Date | string
    followedId?: UuidNullableFilter<"followship"> | string | null
    followerId?: UuidNullableFilter<"followship"> | string | null
    user_followship_followerIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_followship_followedIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type followshipOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    followedId?: SortOrderInput | SortOrder
    followerId?: SortOrderInput | SortOrder
    user_followship_followerIdTouser?: userOrderByWithRelationInput
    user_followship_followedIdTouser?: userOrderByWithRelationInput
  }

  export type followshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: followshipWhereInput | followshipWhereInput[]
    OR?: followshipWhereInput[]
    NOT?: followshipWhereInput | followshipWhereInput[]
    created_at?: DateTimeFilter<"followship"> | Date | string
    followedId?: UuidNullableFilter<"followship"> | string | null
    followerId?: UuidNullableFilter<"followship"> | string | null
    user_followship_followerIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    user_followship_followedIdTouser?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type followshipOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    followedId?: SortOrderInput | SortOrder
    followerId?: SortOrderInput | SortOrder
    _count?: followshipCountOrderByAggregateInput
    _max?: followshipMaxOrderByAggregateInput
    _min?: followshipMinOrderByAggregateInput
  }

  export type followshipScalarWhereWithAggregatesInput = {
    AND?: followshipScalarWhereWithAggregatesInput | followshipScalarWhereWithAggregatesInput[]
    OR?: followshipScalarWhereWithAggregatesInput[]
    NOT?: followshipScalarWhereWithAggregatesInput | followshipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"followship"> | string
    created_at?: DateTimeWithAggregatesFilter<"followship"> | Date | string
    followedId?: UuidNullableWithAggregatesFilter<"followship"> | string | null
    followerId?: UuidNullableWithAggregatesFilter<"followship"> | string | null
  }

  export type guestWhereInput = {
    AND?: guestWhereInput | guestWhereInput[]
    OR?: guestWhereInput[]
    NOT?: guestWhereInput | guestWhereInput[]
    id?: UuidFilter<"guest"> | string
    password?: StringFilter<"guest"> | string
    user_name?: StringFilter<"guest"> | string
    avatar?: StringFilter<"guest"> | string
    verify_photo?: StringFilter<"guest"> | string
    verify?: BoolFilter<"guest"> | boolean
    created_at?: DateTimeFilter<"guest"> | Date | string
    updated_at?: DateTimeFilter<"guest"> | Date | string
    email?: StringFilter<"guest"> | string
    emailOTP?: BoolFilter<"guest"> | boolean
    activity_activity_subscriberIdToguest?: ActivityListRelationFilter
    activity_activity_guestIdToguest?: ActivityListRelationFilter
    invite_invite_invitedIdToguest?: XOR<InviteNullableScalarRelationFilter, inviteWhereInput> | null
    invite_invite_inviterIdToguest?: InviteListRelationFilter
    praise?: PraiseListRelationFilter
    reward?: RewardListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    warning?: XOR<WarningNullableScalarRelationFilter, warningWhereInput> | null
  }

  export type guestOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    user_name?: SortOrder
    avatar?: SortOrder
    verify_photo?: SortOrder
    verify?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    emailOTP?: SortOrder
    activity_activity_subscriberIdToguest?: activityOrderByRelationAggregateInput
    activity_activity_guestIdToguest?: activityOrderByRelationAggregateInput
    invite_invite_invitedIdToguest?: inviteOrderByWithRelationInput
    invite_invite_inviterIdToguest?: inviteOrderByRelationAggregateInput
    praise?: praiseOrderByRelationAggregateInput
    reward?: rewardOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    warning?: warningOrderByWithRelationInput
  }

  export type guestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: guestWhereInput | guestWhereInput[]
    OR?: guestWhereInput[]
    NOT?: guestWhereInput | guestWhereInput[]
    password?: StringFilter<"guest"> | string
    user_name?: StringFilter<"guest"> | string
    avatar?: StringFilter<"guest"> | string
    verify_photo?: StringFilter<"guest"> | string
    verify?: BoolFilter<"guest"> | boolean
    created_at?: DateTimeFilter<"guest"> | Date | string
    updated_at?: DateTimeFilter<"guest"> | Date | string
    email?: StringFilter<"guest"> | string
    emailOTP?: BoolFilter<"guest"> | boolean
    activity_activity_subscriberIdToguest?: ActivityListRelationFilter
    activity_activity_guestIdToguest?: ActivityListRelationFilter
    invite_invite_invitedIdToguest?: XOR<InviteNullableScalarRelationFilter, inviteWhereInput> | null
    invite_invite_inviterIdToguest?: InviteListRelationFilter
    praise?: PraiseListRelationFilter
    reward?: RewardListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    warning?: XOR<WarningNullableScalarRelationFilter, warningWhereInput> | null
  }, "id">

  export type guestOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    user_name?: SortOrder
    avatar?: SortOrder
    verify_photo?: SortOrder
    verify?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    emailOTP?: SortOrder
    _count?: guestCountOrderByAggregateInput
    _max?: guestMaxOrderByAggregateInput
    _min?: guestMinOrderByAggregateInput
  }

  export type guestScalarWhereWithAggregatesInput = {
    AND?: guestScalarWhereWithAggregatesInput | guestScalarWhereWithAggregatesInput[]
    OR?: guestScalarWhereWithAggregatesInput[]
    NOT?: guestScalarWhereWithAggregatesInput | guestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"guest"> | string
    password?: StringWithAggregatesFilter<"guest"> | string
    user_name?: StringWithAggregatesFilter<"guest"> | string
    avatar?: StringWithAggregatesFilter<"guest"> | string
    verify_photo?: StringWithAggregatesFilter<"guest"> | string
    verify?: BoolWithAggregatesFilter<"guest"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"guest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"guest"> | Date | string
    email?: StringWithAggregatesFilter<"guest"> | string
    emailOTP?: BoolWithAggregatesFilter<"guest"> | boolean
  }

  export type image_messageWhereInput = {
    AND?: image_messageWhereInput | image_messageWhereInput[]
    OR?: image_messageWhereInput[]
    NOT?: image_messageWhereInput | image_messageWhereInput[]
    id?: UuidFilter<"image_message"> | string
    image?: StringFilter<"image_message"> | string
    created_at?: DateTimeFilter<"image_message"> | Date | string
    updated_at?: DateTimeFilter<"image_message"> | Date | string
    message_id?: UuidNullableFilter<"image_message"> | string | null
    message?: XOR<MessageNullableScalarRelationFilter, messageWhereInput> | null
  }

  export type image_messageOrderByWithRelationInput = {
    id?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message_id?: SortOrderInput | SortOrder
    message?: messageOrderByWithRelationInput
  }

  export type image_messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: image_messageWhereInput | image_messageWhereInput[]
    OR?: image_messageWhereInput[]
    NOT?: image_messageWhereInput | image_messageWhereInput[]
    image?: StringFilter<"image_message"> | string
    created_at?: DateTimeFilter<"image_message"> | Date | string
    updated_at?: DateTimeFilter<"image_message"> | Date | string
    message_id?: UuidNullableFilter<"image_message"> | string | null
    message?: XOR<MessageNullableScalarRelationFilter, messageWhereInput> | null
  }, "id">

  export type image_messageOrderByWithAggregationInput = {
    id?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message_id?: SortOrderInput | SortOrder
    _count?: image_messageCountOrderByAggregateInput
    _max?: image_messageMaxOrderByAggregateInput
    _min?: image_messageMinOrderByAggregateInput
  }

  export type image_messageScalarWhereWithAggregatesInput = {
    AND?: image_messageScalarWhereWithAggregatesInput | image_messageScalarWhereWithAggregatesInput[]
    OR?: image_messageScalarWhereWithAggregatesInput[]
    NOT?: image_messageScalarWhereWithAggregatesInput | image_messageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"image_message"> | string
    image?: StringWithAggregatesFilter<"image_message"> | string
    created_at?: DateTimeWithAggregatesFilter<"image_message"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"image_message"> | Date | string
    message_id?: UuidNullableWithAggregatesFilter<"image_message"> | string | null
  }

  export type inviteWhereInput = {
    AND?: inviteWhereInput | inviteWhereInput[]
    OR?: inviteWhereInput[]
    NOT?: inviteWhereInput | inviteWhereInput[]
    id?: UuidFilter<"invite"> | string
    created_at?: DateTimeFilter<"invite"> | Date | string
    inviterId?: UuidNullableFilter<"invite"> | string | null
    invitedId?: UuidNullableFilter<"invite"> | string | null
    guest_invite_invitedIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    guest_invite_inviterIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }

  export type inviteOrderByWithRelationInput = {
    id?: SortOrder
    created_at?: SortOrder
    inviterId?: SortOrderInput | SortOrder
    invitedId?: SortOrderInput | SortOrder
    guest_invite_invitedIdToguest?: guestOrderByWithRelationInput
    guest_invite_inviterIdToguest?: guestOrderByWithRelationInput
  }

  export type inviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invitedId?: string
    AND?: inviteWhereInput | inviteWhereInput[]
    OR?: inviteWhereInput[]
    NOT?: inviteWhereInput | inviteWhereInput[]
    created_at?: DateTimeFilter<"invite"> | Date | string
    inviterId?: UuidNullableFilter<"invite"> | string | null
    guest_invite_invitedIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    guest_invite_inviterIdToguest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }, "id" | "invitedId">

  export type inviteOrderByWithAggregationInput = {
    id?: SortOrder
    created_at?: SortOrder
    inviterId?: SortOrderInput | SortOrder
    invitedId?: SortOrderInput | SortOrder
    _count?: inviteCountOrderByAggregateInput
    _max?: inviteMaxOrderByAggregateInput
    _min?: inviteMinOrderByAggregateInput
  }

  export type inviteScalarWhereWithAggregatesInput = {
    AND?: inviteScalarWhereWithAggregatesInput | inviteScalarWhereWithAggregatesInput[]
    OR?: inviteScalarWhereWithAggregatesInput[]
    NOT?: inviteScalarWhereWithAggregatesInput | inviteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"invite"> | string
    created_at?: DateTimeWithAggregatesFilter<"invite"> | Date | string
    inviterId?: UuidNullableWithAggregatesFilter<"invite"> | string | null
    invitedId?: UuidNullableWithAggregatesFilter<"invite"> | string | null
  }

  export type messageWhereInput = {
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    id?: UuidFilter<"message"> | string
    message?: StringFilter<"message"> | string
    created_at?: DateTimeFilter<"message"> | Date | string
    updated_at?: DateTimeFilter<"message"> | Date | string
    sender_id?: UuidNullableFilter<"message"> | string | null
    chatroom_id?: UuidNullableFilter<"message"> | string | null
    is_read?: BoolFilter<"message"> | boolean
    order?: IntFilter<"message"> | number
    image_message?: Image_messageListRelationFilter
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type messageOrderByWithRelationInput = {
    id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sender_id?: SortOrderInput | SortOrder
    chatroom_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    order?: SortOrder
    image_message?: image_messageOrderByRelationAggregateInput
    chatroom?: chatroomOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type messageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messageWhereInput | messageWhereInput[]
    OR?: messageWhereInput[]
    NOT?: messageWhereInput | messageWhereInput[]
    message?: StringFilter<"message"> | string
    created_at?: DateTimeFilter<"message"> | Date | string
    updated_at?: DateTimeFilter<"message"> | Date | string
    sender_id?: UuidNullableFilter<"message"> | string | null
    chatroom_id?: UuidNullableFilter<"message"> | string | null
    is_read?: BoolFilter<"message"> | boolean
    order?: IntFilter<"message"> | number
    image_message?: Image_messageListRelationFilter
    chatroom?: XOR<ChatroomNullableScalarRelationFilter, chatroomWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type messageOrderByWithAggregationInput = {
    id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sender_id?: SortOrderInput | SortOrder
    chatroom_id?: SortOrderInput | SortOrder
    is_read?: SortOrder
    order?: SortOrder
    _count?: messageCountOrderByAggregateInput
    _avg?: messageAvgOrderByAggregateInput
    _max?: messageMaxOrderByAggregateInput
    _min?: messageMinOrderByAggregateInput
    _sum?: messageSumOrderByAggregateInput
  }

  export type messageScalarWhereWithAggregatesInput = {
    AND?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    OR?: messageScalarWhereWithAggregatesInput[]
    NOT?: messageScalarWhereWithAggregatesInput | messageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"message"> | string
    message?: StringWithAggregatesFilter<"message"> | string
    created_at?: DateTimeWithAggregatesFilter<"message"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"message"> | Date | string
    sender_id?: UuidNullableWithAggregatesFilter<"message"> | string | null
    chatroom_id?: UuidNullableWithAggregatesFilter<"message"> | string | null
    is_read?: BoolWithAggregatesFilter<"message"> | boolean
    order?: IntWithAggregatesFilter<"message"> | number
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    timestamp?: BigIntFilter<"migrations"> | bigint | number
    name?: StringFilter<"migrations"> | string
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    timestamp?: BigIntFilter<"migrations"> | bigint | number
    name?: StringFilter<"migrations"> | string
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    timestamp?: BigIntWithAggregatesFilter<"migrations"> | bigint | number
    name?: StringWithAggregatesFilter<"migrations"> | string
  }

  export type postWhereInput = {
    AND?: postWhereInput | postWhereInput[]
    OR?: postWhereInput[]
    NOT?: postWhereInput | postWhereInput[]
    id?: UuidFilter<"post"> | string
    picture?: StringFilter<"post"> | string
    content?: StringFilter<"post"> | string
    created_at?: DateTimeFilter<"post"> | Date | string
    updated_at?: DateTimeFilter<"post"> | Date | string
    user_id?: UuidNullableFilter<"post"> | string | null
    combo?: ComboListRelationFilter
    comment?: CommentListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    post_like?: Post_likeListRelationFilter
    report_post?: Report_postListRelationFilter
  }

  export type postOrderByWithRelationInput = {
    id?: SortOrder
    picture?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    combo?: comboOrderByRelationAggregateInput
    comment?: commentOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    post_like?: post_likeOrderByRelationAggregateInput
    report_post?: report_postOrderByRelationAggregateInput
  }

  export type postWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: postWhereInput | postWhereInput[]
    OR?: postWhereInput[]
    NOT?: postWhereInput | postWhereInput[]
    picture?: StringFilter<"post"> | string
    content?: StringFilter<"post"> | string
    created_at?: DateTimeFilter<"post"> | Date | string
    updated_at?: DateTimeFilter<"post"> | Date | string
    user_id?: UuidNullableFilter<"post"> | string | null
    combo?: ComboListRelationFilter
    comment?: CommentListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    post_like?: Post_likeListRelationFilter
    report_post?: Report_postListRelationFilter
  }, "id">

  export type postOrderByWithAggregationInput = {
    id?: SortOrder
    picture?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: postCountOrderByAggregateInput
    _max?: postMaxOrderByAggregateInput
    _min?: postMinOrderByAggregateInput
  }

  export type postScalarWhereWithAggregatesInput = {
    AND?: postScalarWhereWithAggregatesInput | postScalarWhereWithAggregatesInput[]
    OR?: postScalarWhereWithAggregatesInput[]
    NOT?: postScalarWhereWithAggregatesInput | postScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"post"> | string
    picture?: StringWithAggregatesFilter<"post"> | string
    content?: StringWithAggregatesFilter<"post"> | string
    created_at?: DateTimeWithAggregatesFilter<"post"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"post"> | Date | string
    user_id?: UuidNullableWithAggregatesFilter<"post"> | string | null
  }

  export type post_likeWhereInput = {
    AND?: post_likeWhereInput | post_likeWhereInput[]
    OR?: post_likeWhereInput[]
    NOT?: post_likeWhereInput | post_likeWhereInput[]
    id?: UuidFilter<"post_like"> | string
    post_id?: UuidNullableFilter<"post_like"> | string | null
    user_id?: UuidNullableFilter<"post_like"> | string | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type post_likeOrderByWithRelationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    post?: postOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type post_likeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: post_likeWhereInput | post_likeWhereInput[]
    OR?: post_likeWhereInput[]
    NOT?: post_likeWhereInput | post_likeWhereInput[]
    post_id?: UuidNullableFilter<"post_like"> | string | null
    user_id?: UuidNullableFilter<"post_like"> | string | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type post_likeOrderByWithAggregationInput = {
    id?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: post_likeCountOrderByAggregateInput
    _max?: post_likeMaxOrderByAggregateInput
    _min?: post_likeMinOrderByAggregateInput
  }

  export type post_likeScalarWhereWithAggregatesInput = {
    AND?: post_likeScalarWhereWithAggregatesInput | post_likeScalarWhereWithAggregatesInput[]
    OR?: post_likeScalarWhereWithAggregatesInput[]
    NOT?: post_likeScalarWhereWithAggregatesInput | post_likeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"post_like"> | string
    post_id?: UuidNullableWithAggregatesFilter<"post_like"> | string | null
    user_id?: UuidNullableWithAggregatesFilter<"post_like"> | string | null
  }

  export type praiseWhereInput = {
    AND?: praiseWhereInput | praiseWhereInput[]
    OR?: praiseWhereInput[]
    NOT?: praiseWhereInput | praiseWhereInput[]
    id?: UuidFilter<"praise"> | string
    is_like?: BoolFilter<"praise"> | boolean
    user_id?: UuidNullableFilter<"praise"> | string | null
    guest_id?: UuidNullableFilter<"praise"> | string | null
    created_at?: DateTimeFilter<"praise"> | Date | string
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type praiseOrderByWithRelationInput = {
    id?: SortOrder
    is_like?: SortOrder
    user_id?: SortOrderInput | SortOrder
    guest_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    guest?: guestOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type praiseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: praiseWhereInput | praiseWhereInput[]
    OR?: praiseWhereInput[]
    NOT?: praiseWhereInput | praiseWhereInput[]
    is_like?: BoolFilter<"praise"> | boolean
    user_id?: UuidNullableFilter<"praise"> | string | null
    guest_id?: UuidNullableFilter<"praise"> | string | null
    created_at?: DateTimeFilter<"praise"> | Date | string
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id">

  export type praiseOrderByWithAggregationInput = {
    id?: SortOrder
    is_like?: SortOrder
    user_id?: SortOrderInput | SortOrder
    guest_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: praiseCountOrderByAggregateInput
    _max?: praiseMaxOrderByAggregateInput
    _min?: praiseMinOrderByAggregateInput
  }

  export type praiseScalarWhereWithAggregatesInput = {
    AND?: praiseScalarWhereWithAggregatesInput | praiseScalarWhereWithAggregatesInput[]
    OR?: praiseScalarWhereWithAggregatesInput[]
    NOT?: praiseScalarWhereWithAggregatesInput | praiseScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"praise"> | string
    is_like?: BoolWithAggregatesFilter<"praise"> | boolean
    user_id?: UuidNullableWithAggregatesFilter<"praise"> | string | null
    guest_id?: UuidNullableWithAggregatesFilter<"praise"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"praise"> | Date | string
  }

  export type recycle_accountWhereInput = {
    AND?: recycle_accountWhereInput | recycle_accountWhereInput[]
    OR?: recycle_accountWhereInput[]
    NOT?: recycle_accountWhereInput | recycle_accountWhereInput[]
    id?: UuidFilter<"recycle_account"> | string
    delete_time?: DateTimeFilter<"recycle_account"> | Date | string
    user_id?: UuidNullableFilter<"recycle_account"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }

  export type recycle_accountOrderByWithRelationInput = {
    id?: SortOrder
    delete_time?: SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
  }

  export type recycle_accountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    user_id?: string
    AND?: recycle_accountWhereInput | recycle_accountWhereInput[]
    OR?: recycle_accountWhereInput[]
    NOT?: recycle_accountWhereInput | recycle_accountWhereInput[]
    delete_time?: DateTimeFilter<"recycle_account"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
  }, "id" | "user_id">

  export type recycle_accountOrderByWithAggregationInput = {
    id?: SortOrder
    delete_time?: SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: recycle_accountCountOrderByAggregateInput
    _max?: recycle_accountMaxOrderByAggregateInput
    _min?: recycle_accountMinOrderByAggregateInput
  }

  export type recycle_accountScalarWhereWithAggregatesInput = {
    AND?: recycle_accountScalarWhereWithAggregatesInput | recycle_accountScalarWhereWithAggregatesInput[]
    OR?: recycle_accountScalarWhereWithAggregatesInput[]
    NOT?: recycle_accountScalarWhereWithAggregatesInput | recycle_accountScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"recycle_account"> | string
    delete_time?: DateTimeWithAggregatesFilter<"recycle_account"> | Date | string
    user_id?: UuidNullableWithAggregatesFilter<"recycle_account"> | string | null
  }

  export type report_postWhereInput = {
    AND?: report_postWhereInput | report_postWhereInput[]
    OR?: report_postWhereInput[]
    NOT?: report_postWhereInput | report_postWhereInput[]
    id?: UuidFilter<"report_post"> | string
    report_type?: StringFilter<"report_post"> | string
    content?: StringNullableFilter<"report_post"> | string | null
    created_at?: DateTimeFilter<"report_post"> | Date | string
    post_id?: UuidNullableFilter<"report_post"> | string | null
    user_id?: UuidNullableFilter<"report_post"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
  }

  export type report_postOrderByWithRelationInput = {
    id?: SortOrder
    report_type?: SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    user?: userOrderByWithRelationInput
    post?: postOrderByWithRelationInput
  }

  export type report_postWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: report_postWhereInput | report_postWhereInput[]
    OR?: report_postWhereInput[]
    NOT?: report_postWhereInput | report_postWhereInput[]
    report_type?: StringFilter<"report_post"> | string
    content?: StringNullableFilter<"report_post"> | string | null
    created_at?: DateTimeFilter<"report_post"> | Date | string
    post_id?: UuidNullableFilter<"report_post"> | string | null
    user_id?: UuidNullableFilter<"report_post"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, userWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, postWhereInput> | null
  }, "id">

  export type report_postOrderByWithAggregationInput = {
    id?: SortOrder
    report_type?: SortOrder
    content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    post_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    _count?: report_postCountOrderByAggregateInput
    _max?: report_postMaxOrderByAggregateInput
    _min?: report_postMinOrderByAggregateInput
  }

  export type report_postScalarWhereWithAggregatesInput = {
    AND?: report_postScalarWhereWithAggregatesInput | report_postScalarWhereWithAggregatesInput[]
    OR?: report_postScalarWhereWithAggregatesInput[]
    NOT?: report_postScalarWhereWithAggregatesInput | report_postScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"report_post"> | string
    report_type?: StringWithAggregatesFilter<"report_post"> | string
    content?: StringNullableWithAggregatesFilter<"report_post"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"report_post"> | Date | string
    post_id?: UuidNullableWithAggregatesFilter<"report_post"> | string | null
    user_id?: UuidNullableWithAggregatesFilter<"report_post"> | string | null
  }

  export type reset_passwordWhereInput = {
    AND?: reset_passwordWhereInput | reset_passwordWhereInput[]
    OR?: reset_passwordWhereInput[]
    NOT?: reset_passwordWhereInput | reset_passwordWhereInput[]
    id?: UuidFilter<"reset_password"> | string
    userId?: StringFilter<"reset_password"> | string
    otp?: StringFilter<"reset_password"> | string
    expired_at?: DateTimeFilter<"reset_password"> | Date | string
    last_request_at?: DateTimeFilter<"reset_password"> | Date | string
  }

  export type reset_passwordOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type reset_passwordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: reset_passwordWhereInput | reset_passwordWhereInput[]
    OR?: reset_passwordWhereInput[]
    NOT?: reset_passwordWhereInput | reset_passwordWhereInput[]
    userId?: StringFilter<"reset_password"> | string
    otp?: StringFilter<"reset_password"> | string
    expired_at?: DateTimeFilter<"reset_password"> | Date | string
    last_request_at?: DateTimeFilter<"reset_password"> | Date | string
  }, "id">

  export type reset_passwordOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
    _count?: reset_passwordCountOrderByAggregateInput
    _max?: reset_passwordMaxOrderByAggregateInput
    _min?: reset_passwordMinOrderByAggregateInput
  }

  export type reset_passwordScalarWhereWithAggregatesInput = {
    AND?: reset_passwordScalarWhereWithAggregatesInput | reset_passwordScalarWhereWithAggregatesInput[]
    OR?: reset_passwordScalarWhereWithAggregatesInput[]
    NOT?: reset_passwordScalarWhereWithAggregatesInput | reset_passwordScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reset_password"> | string
    userId?: StringWithAggregatesFilter<"reset_password"> | string
    otp?: StringWithAggregatesFilter<"reset_password"> | string
    expired_at?: DateTimeWithAggregatesFilter<"reset_password"> | Date | string
    last_request_at?: DateTimeWithAggregatesFilter<"reset_password"> | Date | string
  }

  export type rewardWhereInput = {
    AND?: rewardWhereInput | rewardWhereInput[]
    OR?: rewardWhereInput[]
    NOT?: rewardWhereInput | rewardWhereInput[]
    id?: UuidFilter<"reward"> | string
    amount?: IntFilter<"reward"> | number
    created_at?: DateTimeFilter<"reward"> | Date | string
    updated_at?: DateTimeFilter<"reward"> | Date | string
    guest_id?: UuidNullableFilter<"reward"> | string | null
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }

  export type rewardOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guest_id?: SortOrderInput | SortOrder
    guest?: guestOrderByWithRelationInput
  }

  export type rewardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: rewardWhereInput | rewardWhereInput[]
    OR?: rewardWhereInput[]
    NOT?: rewardWhereInput | rewardWhereInput[]
    amount?: IntFilter<"reward"> | number
    created_at?: DateTimeFilter<"reward"> | Date | string
    updated_at?: DateTimeFilter<"reward"> | Date | string
    guest_id?: UuidNullableFilter<"reward"> | string | null
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }, "id">

  export type rewardOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guest_id?: SortOrderInput | SortOrder
    _count?: rewardCountOrderByAggregateInput
    _avg?: rewardAvgOrderByAggregateInput
    _max?: rewardMaxOrderByAggregateInput
    _min?: rewardMinOrderByAggregateInput
    _sum?: rewardSumOrderByAggregateInput
  }

  export type rewardScalarWhereWithAggregatesInput = {
    AND?: rewardScalarWhereWithAggregatesInput | rewardScalarWhereWithAggregatesInput[]
    OR?: rewardScalarWhereWithAggregatesInput[]
    NOT?: rewardScalarWhereWithAggregatesInput | rewardScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"reward"> | string
    amount?: IntWithAggregatesFilter<"reward"> | number
    created_at?: DateTimeWithAggregatesFilter<"reward"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"reward"> | Date | string
    guest_id?: UuidNullableWithAggregatesFilter<"reward"> | string | null
  }

  export type userWhereInput = {
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    id?: UuidFilter<"user"> | string
    legal_name?: StringFilter<"user"> | string
    phone_number?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    user_name?: StringNullableFilter<"user"> | string | null
    introduction?: StringNullableFilter<"user"> | string | null
    guestId?: UuidNullableFilter<"user"> | string | null
    block_user_block_user_blockerIdTouser?: Block_userListRelationFilter
    block_user_block_user_blockedIdTouser?: Block_userListRelationFilter
    chatroom_member?: Chatroom_memberListRelationFilter
    combo?: ComboListRelationFilter
    comment?: CommentListRelationFilter
    followship_followship_followerIdTouser?: FollowshipListRelationFilter
    followship_followship_followedIdTouser?: FollowshipListRelationFilter
    message?: MessageListRelationFilter
    post?: PostListRelationFilter
    post_like?: Post_likeListRelationFilter
    praise?: PraiseListRelationFilter
    recycle_account?: XOR<Recycle_accountNullableScalarRelationFilter, recycle_accountWhereInput> | null
    report_post?: Report_postListRelationFilter
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    legal_name?: SortOrder
    phone_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_name?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    block_user_block_user_blockerIdTouser?: block_userOrderByRelationAggregateInput
    block_user_block_user_blockedIdTouser?: block_userOrderByRelationAggregateInput
    chatroom_member?: chatroom_memberOrderByRelationAggregateInput
    combo?: comboOrderByRelationAggregateInput
    comment?: commentOrderByRelationAggregateInput
    followship_followship_followerIdTouser?: followshipOrderByRelationAggregateInput
    followship_followship_followedIdTouser?: followshipOrderByRelationAggregateInput
    message?: messageOrderByRelationAggregateInput
    post?: postOrderByRelationAggregateInput
    post_like?: post_likeOrderByRelationAggregateInput
    praise?: praiseOrderByRelationAggregateInput
    recycle_account?: recycle_accountOrderByWithRelationInput
    report_post?: report_postOrderByRelationAggregateInput
    guest?: guestOrderByWithRelationInput
  }

  export type userWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guestId?: string
    AND?: userWhereInput | userWhereInput[]
    OR?: userWhereInput[]
    NOT?: userWhereInput | userWhereInput[]
    legal_name?: StringFilter<"user"> | string
    phone_number?: StringFilter<"user"> | string
    created_at?: DateTimeFilter<"user"> | Date | string
    updated_at?: DateTimeFilter<"user"> | Date | string
    user_name?: StringNullableFilter<"user"> | string | null
    introduction?: StringNullableFilter<"user"> | string | null
    block_user_block_user_blockerIdTouser?: Block_userListRelationFilter
    block_user_block_user_blockedIdTouser?: Block_userListRelationFilter
    chatroom_member?: Chatroom_memberListRelationFilter
    combo?: ComboListRelationFilter
    comment?: CommentListRelationFilter
    followship_followship_followerIdTouser?: FollowshipListRelationFilter
    followship_followship_followedIdTouser?: FollowshipListRelationFilter
    message?: MessageListRelationFilter
    post?: PostListRelationFilter
    post_like?: Post_likeListRelationFilter
    praise?: PraiseListRelationFilter
    recycle_account?: XOR<Recycle_accountNullableScalarRelationFilter, recycle_accountWhereInput> | null
    report_post?: Report_postListRelationFilter
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }, "id" | "guestId">

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    legal_name?: SortOrder
    phone_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_name?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    guestId?: SortOrderInput | SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    OR?: userScalarWhereWithAggregatesInput[]
    NOT?: userScalarWhereWithAggregatesInput | userScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"user"> | string
    legal_name?: StringWithAggregatesFilter<"user"> | string
    phone_number?: StringWithAggregatesFilter<"user"> | string
    created_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"user"> | Date | string
    user_name?: StringNullableWithAggregatesFilter<"user"> | string | null
    introduction?: StringNullableWithAggregatesFilter<"user"> | string | null
    guestId?: UuidNullableWithAggregatesFilter<"user"> | string | null
  }

  export type warningWhereInput = {
    AND?: warningWhereInput | warningWhereInput[]
    OR?: warningWhereInput[]
    NOT?: warningWhereInput | warningWhereInput[]
    id?: UuidFilter<"warning"> | string
    status?: StringFilter<"warning"> | string
    created_at?: DateTimeFilter<"warning"> | Date | string
    updated_at?: DateTimeFilter<"warning"> | Date | string
    guestId?: UuidNullableFilter<"warning"> | string | null
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }

  export type warningOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guestId?: SortOrderInput | SortOrder
    guest?: guestOrderByWithRelationInput
  }

  export type warningWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    guestId?: string
    AND?: warningWhereInput | warningWhereInput[]
    OR?: warningWhereInput[]
    NOT?: warningWhereInput | warningWhereInput[]
    status?: StringFilter<"warning"> | string
    created_at?: DateTimeFilter<"warning"> | Date | string
    updated_at?: DateTimeFilter<"warning"> | Date | string
    guest?: XOR<GuestNullableScalarRelationFilter, guestWhereInput> | null
  }, "id" | "guestId">

  export type warningOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guestId?: SortOrderInput | SortOrder
    _count?: warningCountOrderByAggregateInput
    _max?: warningMaxOrderByAggregateInput
    _min?: warningMinOrderByAggregateInput
  }

  export type warningScalarWhereWithAggregatesInput = {
    AND?: warningScalarWhereWithAggregatesInput | warningScalarWhereWithAggregatesInput[]
    OR?: warningScalarWhereWithAggregatesInput[]
    NOT?: warningScalarWhereWithAggregatesInput | warningScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"warning"> | string
    status?: StringWithAggregatesFilter<"warning"> | string
    created_at?: DateTimeWithAggregatesFilter<"warning"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"warning"> | Date | string
    guestId?: UuidNullableWithAggregatesFilter<"warning"> | string | null
  }

  export type activityCreateInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guest_activity_subscriberIdToguest?: guestCreateNestedOneWithoutActivity_activity_subscriberIdToguestInput
    guest_activity_guestIdToguest?: guestCreateNestedOneWithoutActivity_activity_guestIdToguestInput
  }

  export type activityUncheckedCreateInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guestId?: string | null
    subscriberId?: string | null
  }

  export type activityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_activity_subscriberIdToguest?: guestUpdateOneWithoutActivity_activity_subscriberIdToguestNestedInput
    guest_activity_guestIdToguest?: guestUpdateOneWithoutActivity_activity_guestIdToguestNestedInput
  }

  export type activityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type activityCreateManyInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guestId?: string | null
    subscriberId?: string | null
  }

  export type activityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type activityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userCreateInput = {
    id?: string
    created_at?: Date | string
    user_block_user_blockerIdTouser?: userCreateNestedOneWithoutBlock_user_block_user_blockerIdTouserInput
    user_block_user_blockedIdTouser?: userCreateNestedOneWithoutBlock_user_block_user_blockedIdTouserInput
  }

  export type block_userUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    blockerId?: string | null
    blockedId?: string | null
  }

  export type block_userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_block_user_blockerIdTouser?: userUpdateOneWithoutBlock_user_block_user_blockerIdTouserNestedInput
    user_block_user_blockedIdTouser?: userUpdateOneWithoutBlock_user_block_user_blockedIdTouserNestedInput
  }

  export type block_userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: NullableStringFieldUpdateOperationsInput | string | null
    blockedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userCreateManyInput = {
    id?: string
    created_at?: Date | string
    blockerId?: string | null
    blockedId?: string | null
  }

  export type block_userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type block_userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: NullableStringFieldUpdateOperationsInput | string | null
    blockedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatroomCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_member?: chatroom_memberCreateNestedManyWithoutChatroomInput
    message?: messageCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutChatroomInput
    message?: messageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_member?: chatroom_memberUpdateManyWithoutChatroomNestedInput
    message?: messageUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutChatroomNestedInput
    message?: messageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomCreateManyInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type chatroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type chatroom_memberCreateInput = {
    chatroom: chatroomCreateNestedOneWithoutChatroom_memberInput
    user: userCreateNestedOneWithoutChatroom_memberInput
  }

  export type chatroom_memberUncheckedCreateInput = {
    chatroomId: string
    userId: string
  }

  export type chatroom_memberUpdateInput = {
    chatroom?: chatroomUpdateOneRequiredWithoutChatroom_memberNestedInput
    user?: userUpdateOneRequiredWithoutChatroom_memberNestedInput
  }

  export type chatroom_memberUncheckedUpdateInput = {
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatroom_memberCreateManyInput = {
    chatroomId: string
    userId: string
  }

  export type chatroom_memberUpdateManyMutationInput = {

  }

  export type chatroom_memberUncheckedUpdateManyInput = {
    chatroomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type comboCreateInput = {
    id?: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
    post: postCreateNestedOneWithoutComboInput
    user: userCreateNestedOneWithoutComboInput
  }

  export type comboUncheckedCreateInput = {
    id?: string
    user_id: string
    post_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type comboUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postUpdateOneRequiredWithoutComboNestedInput
    user?: userUpdateOneRequiredWithoutComboNestedInput
  }

  export type comboUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comboCreateManyInput = {
    id?: string
    user_id: string
    post_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type comboUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comboUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentCreateInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post?: postCreateNestedOneWithoutCommentInput
    user?: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post_id?: string | null
    user_id?: string | null
  }

  export type commentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postUpdateOneWithoutCommentNestedInput
    user?: userUpdateOneWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentCreateManyInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post_id?: string | null
    user_id?: string | null
  }

  export type commentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type configCreateInput = {
    id?: string
    verify_amount: number
  }

  export type configUncheckedCreateInput = {
    id?: string
    verify_amount: number
  }

  export type configUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verify_amount?: IntFieldUpdateOperationsInput | number
  }

  export type configUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    verify_amount?: IntFieldUpdateOperationsInput | number
  }

  export type configCreateManyInput = {
    id?: string
    verify_amount: number
  }

  export type configUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    verify_amount?: IntFieldUpdateOperationsInput | number
  }

  export type configUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    verify_amount?: IntFieldUpdateOperationsInput | number
  }

  export type email_otpCreateInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type email_otpUncheckedCreateInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type email_otpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type email_otpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type email_otpCreateManyInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type email_otpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type email_otpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type followshipCreateInput = {
    id?: string
    created_at?: Date | string
    user_followship_followerIdTouser?: userCreateNestedOneWithoutFollowship_followship_followerIdTouserInput
    user_followship_followedIdTouser?: userCreateNestedOneWithoutFollowship_followship_followedIdTouserInput
  }

  export type followshipUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    followedId?: string | null
    followerId?: string | null
  }

  export type followshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_followship_followerIdTouser?: userUpdateOneWithoutFollowship_followship_followerIdTouserNestedInput
    user_followship_followedIdTouser?: userUpdateOneWithoutFollowship_followship_followedIdTouserNestedInput
  }

  export type followshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followedId?: NullableStringFieldUpdateOperationsInput | string | null
    followerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type followshipCreateManyInput = {
    id?: string
    created_at?: Date | string
    followedId?: string | null
    followerId?: string | null
  }

  export type followshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type followshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followedId?: NullableStringFieldUpdateOperationsInput | string | null
    followerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type guestCreateInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type guestCreateManyInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
  }

  export type guestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
  }

  export type guestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
  }

  export type image_messageCreateInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
    message?: messageCreateNestedOneWithoutImage_messageInput
  }

  export type image_messageUncheckedCreateInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
    message_id?: string | null
  }

  export type image_messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateOneWithoutImage_messageNestedInput
  }

  export type image_messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type image_messageCreateManyInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
    message_id?: string | null
  }

  export type image_messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inviteCreateInput = {
    id?: string
    created_at?: Date | string
    guest_invite_invitedIdToguest?: guestCreateNestedOneWithoutInvite_invite_invitedIdToguestInput
    guest_invite_inviterIdToguest?: guestCreateNestedOneWithoutInvite_invite_inviterIdToguestInput
  }

  export type inviteUncheckedCreateInput = {
    id?: string
    created_at?: Date | string
    inviterId?: string | null
    invitedId?: string | null
  }

  export type inviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_invite_invitedIdToguest?: guestUpdateOneWithoutInvite_invite_invitedIdToguestNestedInput
    guest_invite_inviterIdToguest?: guestUpdateOneWithoutInvite_invite_inviterIdToguestNestedInput
  }

  export type inviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    invitedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inviteCreateManyInput = {
    id?: string
    created_at?: Date | string
    inviterId?: string | null
    invitedId?: string | null
  }

  export type inviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type inviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
    invitedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageCreateInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
    order?: number
    image_message?: image_messageCreateNestedManyWithoutMessageInput
    chatroom?: chatroomCreateNestedOneWithoutMessageInput
    user?: userCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    sender_id?: string | null
    chatroom_id?: string | null
    is_read?: boolean
    order?: number
    image_message?: image_messageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUpdateManyWithoutMessageNestedInput
    chatroom?: chatroomUpdateOneWithoutMessageNestedInput
    user?: userUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageCreateManyInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    sender_id?: string | null
    chatroom_id?: string | null
    is_read?: boolean
    order?: number
  }

  export type messageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type messageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateInput = {
    timestamp: bigint | number
    name: string
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsCreateManyInput = {
    id?: number
    timestamp: bigint | number
    name: string
  }

  export type migrationsUpdateManyMutationInput = {
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type postCreateInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboCreateNestedManyWithoutPostInput
    comment?: commentCreateNestedManyWithoutPostInput
    user?: userCreateNestedOneWithoutPostInput
    post_like?: post_likeCreateNestedManyWithoutPostInput
    report_post?: report_postCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
    combo?: comboUncheckedCreateNestedManyWithoutPostInput
    comment?: commentUncheckedCreateNestedManyWithoutPostInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutPostInput
    report_post?: report_postUncheckedCreateNestedManyWithoutPostInput
  }

  export type postUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUpdateManyWithoutPostNestedInput
    comment?: commentUpdateManyWithoutPostNestedInput
    user?: userUpdateOneWithoutPostNestedInput
    post_like?: post_likeUpdateManyWithoutPostNestedInput
    report_post?: report_postUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    combo?: comboUncheckedUpdateManyWithoutPostNestedInput
    comment?: commentUncheckedUpdateManyWithoutPostNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutPostNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutPostNestedInput
  }

  export type postCreateManyInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
  }

  export type postUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type postUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type post_likeCreateInput = {
    id?: string
    post?: postCreateNestedOneWithoutPost_likeInput
    user?: userCreateNestedOneWithoutPost_likeInput
  }

  export type post_likeUncheckedCreateInput = {
    id?: string
    post_id?: string | null
    user_id?: string | null
  }

  export type post_likeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: postUpdateOneWithoutPost_likeNestedInput
    user?: userUpdateOneWithoutPost_likeNestedInput
  }

  export type post_likeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type post_likeCreateManyInput = {
    id?: string
    post_id?: string | null
    user_id?: string | null
  }

  export type post_likeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type post_likeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type praiseCreateInput = {
    id?: string
    is_like: boolean
    created_at?: Date | string
    guest?: guestCreateNestedOneWithoutPraiseInput
    user?: userCreateNestedOneWithoutPraiseInput
  }

  export type praiseUncheckedCreateInput = {
    id?: string
    is_like: boolean
    user_id?: string | null
    guest_id?: string | null
    created_at?: Date | string
  }

  export type praiseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: guestUpdateOneWithoutPraiseNestedInput
    user?: userUpdateOneWithoutPraiseNestedInput
  }

  export type praiseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type praiseCreateManyInput = {
    id?: string
    is_like: boolean
    user_id?: string | null
    guest_id?: string | null
    created_at?: Date | string
  }

  export type praiseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type praiseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recycle_accountCreateInput = {
    id?: string
    delete_time: Date | string
    user?: userCreateNestedOneWithoutRecycle_accountInput
  }

  export type recycle_accountUncheckedCreateInput = {
    id?: string
    delete_time: Date | string
    user_id?: string | null
  }

  export type recycle_accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutRecycle_accountNestedInput
  }

  export type recycle_accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recycle_accountCreateManyInput = {
    id?: string
    delete_time: Date | string
    user_id?: string | null
  }

  export type recycle_accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recycle_accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_postCreateInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    user?: userCreateNestedOneWithoutReport_postInput
    post?: postCreateNestedOneWithoutReport_postInput
  }

  export type report_postUncheckedCreateInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    post_id?: string | null
    user_id?: string | null
  }

  export type report_postUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutReport_postNestedInput
    post?: postUpdateOneWithoutReport_postNestedInput
  }

  export type report_postUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_postCreateManyInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    post_id?: string | null
    user_id?: string | null
  }

  export type report_postUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_postUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reset_passwordCreateInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type reset_passwordUncheckedCreateInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type reset_passwordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reset_passwordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reset_passwordCreateManyInput = {
    id?: string
    userId: string
    otp: string
    expired_at: Date | string
    last_request_at: Date | string
  }

  export type reset_passwordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reset_passwordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    expired_at?: DateTimeFieldUpdateOperationsInput | Date | string
    last_request_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardCreateInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
    guest?: guestCreateNestedOneWithoutRewardInput
  }

  export type rewardUncheckedCreateInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
    guest_id?: string | null
  }

  export type rewardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: guestUpdateOneWithoutRewardNestedInput
  }

  export type rewardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type rewardCreateManyInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
    guest_id?: string | null
  }

  export type rewardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userCreateInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateManyInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warningCreateInput = {
    id?: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    guest?: guestCreateNestedOneWithoutWarningInput
  }

  export type warningUncheckedCreateInput = {
    id?: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    guestId?: string | null
  }

  export type warningUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: guestUpdateOneWithoutWarningNestedInput
  }

  export type warningUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type warningCreateManyInput = {
    id?: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    guestId?: string | null
  }

  export type warningUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type warningUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type GuestNullableScalarRelationFilter = {
    is?: guestWhereInput | null
    isNot?: guestWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type activityCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    route?: SortOrder
    param?: SortOrder
    subscriber_avatar?: SortOrder
    post_image?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    guestId?: SortOrder
    subscriberId?: SortOrder
  }

  export type activityMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    route?: SortOrder
    param?: SortOrder
    subscriber_avatar?: SortOrder
    post_image?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    guestId?: SortOrder
    subscriberId?: SortOrder
  }

  export type activityMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    route?: SortOrder
    param?: SortOrder
    subscriber_avatar?: SortOrder
    post_image?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    guestId?: SortOrder
    subscriberId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UserNullableScalarRelationFilter = {
    is?: userWhereInput | null
    isNot?: userWhereInput | null
  }

  export type block_userCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type block_userMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type block_userMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
  }

  export type Chatroom_memberListRelationFilter = {
    every?: chatroom_memberWhereInput
    some?: chatroom_memberWhereInput
    none?: chatroom_memberWhereInput
  }

  export type MessageListRelationFilter = {
    every?: messageWhereInput
    some?: messageWhereInput
    none?: messageWhereInput
  }

  export type chatroom_memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatroomCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chatroomMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type chatroomMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ChatroomScalarRelationFilter = {
    is?: chatroomWhereInput
    isNot?: chatroomWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type chatroom_memberChatroomIdUserIdCompoundUniqueInput = {
    chatroomId: string
    userId: string
  }

  export type chatroom_memberCountOrderByAggregateInput = {
    chatroomId?: SortOrder
    userId?: SortOrder
  }

  export type chatroom_memberMaxOrderByAggregateInput = {
    chatroomId?: SortOrder
    userId?: SortOrder
  }

  export type chatroom_memberMinOrderByAggregateInput = {
    chatroomId?: SortOrder
    userId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PostScalarRelationFilter = {
    is?: postWhereInput
    isNot?: postWhereInput
  }

  export type comboCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    post_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type comboAvgOrderByAggregateInput = {
    count?: SortOrder
  }

  export type comboMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    post_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type comboMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    post_id?: SortOrder
    count?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type comboSumOrderByAggregateInput = {
    count?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PostNullableScalarRelationFilter = {
    is?: postWhereInput | null
    isNot?: postWhereInput | null
  }

  export type commentCountOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type commentMaxOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type commentMinOrderByAggregateInput = {
    id?: SortOrder
    comment?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type configCountOrderByAggregateInput = {
    id?: SortOrder
    verify_amount?: SortOrder
  }

  export type configAvgOrderByAggregateInput = {
    verify_amount?: SortOrder
  }

  export type configMaxOrderByAggregateInput = {
    id?: SortOrder
    verify_amount?: SortOrder
  }

  export type configMinOrderByAggregateInput = {
    id?: SortOrder
    verify_amount?: SortOrder
  }

  export type configSumOrderByAggregateInput = {
    verify_amount?: SortOrder
  }

  export type email_otpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type email_otpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type email_otpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type followshipCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    followedId?: SortOrder
    followerId?: SortOrder
  }

  export type followshipMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    followedId?: SortOrder
    followerId?: SortOrder
  }

  export type followshipMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    followedId?: SortOrder
    followerId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ActivityListRelationFilter = {
    every?: activityWhereInput
    some?: activityWhereInput
    none?: activityWhereInput
  }

  export type InviteNullableScalarRelationFilter = {
    is?: inviteWhereInput | null
    isNot?: inviteWhereInput | null
  }

  export type InviteListRelationFilter = {
    every?: inviteWhereInput
    some?: inviteWhereInput
    none?: inviteWhereInput
  }

  export type PraiseListRelationFilter = {
    every?: praiseWhereInput
    some?: praiseWhereInput
    none?: praiseWhereInput
  }

  export type RewardListRelationFilter = {
    every?: rewardWhereInput
    some?: rewardWhereInput
    none?: rewardWhereInput
  }

  export type WarningNullableScalarRelationFilter = {
    is?: warningWhereInput | null
    isNot?: warningWhereInput | null
  }

  export type activityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type inviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type praiseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rewardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type guestCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    user_name?: SortOrder
    avatar?: SortOrder
    verify_photo?: SortOrder
    verify?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    emailOTP?: SortOrder
  }

  export type guestMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    user_name?: SortOrder
    avatar?: SortOrder
    verify_photo?: SortOrder
    verify?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    emailOTP?: SortOrder
  }

  export type guestMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    user_name?: SortOrder
    avatar?: SortOrder
    verify_photo?: SortOrder
    verify?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    email?: SortOrder
    emailOTP?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type MessageNullableScalarRelationFilter = {
    is?: messageWhereInput | null
    isNot?: messageWhereInput | null
  }

  export type image_messageCountOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message_id?: SortOrder
  }

  export type image_messageMaxOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message_id?: SortOrder
  }

  export type image_messageMinOrderByAggregateInput = {
    id?: SortOrder
    image?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    message_id?: SortOrder
  }

  export type inviteCountOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    inviterId?: SortOrder
    invitedId?: SortOrder
  }

  export type inviteMaxOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    inviterId?: SortOrder
    invitedId?: SortOrder
  }

  export type inviteMinOrderByAggregateInput = {
    id?: SortOrder
    created_at?: SortOrder
    inviterId?: SortOrder
    invitedId?: SortOrder
  }

  export type Image_messageListRelationFilter = {
    every?: image_messageWhereInput
    some?: image_messageWhereInput
    none?: image_messageWhereInput
  }

  export type ChatroomNullableScalarRelationFilter = {
    is?: chatroomWhereInput | null
    isNot?: chatroomWhereInput | null
  }

  export type image_messageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messageCountOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sender_id?: SortOrder
    chatroom_id?: SortOrder
    is_read?: SortOrder
    order?: SortOrder
  }

  export type messageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type messageMaxOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sender_id?: SortOrder
    chatroom_id?: SortOrder
    is_read?: SortOrder
    order?: SortOrder
  }

  export type messageMinOrderByAggregateInput = {
    id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    sender_id?: SortOrder
    chatroom_id?: SortOrder
    is_read?: SortOrder
    order?: SortOrder
  }

  export type messageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
    name?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    timestamp?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ComboListRelationFilter = {
    every?: comboWhereInput
    some?: comboWhereInput
    none?: comboWhereInput
  }

  export type CommentListRelationFilter = {
    every?: commentWhereInput
    some?: commentWhereInput
    none?: commentWhereInput
  }

  export type Post_likeListRelationFilter = {
    every?: post_likeWhereInput
    some?: post_likeWhereInput
    none?: post_likeWhereInput
  }

  export type Report_postListRelationFilter = {
    every?: report_postWhereInput
    some?: report_postWhereInput
    none?: report_postWhereInput
  }

  export type comboOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type commentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type post_likeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type report_postOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type postCountOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type postMaxOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type postMinOrderByAggregateInput = {
    id?: SortOrder
    picture?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type post_likeCountOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type post_likeMaxOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type post_likeMinOrderByAggregateInput = {
    id?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type praiseCountOrderByAggregateInput = {
    id?: SortOrder
    is_like?: SortOrder
    user_id?: SortOrder
    guest_id?: SortOrder
    created_at?: SortOrder
  }

  export type praiseMaxOrderByAggregateInput = {
    id?: SortOrder
    is_like?: SortOrder
    user_id?: SortOrder
    guest_id?: SortOrder
    created_at?: SortOrder
  }

  export type praiseMinOrderByAggregateInput = {
    id?: SortOrder
    is_like?: SortOrder
    user_id?: SortOrder
    guest_id?: SortOrder
    created_at?: SortOrder
  }

  export type recycle_accountCountOrderByAggregateInput = {
    id?: SortOrder
    delete_time?: SortOrder
    user_id?: SortOrder
  }

  export type recycle_accountMaxOrderByAggregateInput = {
    id?: SortOrder
    delete_time?: SortOrder
    user_id?: SortOrder
  }

  export type recycle_accountMinOrderByAggregateInput = {
    id?: SortOrder
    delete_time?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type report_postCountOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type report_postMaxOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type report_postMinOrderByAggregateInput = {
    id?: SortOrder
    report_type?: SortOrder
    content?: SortOrder
    created_at?: SortOrder
    post_id?: SortOrder
    user_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type reset_passwordCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type reset_passwordMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type reset_passwordMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    expired_at?: SortOrder
    last_request_at?: SortOrder
  }

  export type rewardCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guest_id?: SortOrder
  }

  export type rewardAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type rewardMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guest_id?: SortOrder
  }

  export type rewardMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guest_id?: SortOrder
  }

  export type rewardSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type Block_userListRelationFilter = {
    every?: block_userWhereInput
    some?: block_userWhereInput
    none?: block_userWhereInput
  }

  export type FollowshipListRelationFilter = {
    every?: followshipWhereInput
    some?: followshipWhereInput
    none?: followshipWhereInput
  }

  export type PostListRelationFilter = {
    every?: postWhereInput
    some?: postWhereInput
    none?: postWhereInput
  }

  export type Recycle_accountNullableScalarRelationFilter = {
    is?: recycle_accountWhereInput | null
    isNot?: recycle_accountWhereInput | null
  }

  export type block_userOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type followshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type postOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    phone_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_name?: SortOrder
    introduction?: SortOrder
    guestId?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    phone_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_name?: SortOrder
    introduction?: SortOrder
    guestId?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    legal_name?: SortOrder
    phone_number?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_name?: SortOrder
    introduction?: SortOrder
    guestId?: SortOrder
  }

  export type warningCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guestId?: SortOrder
  }

  export type warningMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guestId?: SortOrder
  }

  export type warningMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    guestId?: SortOrder
  }

  export type guestCreateNestedOneWithoutActivity_activity_subscriberIdToguestInput = {
    create?: XOR<guestCreateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedCreateWithoutActivity_activity_subscriberIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutActivity_activity_subscriberIdToguestInput
    connect?: guestWhereUniqueInput
  }

  export type guestCreateNestedOneWithoutActivity_activity_guestIdToguestInput = {
    create?: XOR<guestCreateWithoutActivity_activity_guestIdToguestInput, guestUncheckedCreateWithoutActivity_activity_guestIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutActivity_activity_guestIdToguestInput
    connect?: guestWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type guestUpdateOneWithoutActivity_activity_subscriberIdToguestNestedInput = {
    create?: XOR<guestCreateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedCreateWithoutActivity_activity_subscriberIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutActivity_activity_subscriberIdToguestInput
    upsert?: guestUpsertWithoutActivity_activity_subscriberIdToguestInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutActivity_activity_subscriberIdToguestInput, guestUpdateWithoutActivity_activity_subscriberIdToguestInput>, guestUncheckedUpdateWithoutActivity_activity_subscriberIdToguestInput>
  }

  export type guestUpdateOneWithoutActivity_activity_guestIdToguestNestedInput = {
    create?: XOR<guestCreateWithoutActivity_activity_guestIdToguestInput, guestUncheckedCreateWithoutActivity_activity_guestIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutActivity_activity_guestIdToguestInput
    upsert?: guestUpsertWithoutActivity_activity_guestIdToguestInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutActivity_activity_guestIdToguestInput, guestUpdateWithoutActivity_activity_guestIdToguestInput>, guestUncheckedUpdateWithoutActivity_activity_guestIdToguestInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userCreateNestedOneWithoutBlock_user_block_user_blockerIdTouserInput = {
    create?: XOR<userCreateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutBlock_user_block_user_blockerIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutBlock_user_block_user_blockedIdTouserInput = {
    create?: XOR<userCreateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockedIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutBlock_user_block_user_blockedIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutBlock_user_block_user_blockerIdTouserNestedInput = {
    create?: XOR<userCreateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutBlock_user_block_user_blockerIdTouserInput
    upsert?: userUpsertWithoutBlock_user_block_user_blockerIdTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBlock_user_block_user_blockerIdTouserInput, userUpdateWithoutBlock_user_block_user_blockerIdTouserInput>, userUncheckedUpdateWithoutBlock_user_block_user_blockerIdTouserInput>
  }

  export type userUpdateOneWithoutBlock_user_block_user_blockedIdTouserNestedInput = {
    create?: XOR<userCreateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockedIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutBlock_user_block_user_blockedIdTouserInput
    upsert?: userUpsertWithoutBlock_user_block_user_blockedIdTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutBlock_user_block_user_blockedIdTouserInput, userUpdateWithoutBlock_user_block_user_blockedIdTouserInput>, userUncheckedUpdateWithoutBlock_user_block_user_blockedIdTouserInput>
  }

  export type chatroom_memberCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput> | chatroom_memberCreateWithoutChatroomInput[] | chatroom_memberUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutChatroomInput | chatroom_memberCreateOrConnectWithoutChatroomInput[]
    createMany?: chatroom_memberCreateManyChatroomInputEnvelope
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutChatroomInput = {
    create?: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput> | messageCreateWithoutChatroomInput[] | messageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutChatroomInput | messageCreateOrConnectWithoutChatroomInput[]
    createMany?: messageCreateManyChatroomInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type chatroom_memberUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput> | chatroom_memberCreateWithoutChatroomInput[] | chatroom_memberUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutChatroomInput | chatroom_memberCreateOrConnectWithoutChatroomInput[]
    createMany?: chatroom_memberCreateManyChatroomInputEnvelope
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutChatroomInput = {
    create?: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput> | messageCreateWithoutChatroomInput[] | messageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutChatroomInput | messageCreateOrConnectWithoutChatroomInput[]
    createMany?: messageCreateManyChatroomInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type chatroom_memberUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput> | chatroom_memberCreateWithoutChatroomInput[] | chatroom_memberUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutChatroomInput | chatroom_memberCreateOrConnectWithoutChatroomInput[]
    upsert?: chatroom_memberUpsertWithWhereUniqueWithoutChatroomInput | chatroom_memberUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatroom_memberCreateManyChatroomInputEnvelope
    set?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    disconnect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    delete?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    update?: chatroom_memberUpdateWithWhereUniqueWithoutChatroomInput | chatroom_memberUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatroom_memberUpdateManyWithWhereWithoutChatroomInput | chatroom_memberUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
  }

  export type messageUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput> | messageCreateWithoutChatroomInput[] | messageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutChatroomInput | messageCreateOrConnectWithoutChatroomInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutChatroomInput | messageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: messageCreateManyChatroomInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutChatroomInput | messageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: messageUpdateManyWithWhereWithoutChatroomInput | messageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type chatroom_memberUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput> | chatroom_memberCreateWithoutChatroomInput[] | chatroom_memberUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutChatroomInput | chatroom_memberCreateOrConnectWithoutChatroomInput[]
    upsert?: chatroom_memberUpsertWithWhereUniqueWithoutChatroomInput | chatroom_memberUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: chatroom_memberCreateManyChatroomInputEnvelope
    set?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    disconnect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    delete?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    update?: chatroom_memberUpdateWithWhereUniqueWithoutChatroomInput | chatroom_memberUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: chatroom_memberUpdateManyWithWhereWithoutChatroomInput | chatroom_memberUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutChatroomNestedInput = {
    create?: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput> | messageCreateWithoutChatroomInput[] | messageUncheckedCreateWithoutChatroomInput[]
    connectOrCreate?: messageCreateOrConnectWithoutChatroomInput | messageCreateOrConnectWithoutChatroomInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutChatroomInput | messageUpsertWithWhereUniqueWithoutChatroomInput[]
    createMany?: messageCreateManyChatroomInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutChatroomInput | messageUpdateWithWhereUniqueWithoutChatroomInput[]
    updateMany?: messageUpdateManyWithWhereWithoutChatroomInput | messageUpdateManyWithWhereWithoutChatroomInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type chatroomCreateNestedOneWithoutChatroom_memberInput = {
    create?: XOR<chatroomCreateWithoutChatroom_memberInput, chatroomUncheckedCreateWithoutChatroom_memberInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatroom_memberInput
    connect?: chatroomWhereUniqueInput
  }

  export type userCreateNestedOneWithoutChatroom_memberInput = {
    create?: XOR<userCreateWithoutChatroom_memberInput, userUncheckedCreateWithoutChatroom_memberInput>
    connectOrCreate?: userCreateOrConnectWithoutChatroom_memberInput
    connect?: userWhereUniqueInput
  }

  export type chatroomUpdateOneRequiredWithoutChatroom_memberNestedInput = {
    create?: XOR<chatroomCreateWithoutChatroom_memberInput, chatroomUncheckedCreateWithoutChatroom_memberInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutChatroom_memberInput
    upsert?: chatroomUpsertWithoutChatroom_memberInput
    connect?: chatroomWhereUniqueInput
    update?: XOR<XOR<chatroomUpdateToOneWithWhereWithoutChatroom_memberInput, chatroomUpdateWithoutChatroom_memberInput>, chatroomUncheckedUpdateWithoutChatroom_memberInput>
  }

  export type userUpdateOneRequiredWithoutChatroom_memberNestedInput = {
    create?: XOR<userCreateWithoutChatroom_memberInput, userUncheckedCreateWithoutChatroom_memberInput>
    connectOrCreate?: userCreateOrConnectWithoutChatroom_memberInput
    upsert?: userUpsertWithoutChatroom_memberInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutChatroom_memberInput, userUpdateWithoutChatroom_memberInput>, userUncheckedUpdateWithoutChatroom_memberInput>
  }

  export type postCreateNestedOneWithoutComboInput = {
    create?: XOR<postCreateWithoutComboInput, postUncheckedCreateWithoutComboInput>
    connectOrCreate?: postCreateOrConnectWithoutComboInput
    connect?: postWhereUniqueInput
  }

  export type userCreateNestedOneWithoutComboInput = {
    create?: XOR<userCreateWithoutComboInput, userUncheckedCreateWithoutComboInput>
    connectOrCreate?: userCreateOrConnectWithoutComboInput
    connect?: userWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type postUpdateOneRequiredWithoutComboNestedInput = {
    create?: XOR<postCreateWithoutComboInput, postUncheckedCreateWithoutComboInput>
    connectOrCreate?: postCreateOrConnectWithoutComboInput
    upsert?: postUpsertWithoutComboInput
    connect?: postWhereUniqueInput
    update?: XOR<XOR<postUpdateToOneWithWhereWithoutComboInput, postUpdateWithoutComboInput>, postUncheckedUpdateWithoutComboInput>
  }

  export type userUpdateOneRequiredWithoutComboNestedInput = {
    create?: XOR<userCreateWithoutComboInput, userUncheckedCreateWithoutComboInput>
    connectOrCreate?: userCreateOrConnectWithoutComboInput
    upsert?: userUpsertWithoutComboInput
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutComboInput, userUpdateWithoutComboInput>, userUncheckedUpdateWithoutComboInput>
  }

  export type postCreateNestedOneWithoutCommentInput = {
    create?: XOR<postCreateWithoutCommentInput, postUncheckedCreateWithoutCommentInput>
    connectOrCreate?: postCreateOrConnectWithoutCommentInput
    connect?: postWhereUniqueInput
  }

  export type userCreateNestedOneWithoutCommentInput = {
    create?: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    connectOrCreate?: userCreateOrConnectWithoutCommentInput
    connect?: userWhereUniqueInput
  }

  export type postUpdateOneWithoutCommentNestedInput = {
    create?: XOR<postCreateWithoutCommentInput, postUncheckedCreateWithoutCommentInput>
    connectOrCreate?: postCreateOrConnectWithoutCommentInput
    upsert?: postUpsertWithoutCommentInput
    disconnect?: postWhereInput | boolean
    delete?: postWhereInput | boolean
    connect?: postWhereUniqueInput
    update?: XOR<XOR<postUpdateToOneWithWhereWithoutCommentInput, postUpdateWithoutCommentInput>, postUncheckedUpdateWithoutCommentInput>
  }

  export type userUpdateOneWithoutCommentNestedInput = {
    create?: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    connectOrCreate?: userCreateOrConnectWithoutCommentInput
    upsert?: userUpsertWithoutCommentInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutCommentInput, userUpdateWithoutCommentInput>, userUncheckedUpdateWithoutCommentInput>
  }

  export type userCreateNestedOneWithoutFollowship_followship_followerIdTouserInput = {
    create?: XOR<userCreateWithoutFollowship_followship_followerIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFollowship_followship_followerIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFollowship_followship_followedIdTouserInput = {
    create?: XOR<userCreateWithoutFollowship_followship_followedIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followedIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFollowship_followship_followedIdTouserInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutFollowship_followship_followerIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFollowship_followship_followerIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followerIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFollowship_followship_followerIdTouserInput
    upsert?: userUpsertWithoutFollowship_followship_followerIdTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFollowship_followship_followerIdTouserInput, userUpdateWithoutFollowship_followship_followerIdTouserInput>, userUncheckedUpdateWithoutFollowship_followship_followerIdTouserInput>
  }

  export type userUpdateOneWithoutFollowship_followship_followedIdTouserNestedInput = {
    create?: XOR<userCreateWithoutFollowship_followship_followedIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followedIdTouserInput>
    connectOrCreate?: userCreateOrConnectWithoutFollowship_followship_followedIdTouserInput
    upsert?: userUpsertWithoutFollowship_followship_followedIdTouserInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutFollowship_followship_followedIdTouserInput, userUpdateWithoutFollowship_followship_followedIdTouserInput>, userUncheckedUpdateWithoutFollowship_followship_followedIdTouserInput>
  }

  export type activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput = {
    create?: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput> | activityCreateWithoutGuest_activity_subscriberIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput | activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_subscriberIdToguestInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput = {
    create?: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput> | activityCreateWithoutGuest_activity_guestIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput | activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_guestIdToguestInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_invitedIdToguestInput
    connect?: inviteWhereUniqueInput
  }

  export type inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput> | inviteCreateWithoutGuest_invite_inviterIdToguestInput[] | inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput[]
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput | inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput[]
    createMany?: inviteCreateManyGuest_invite_inviterIdToguestInputEnvelope
    connect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
  }

  export type praiseCreateNestedManyWithoutGuestInput = {
    create?: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput> | praiseCreateWithoutGuestInput[] | praiseUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutGuestInput | praiseCreateOrConnectWithoutGuestInput[]
    createMany?: praiseCreateManyGuestInputEnvelope
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
  }

  export type rewardCreateNestedManyWithoutGuestInput = {
    create?: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput> | rewardCreateWithoutGuestInput[] | rewardUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: rewardCreateOrConnectWithoutGuestInput | rewardCreateOrConnectWithoutGuestInput[]
    createMany?: rewardCreateManyGuestInputEnvelope
    connect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutGuestInput = {
    create?: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
    connectOrCreate?: userCreateOrConnectWithoutGuestInput
    connect?: userWhereUniqueInput
  }

  export type warningCreateNestedOneWithoutGuestInput = {
    create?: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
    connectOrCreate?: warningCreateOrConnectWithoutGuestInput
    connect?: warningWhereUniqueInput
  }

  export type activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput = {
    create?: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput> | activityCreateWithoutGuest_activity_subscriberIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput | activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_subscriberIdToguestInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput = {
    create?: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput> | activityCreateWithoutGuest_activity_guestIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput | activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_guestIdToguestInputEnvelope
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
  }

  export type inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_invitedIdToguestInput
    connect?: inviteWhereUniqueInput
  }

  export type inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput> | inviteCreateWithoutGuest_invite_inviterIdToguestInput[] | inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput[]
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput | inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput[]
    createMany?: inviteCreateManyGuest_invite_inviterIdToguestInputEnvelope
    connect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
  }

  export type praiseUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput> | praiseCreateWithoutGuestInput[] | praiseUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutGuestInput | praiseCreateOrConnectWithoutGuestInput[]
    createMany?: praiseCreateManyGuestInputEnvelope
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
  }

  export type rewardUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput> | rewardCreateWithoutGuestInput[] | rewardUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: rewardCreateOrConnectWithoutGuestInput | rewardCreateOrConnectWithoutGuestInput[]
    createMany?: rewardCreateManyGuestInputEnvelope
    connect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
  }

  export type userUncheckedCreateNestedOneWithoutGuestInput = {
    create?: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
    connectOrCreate?: userCreateOrConnectWithoutGuestInput
    connect?: userWhereUniqueInput
  }

  export type warningUncheckedCreateNestedOneWithoutGuestInput = {
    create?: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
    connectOrCreate?: warningCreateOrConnectWithoutGuestInput
    connect?: warningWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput = {
    create?: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput> | activityCreateWithoutGuest_activity_subscriberIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput | activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput | activityUpsertWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_subscriberIdToguestInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput | activityUpdateWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput[]
    updateMany?: activityUpdateManyWithWhereWithoutGuest_activity_subscriberIdToguestInput | activityUpdateManyWithWhereWithoutGuest_activity_subscriberIdToguestInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput = {
    create?: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput> | activityCreateWithoutGuest_activity_guestIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput | activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutGuest_activity_guestIdToguestInput | activityUpsertWithWhereUniqueWithoutGuest_activity_guestIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_guestIdToguestInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutGuest_activity_guestIdToguestInput | activityUpdateWithWhereUniqueWithoutGuest_activity_guestIdToguestInput[]
    updateMany?: activityUpdateManyWithWhereWithoutGuest_activity_guestIdToguestInput | activityUpdateManyWithWhereWithoutGuest_activity_guestIdToguestInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_invitedIdToguestInput
    upsert?: inviteUpsertWithoutGuest_invite_invitedIdToguestInput
    disconnect?: inviteWhereInput | boolean
    delete?: inviteWhereInput | boolean
    connect?: inviteWhereUniqueInput
    update?: XOR<XOR<inviteUpdateToOneWithWhereWithoutGuest_invite_invitedIdToguestInput, inviteUpdateWithoutGuest_invite_invitedIdToguestInput>, inviteUncheckedUpdateWithoutGuest_invite_invitedIdToguestInput>
  }

  export type inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput> | inviteCreateWithoutGuest_invite_inviterIdToguestInput[] | inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput[]
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput | inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput[]
    upsert?: inviteUpsertWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput | inviteUpsertWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput[]
    createMany?: inviteCreateManyGuest_invite_inviterIdToguestInputEnvelope
    set?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    disconnect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    delete?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    connect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    update?: inviteUpdateWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput | inviteUpdateWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput[]
    updateMany?: inviteUpdateManyWithWhereWithoutGuest_invite_inviterIdToguestInput | inviteUpdateManyWithWhereWithoutGuest_invite_inviterIdToguestInput[]
    deleteMany?: inviteScalarWhereInput | inviteScalarWhereInput[]
  }

  export type praiseUpdateManyWithoutGuestNestedInput = {
    create?: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput> | praiseCreateWithoutGuestInput[] | praiseUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutGuestInput | praiseCreateOrConnectWithoutGuestInput[]
    upsert?: praiseUpsertWithWhereUniqueWithoutGuestInput | praiseUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: praiseCreateManyGuestInputEnvelope
    set?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    disconnect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    delete?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    update?: praiseUpdateWithWhereUniqueWithoutGuestInput | praiseUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: praiseUpdateManyWithWhereWithoutGuestInput | praiseUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: praiseScalarWhereInput | praiseScalarWhereInput[]
  }

  export type rewardUpdateManyWithoutGuestNestedInput = {
    create?: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput> | rewardCreateWithoutGuestInput[] | rewardUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: rewardCreateOrConnectWithoutGuestInput | rewardCreateOrConnectWithoutGuestInput[]
    upsert?: rewardUpsertWithWhereUniqueWithoutGuestInput | rewardUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: rewardCreateManyGuestInputEnvelope
    set?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    disconnect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    delete?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    connect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    update?: rewardUpdateWithWhereUniqueWithoutGuestInput | rewardUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: rewardUpdateManyWithWhereWithoutGuestInput | rewardUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: rewardScalarWhereInput | rewardScalarWhereInput[]
  }

  export type userUpdateOneWithoutGuestNestedInput = {
    create?: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
    connectOrCreate?: userCreateOrConnectWithoutGuestInput
    upsert?: userUpsertWithoutGuestInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGuestInput, userUpdateWithoutGuestInput>, userUncheckedUpdateWithoutGuestInput>
  }

  export type warningUpdateOneWithoutGuestNestedInput = {
    create?: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
    connectOrCreate?: warningCreateOrConnectWithoutGuestInput
    upsert?: warningUpsertWithoutGuestInput
    disconnect?: warningWhereInput | boolean
    delete?: warningWhereInput | boolean
    connect?: warningWhereUniqueInput
    update?: XOR<XOR<warningUpdateToOneWithWhereWithoutGuestInput, warningUpdateWithoutGuestInput>, warningUncheckedUpdateWithoutGuestInput>
  }

  export type activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput = {
    create?: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput> | activityCreateWithoutGuest_activity_subscriberIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput | activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput | activityUpsertWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_subscriberIdToguestInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput | activityUpdateWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput[]
    updateMany?: activityUpdateManyWithWhereWithoutGuest_activity_subscriberIdToguestInput | activityUpdateManyWithWhereWithoutGuest_activity_subscriberIdToguestInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput = {
    create?: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput> | activityCreateWithoutGuest_activity_guestIdToguestInput[] | activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput[]
    connectOrCreate?: activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput | activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput[]
    upsert?: activityUpsertWithWhereUniqueWithoutGuest_activity_guestIdToguestInput | activityUpsertWithWhereUniqueWithoutGuest_activity_guestIdToguestInput[]
    createMany?: activityCreateManyGuest_activity_guestIdToguestInputEnvelope
    set?: activityWhereUniqueInput | activityWhereUniqueInput[]
    disconnect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    delete?: activityWhereUniqueInput | activityWhereUniqueInput[]
    connect?: activityWhereUniqueInput | activityWhereUniqueInput[]
    update?: activityUpdateWithWhereUniqueWithoutGuest_activity_guestIdToguestInput | activityUpdateWithWhereUniqueWithoutGuest_activity_guestIdToguestInput[]
    updateMany?: activityUpdateManyWithWhereWithoutGuest_activity_guestIdToguestInput | activityUpdateManyWithWhereWithoutGuest_activity_guestIdToguestInput[]
    deleteMany?: activityScalarWhereInput | activityScalarWhereInput[]
  }

  export type inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_invitedIdToguestInput
    upsert?: inviteUpsertWithoutGuest_invite_invitedIdToguestInput
    disconnect?: inviteWhereInput | boolean
    delete?: inviteWhereInput | boolean
    connect?: inviteWhereUniqueInput
    update?: XOR<XOR<inviteUpdateToOneWithWhereWithoutGuest_invite_invitedIdToguestInput, inviteUpdateWithoutGuest_invite_invitedIdToguestInput>, inviteUncheckedUpdateWithoutGuest_invite_invitedIdToguestInput>
  }

  export type inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput = {
    create?: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput> | inviteCreateWithoutGuest_invite_inviterIdToguestInput[] | inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput[]
    connectOrCreate?: inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput | inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput[]
    upsert?: inviteUpsertWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput | inviteUpsertWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput[]
    createMany?: inviteCreateManyGuest_invite_inviterIdToguestInputEnvelope
    set?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    disconnect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    delete?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    connect?: inviteWhereUniqueInput | inviteWhereUniqueInput[]
    update?: inviteUpdateWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput | inviteUpdateWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput[]
    updateMany?: inviteUpdateManyWithWhereWithoutGuest_invite_inviterIdToguestInput | inviteUpdateManyWithWhereWithoutGuest_invite_inviterIdToguestInput[]
    deleteMany?: inviteScalarWhereInput | inviteScalarWhereInput[]
  }

  export type praiseUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput> | praiseCreateWithoutGuestInput[] | praiseUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutGuestInput | praiseCreateOrConnectWithoutGuestInput[]
    upsert?: praiseUpsertWithWhereUniqueWithoutGuestInput | praiseUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: praiseCreateManyGuestInputEnvelope
    set?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    disconnect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    delete?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    update?: praiseUpdateWithWhereUniqueWithoutGuestInput | praiseUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: praiseUpdateManyWithWhereWithoutGuestInput | praiseUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: praiseScalarWhereInput | praiseScalarWhereInput[]
  }

  export type rewardUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput> | rewardCreateWithoutGuestInput[] | rewardUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: rewardCreateOrConnectWithoutGuestInput | rewardCreateOrConnectWithoutGuestInput[]
    upsert?: rewardUpsertWithWhereUniqueWithoutGuestInput | rewardUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: rewardCreateManyGuestInputEnvelope
    set?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    disconnect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    delete?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    connect?: rewardWhereUniqueInput | rewardWhereUniqueInput[]
    update?: rewardUpdateWithWhereUniqueWithoutGuestInput | rewardUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: rewardUpdateManyWithWhereWithoutGuestInput | rewardUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: rewardScalarWhereInput | rewardScalarWhereInput[]
  }

  export type userUncheckedUpdateOneWithoutGuestNestedInput = {
    create?: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
    connectOrCreate?: userCreateOrConnectWithoutGuestInput
    upsert?: userUpsertWithoutGuestInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutGuestInput, userUpdateWithoutGuestInput>, userUncheckedUpdateWithoutGuestInput>
  }

  export type warningUncheckedUpdateOneWithoutGuestNestedInput = {
    create?: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
    connectOrCreate?: warningCreateOrConnectWithoutGuestInput
    upsert?: warningUpsertWithoutGuestInput
    disconnect?: warningWhereInput | boolean
    delete?: warningWhereInput | boolean
    connect?: warningWhereUniqueInput
    update?: XOR<XOR<warningUpdateToOneWithWhereWithoutGuestInput, warningUpdateWithoutGuestInput>, warningUncheckedUpdateWithoutGuestInput>
  }

  export type messageCreateNestedOneWithoutImage_messageInput = {
    create?: XOR<messageCreateWithoutImage_messageInput, messageUncheckedCreateWithoutImage_messageInput>
    connectOrCreate?: messageCreateOrConnectWithoutImage_messageInput
    connect?: messageWhereUniqueInput
  }

  export type messageUpdateOneWithoutImage_messageNestedInput = {
    create?: XOR<messageCreateWithoutImage_messageInput, messageUncheckedCreateWithoutImage_messageInput>
    connectOrCreate?: messageCreateOrConnectWithoutImage_messageInput
    upsert?: messageUpsertWithoutImage_messageInput
    disconnect?: messageWhereInput | boolean
    delete?: messageWhereInput | boolean
    connect?: messageWhereUniqueInput
    update?: XOR<XOR<messageUpdateToOneWithWhereWithoutImage_messageInput, messageUpdateWithoutImage_messageInput>, messageUncheckedUpdateWithoutImage_messageInput>
  }

  export type guestCreateNestedOneWithoutInvite_invite_invitedIdToguestInput = {
    create?: XOR<guestCreateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedCreateWithoutInvite_invite_invitedIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutInvite_invite_invitedIdToguestInput
    connect?: guestWhereUniqueInput
  }

  export type guestCreateNestedOneWithoutInvite_invite_inviterIdToguestInput = {
    create?: XOR<guestCreateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedCreateWithoutInvite_invite_inviterIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutInvite_invite_inviterIdToguestInput
    connect?: guestWhereUniqueInput
  }

  export type guestUpdateOneWithoutInvite_invite_invitedIdToguestNestedInput = {
    create?: XOR<guestCreateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedCreateWithoutInvite_invite_invitedIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutInvite_invite_invitedIdToguestInput
    upsert?: guestUpsertWithoutInvite_invite_invitedIdToguestInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutInvite_invite_invitedIdToguestInput, guestUpdateWithoutInvite_invite_invitedIdToguestInput>, guestUncheckedUpdateWithoutInvite_invite_invitedIdToguestInput>
  }

  export type guestUpdateOneWithoutInvite_invite_inviterIdToguestNestedInput = {
    create?: XOR<guestCreateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedCreateWithoutInvite_invite_inviterIdToguestInput>
    connectOrCreate?: guestCreateOrConnectWithoutInvite_invite_inviterIdToguestInput
    upsert?: guestUpsertWithoutInvite_invite_inviterIdToguestInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutInvite_invite_inviterIdToguestInput, guestUpdateWithoutInvite_invite_inviterIdToguestInput>, guestUncheckedUpdateWithoutInvite_invite_inviterIdToguestInput>
  }

  export type image_messageCreateNestedManyWithoutMessageInput = {
    create?: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput> | image_messageCreateWithoutMessageInput[] | image_messageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: image_messageCreateOrConnectWithoutMessageInput | image_messageCreateOrConnectWithoutMessageInput[]
    createMany?: image_messageCreateManyMessageInputEnvelope
    connect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
  }

  export type chatroomCreateNestedOneWithoutMessageInput = {
    create?: XOR<chatroomCreateWithoutMessageInput, chatroomUncheckedCreateWithoutMessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutMessageInput
    connect?: chatroomWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMessageInput = {
    create?: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutMessageInput
    connect?: userWhereUniqueInput
  }

  export type image_messageUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput> | image_messageCreateWithoutMessageInput[] | image_messageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: image_messageCreateOrConnectWithoutMessageInput | image_messageCreateOrConnectWithoutMessageInput[]
    createMany?: image_messageCreateManyMessageInputEnvelope
    connect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
  }

  export type image_messageUpdateManyWithoutMessageNestedInput = {
    create?: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput> | image_messageCreateWithoutMessageInput[] | image_messageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: image_messageCreateOrConnectWithoutMessageInput | image_messageCreateOrConnectWithoutMessageInput[]
    upsert?: image_messageUpsertWithWhereUniqueWithoutMessageInput | image_messageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: image_messageCreateManyMessageInputEnvelope
    set?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    disconnect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    delete?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    connect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    update?: image_messageUpdateWithWhereUniqueWithoutMessageInput | image_messageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: image_messageUpdateManyWithWhereWithoutMessageInput | image_messageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: image_messageScalarWhereInput | image_messageScalarWhereInput[]
  }

  export type chatroomUpdateOneWithoutMessageNestedInput = {
    create?: XOR<chatroomCreateWithoutMessageInput, chatroomUncheckedCreateWithoutMessageInput>
    connectOrCreate?: chatroomCreateOrConnectWithoutMessageInput
    upsert?: chatroomUpsertWithoutMessageInput
    disconnect?: chatroomWhereInput | boolean
    delete?: chatroomWhereInput | boolean
    connect?: chatroomWhereUniqueInput
    update?: XOR<XOR<chatroomUpdateToOneWithWhereWithoutMessageInput, chatroomUpdateWithoutMessageInput>, chatroomUncheckedUpdateWithoutMessageInput>
  }

  export type userUpdateOneWithoutMessageNestedInput = {
    create?: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    connectOrCreate?: userCreateOrConnectWithoutMessageInput
    upsert?: userUpsertWithoutMessageInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutMessageInput, userUpdateWithoutMessageInput>, userUncheckedUpdateWithoutMessageInput>
  }

  export type image_messageUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput> | image_messageCreateWithoutMessageInput[] | image_messageUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: image_messageCreateOrConnectWithoutMessageInput | image_messageCreateOrConnectWithoutMessageInput[]
    upsert?: image_messageUpsertWithWhereUniqueWithoutMessageInput | image_messageUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: image_messageCreateManyMessageInputEnvelope
    set?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    disconnect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    delete?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    connect?: image_messageWhereUniqueInput | image_messageWhereUniqueInput[]
    update?: image_messageUpdateWithWhereUniqueWithoutMessageInput | image_messageUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: image_messageUpdateManyWithWhereWithoutMessageInput | image_messageUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: image_messageScalarWhereInput | image_messageScalarWhereInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type comboCreateNestedManyWithoutPostInput = {
    create?: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput> | comboCreateWithoutPostInput[] | comboUncheckedCreateWithoutPostInput[]
    connectOrCreate?: comboCreateOrConnectWithoutPostInput | comboCreateOrConnectWithoutPostInput[]
    createMany?: comboCreateManyPostInputEnvelope
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
  }

  export type commentCreateNestedManyWithoutPostInput = {
    create?: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput> | commentCreateWithoutPostInput[] | commentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPostInput | commentCreateOrConnectWithoutPostInput[]
    createMany?: commentCreateManyPostInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type userCreateNestedOneWithoutPostInput = {
    create?: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    connectOrCreate?: userCreateOrConnectWithoutPostInput
    connect?: userWhereUniqueInput
  }

  export type post_likeCreateNestedManyWithoutPostInput = {
    create?: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput> | post_likeCreateWithoutPostInput[] | post_likeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutPostInput | post_likeCreateOrConnectWithoutPostInput[]
    createMany?: post_likeCreateManyPostInputEnvelope
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
  }

  export type report_postCreateNestedManyWithoutPostInput = {
    create?: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput> | report_postCreateWithoutPostInput[] | report_postUncheckedCreateWithoutPostInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutPostInput | report_postCreateOrConnectWithoutPostInput[]
    createMany?: report_postCreateManyPostInputEnvelope
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
  }

  export type comboUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput> | comboCreateWithoutPostInput[] | comboUncheckedCreateWithoutPostInput[]
    connectOrCreate?: comboCreateOrConnectWithoutPostInput | comboCreateOrConnectWithoutPostInput[]
    createMany?: comboCreateManyPostInputEnvelope
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput> | commentCreateWithoutPostInput[] | commentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPostInput | commentCreateOrConnectWithoutPostInput[]
    createMany?: commentCreateManyPostInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type post_likeUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput> | post_likeCreateWithoutPostInput[] | post_likeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutPostInput | post_likeCreateOrConnectWithoutPostInput[]
    createMany?: post_likeCreateManyPostInputEnvelope
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
  }

  export type report_postUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput> | report_postCreateWithoutPostInput[] | report_postUncheckedCreateWithoutPostInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutPostInput | report_postCreateOrConnectWithoutPostInput[]
    createMany?: report_postCreateManyPostInputEnvelope
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
  }

  export type comboUpdateManyWithoutPostNestedInput = {
    create?: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput> | comboCreateWithoutPostInput[] | comboUncheckedCreateWithoutPostInput[]
    connectOrCreate?: comboCreateOrConnectWithoutPostInput | comboCreateOrConnectWithoutPostInput[]
    upsert?: comboUpsertWithWhereUniqueWithoutPostInput | comboUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: comboCreateManyPostInputEnvelope
    set?: comboWhereUniqueInput | comboWhereUniqueInput[]
    disconnect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    delete?: comboWhereUniqueInput | comboWhereUniqueInput[]
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    update?: comboUpdateWithWhereUniqueWithoutPostInput | comboUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: comboUpdateManyWithWhereWithoutPostInput | comboUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: comboScalarWhereInput | comboScalarWhereInput[]
  }

  export type commentUpdateManyWithoutPostNestedInput = {
    create?: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput> | commentCreateWithoutPostInput[] | commentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPostInput | commentCreateOrConnectWithoutPostInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutPostInput | commentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: commentCreateManyPostInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutPostInput | commentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: commentUpdateManyWithWhereWithoutPostInput | commentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type userUpdateOneWithoutPostNestedInput = {
    create?: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    connectOrCreate?: userCreateOrConnectWithoutPostInput
    upsert?: userUpsertWithoutPostInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPostInput, userUpdateWithoutPostInput>, userUncheckedUpdateWithoutPostInput>
  }

  export type post_likeUpdateManyWithoutPostNestedInput = {
    create?: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput> | post_likeCreateWithoutPostInput[] | post_likeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutPostInput | post_likeCreateOrConnectWithoutPostInput[]
    upsert?: post_likeUpsertWithWhereUniqueWithoutPostInput | post_likeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: post_likeCreateManyPostInputEnvelope
    set?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    disconnect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    delete?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    update?: post_likeUpdateWithWhereUniqueWithoutPostInput | post_likeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: post_likeUpdateManyWithWhereWithoutPostInput | post_likeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
  }

  export type report_postUpdateManyWithoutPostNestedInput = {
    create?: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput> | report_postCreateWithoutPostInput[] | report_postUncheckedCreateWithoutPostInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutPostInput | report_postCreateOrConnectWithoutPostInput[]
    upsert?: report_postUpsertWithWhereUniqueWithoutPostInput | report_postUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: report_postCreateManyPostInputEnvelope
    set?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    disconnect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    delete?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    update?: report_postUpdateWithWhereUniqueWithoutPostInput | report_postUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: report_postUpdateManyWithWhereWithoutPostInput | report_postUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: report_postScalarWhereInput | report_postScalarWhereInput[]
  }

  export type comboUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput> | comboCreateWithoutPostInput[] | comboUncheckedCreateWithoutPostInput[]
    connectOrCreate?: comboCreateOrConnectWithoutPostInput | comboCreateOrConnectWithoutPostInput[]
    upsert?: comboUpsertWithWhereUniqueWithoutPostInput | comboUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: comboCreateManyPostInputEnvelope
    set?: comboWhereUniqueInput | comboWhereUniqueInput[]
    disconnect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    delete?: comboWhereUniqueInput | comboWhereUniqueInput[]
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    update?: comboUpdateWithWhereUniqueWithoutPostInput | comboUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: comboUpdateManyWithWhereWithoutPostInput | comboUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: comboScalarWhereInput | comboScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput> | commentCreateWithoutPostInput[] | commentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: commentCreateOrConnectWithoutPostInput | commentCreateOrConnectWithoutPostInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutPostInput | commentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: commentCreateManyPostInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutPostInput | commentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: commentUpdateManyWithWhereWithoutPostInput | commentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type post_likeUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput> | post_likeCreateWithoutPostInput[] | post_likeUncheckedCreateWithoutPostInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutPostInput | post_likeCreateOrConnectWithoutPostInput[]
    upsert?: post_likeUpsertWithWhereUniqueWithoutPostInput | post_likeUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: post_likeCreateManyPostInputEnvelope
    set?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    disconnect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    delete?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    update?: post_likeUpdateWithWhereUniqueWithoutPostInput | post_likeUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: post_likeUpdateManyWithWhereWithoutPostInput | post_likeUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
  }

  export type report_postUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput> | report_postCreateWithoutPostInput[] | report_postUncheckedCreateWithoutPostInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutPostInput | report_postCreateOrConnectWithoutPostInput[]
    upsert?: report_postUpsertWithWhereUniqueWithoutPostInput | report_postUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: report_postCreateManyPostInputEnvelope
    set?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    disconnect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    delete?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    update?: report_postUpdateWithWhereUniqueWithoutPostInput | report_postUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: report_postUpdateManyWithWhereWithoutPostInput | report_postUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: report_postScalarWhereInput | report_postScalarWhereInput[]
  }

  export type postCreateNestedOneWithoutPost_likeInput = {
    create?: XOR<postCreateWithoutPost_likeInput, postUncheckedCreateWithoutPost_likeInput>
    connectOrCreate?: postCreateOrConnectWithoutPost_likeInput
    connect?: postWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPost_likeInput = {
    create?: XOR<userCreateWithoutPost_likeInput, userUncheckedCreateWithoutPost_likeInput>
    connectOrCreate?: userCreateOrConnectWithoutPost_likeInput
    connect?: userWhereUniqueInput
  }

  export type postUpdateOneWithoutPost_likeNestedInput = {
    create?: XOR<postCreateWithoutPost_likeInput, postUncheckedCreateWithoutPost_likeInput>
    connectOrCreate?: postCreateOrConnectWithoutPost_likeInput
    upsert?: postUpsertWithoutPost_likeInput
    disconnect?: postWhereInput | boolean
    delete?: postWhereInput | boolean
    connect?: postWhereUniqueInput
    update?: XOR<XOR<postUpdateToOneWithWhereWithoutPost_likeInput, postUpdateWithoutPost_likeInput>, postUncheckedUpdateWithoutPost_likeInput>
  }

  export type userUpdateOneWithoutPost_likeNestedInput = {
    create?: XOR<userCreateWithoutPost_likeInput, userUncheckedCreateWithoutPost_likeInput>
    connectOrCreate?: userCreateOrConnectWithoutPost_likeInput
    upsert?: userUpsertWithoutPost_likeInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPost_likeInput, userUpdateWithoutPost_likeInput>, userUncheckedUpdateWithoutPost_likeInput>
  }

  export type guestCreateNestedOneWithoutPraiseInput = {
    create?: XOR<guestCreateWithoutPraiseInput, guestUncheckedCreateWithoutPraiseInput>
    connectOrCreate?: guestCreateOrConnectWithoutPraiseInput
    connect?: guestWhereUniqueInput
  }

  export type userCreateNestedOneWithoutPraiseInput = {
    create?: XOR<userCreateWithoutPraiseInput, userUncheckedCreateWithoutPraiseInput>
    connectOrCreate?: userCreateOrConnectWithoutPraiseInput
    connect?: userWhereUniqueInput
  }

  export type guestUpdateOneWithoutPraiseNestedInput = {
    create?: XOR<guestCreateWithoutPraiseInput, guestUncheckedCreateWithoutPraiseInput>
    connectOrCreate?: guestCreateOrConnectWithoutPraiseInput
    upsert?: guestUpsertWithoutPraiseInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutPraiseInput, guestUpdateWithoutPraiseInput>, guestUncheckedUpdateWithoutPraiseInput>
  }

  export type userUpdateOneWithoutPraiseNestedInput = {
    create?: XOR<userCreateWithoutPraiseInput, userUncheckedCreateWithoutPraiseInput>
    connectOrCreate?: userCreateOrConnectWithoutPraiseInput
    upsert?: userUpsertWithoutPraiseInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutPraiseInput, userUpdateWithoutPraiseInput>, userUncheckedUpdateWithoutPraiseInput>
  }

  export type userCreateNestedOneWithoutRecycle_accountInput = {
    create?: XOR<userCreateWithoutRecycle_accountInput, userUncheckedCreateWithoutRecycle_accountInput>
    connectOrCreate?: userCreateOrConnectWithoutRecycle_accountInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneWithoutRecycle_accountNestedInput = {
    create?: XOR<userCreateWithoutRecycle_accountInput, userUncheckedCreateWithoutRecycle_accountInput>
    connectOrCreate?: userCreateOrConnectWithoutRecycle_accountInput
    upsert?: userUpsertWithoutRecycle_accountInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutRecycle_accountInput, userUpdateWithoutRecycle_accountInput>, userUncheckedUpdateWithoutRecycle_accountInput>
  }

  export type userCreateNestedOneWithoutReport_postInput = {
    create?: XOR<userCreateWithoutReport_postInput, userUncheckedCreateWithoutReport_postInput>
    connectOrCreate?: userCreateOrConnectWithoutReport_postInput
    connect?: userWhereUniqueInput
  }

  export type postCreateNestedOneWithoutReport_postInput = {
    create?: XOR<postCreateWithoutReport_postInput, postUncheckedCreateWithoutReport_postInput>
    connectOrCreate?: postCreateOrConnectWithoutReport_postInput
    connect?: postWhereUniqueInput
  }

  export type userUpdateOneWithoutReport_postNestedInput = {
    create?: XOR<userCreateWithoutReport_postInput, userUncheckedCreateWithoutReport_postInput>
    connectOrCreate?: userCreateOrConnectWithoutReport_postInput
    upsert?: userUpsertWithoutReport_postInput
    disconnect?: userWhereInput | boolean
    delete?: userWhereInput | boolean
    connect?: userWhereUniqueInput
    update?: XOR<XOR<userUpdateToOneWithWhereWithoutReport_postInput, userUpdateWithoutReport_postInput>, userUncheckedUpdateWithoutReport_postInput>
  }

  export type postUpdateOneWithoutReport_postNestedInput = {
    create?: XOR<postCreateWithoutReport_postInput, postUncheckedCreateWithoutReport_postInput>
    connectOrCreate?: postCreateOrConnectWithoutReport_postInput
    upsert?: postUpsertWithoutReport_postInput
    disconnect?: postWhereInput | boolean
    delete?: postWhereInput | boolean
    connect?: postWhereUniqueInput
    update?: XOR<XOR<postUpdateToOneWithWhereWithoutReport_postInput, postUpdateWithoutReport_postInput>, postUncheckedUpdateWithoutReport_postInput>
  }

  export type guestCreateNestedOneWithoutRewardInput = {
    create?: XOR<guestCreateWithoutRewardInput, guestUncheckedCreateWithoutRewardInput>
    connectOrCreate?: guestCreateOrConnectWithoutRewardInput
    connect?: guestWhereUniqueInput
  }

  export type guestUpdateOneWithoutRewardNestedInput = {
    create?: XOR<guestCreateWithoutRewardInput, guestUncheckedCreateWithoutRewardInput>
    connectOrCreate?: guestCreateOrConnectWithoutRewardInput
    upsert?: guestUpsertWithoutRewardInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutRewardInput, guestUpdateWithoutRewardInput>, guestUncheckedUpdateWithoutRewardInput>
  }

  export type block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput> | block_userCreateWithoutUser_block_user_blockerIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockerIdTouserInputEnvelope
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
  }

  export type block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput> | block_userCreateWithoutUser_block_user_blockedIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockedIdTouserInputEnvelope
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
  }

  export type chatroom_memberCreateNestedManyWithoutUserInput = {
    create?: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput> | chatroom_memberCreateWithoutUserInput[] | chatroom_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutUserInput | chatroom_memberCreateOrConnectWithoutUserInput[]
    createMany?: chatroom_memberCreateManyUserInputEnvelope
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
  }

  export type comboCreateNestedManyWithoutUserInput = {
    create?: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput> | comboCreateWithoutUserInput[] | comboUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comboCreateOrConnectWithoutUserInput | comboCreateOrConnectWithoutUserInput[]
    createMany?: comboCreateManyUserInputEnvelope
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
  }

  export type commentCreateNestedManyWithoutUserInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput> | followshipCreateWithoutUser_followship_followerIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followerIdTouserInputEnvelope
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
  }

  export type followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput> | followshipCreateWithoutUser_followship_followedIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followedIdTouserInputEnvelope
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
  }

  export type messageCreateNestedManyWithoutUserInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type postCreateNestedManyWithoutUserInput = {
    create?: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput> | postCreateWithoutUserInput[] | postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: postCreateOrConnectWithoutUserInput | postCreateOrConnectWithoutUserInput[]
    createMany?: postCreateManyUserInputEnvelope
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
  }

  export type post_likeCreateNestedManyWithoutUserInput = {
    create?: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput> | post_likeCreateWithoutUserInput[] | post_likeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutUserInput | post_likeCreateOrConnectWithoutUserInput[]
    createMany?: post_likeCreateManyUserInputEnvelope
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
  }

  export type praiseCreateNestedManyWithoutUserInput = {
    create?: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput> | praiseCreateWithoutUserInput[] | praiseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutUserInput | praiseCreateOrConnectWithoutUserInput[]
    createMany?: praiseCreateManyUserInputEnvelope
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
  }

  export type recycle_accountCreateNestedOneWithoutUserInput = {
    create?: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
    connectOrCreate?: recycle_accountCreateOrConnectWithoutUserInput
    connect?: recycle_accountWhereUniqueInput
  }

  export type report_postCreateNestedManyWithoutUserInput = {
    create?: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput> | report_postCreateWithoutUserInput[] | report_postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutUserInput | report_postCreateOrConnectWithoutUserInput[]
    createMany?: report_postCreateManyUserInputEnvelope
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
  }

  export type guestCreateNestedOneWithoutUserInput = {
    create?: XOR<guestCreateWithoutUserInput, guestUncheckedCreateWithoutUserInput>
    connectOrCreate?: guestCreateOrConnectWithoutUserInput
    connect?: guestWhereUniqueInput
  }

  export type block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput> | block_userCreateWithoutUser_block_user_blockerIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockerIdTouserInputEnvelope
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
  }

  export type block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput> | block_userCreateWithoutUser_block_user_blockedIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockedIdTouserInputEnvelope
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
  }

  export type chatroom_memberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput> | chatroom_memberCreateWithoutUserInput[] | chatroom_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutUserInput | chatroom_memberCreateOrConnectWithoutUserInput[]
    createMany?: chatroom_memberCreateManyUserInputEnvelope
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
  }

  export type comboUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput> | comboCreateWithoutUserInput[] | comboUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comboCreateOrConnectWithoutUserInput | comboCreateOrConnectWithoutUserInput[]
    createMany?: comboCreateManyUserInputEnvelope
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
  }

  export type commentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
  }

  export type followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput> | followshipCreateWithoutUser_followship_followerIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followerIdTouserInputEnvelope
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
  }

  export type followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput> | followshipCreateWithoutUser_followship_followedIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followedIdTouserInputEnvelope
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
  }

  export type messageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
  }

  export type postUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput> | postCreateWithoutUserInput[] | postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: postCreateOrConnectWithoutUserInput | postCreateOrConnectWithoutUserInput[]
    createMany?: postCreateManyUserInputEnvelope
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
  }

  export type post_likeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput> | post_likeCreateWithoutUserInput[] | post_likeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutUserInput | post_likeCreateOrConnectWithoutUserInput[]
    createMany?: post_likeCreateManyUserInputEnvelope
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
  }

  export type praiseUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput> | praiseCreateWithoutUserInput[] | praiseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutUserInput | praiseCreateOrConnectWithoutUserInput[]
    createMany?: praiseCreateManyUserInputEnvelope
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
  }

  export type recycle_accountUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
    connectOrCreate?: recycle_accountCreateOrConnectWithoutUserInput
    connect?: recycle_accountWhereUniqueInput
  }

  export type report_postUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput> | report_postCreateWithoutUserInput[] | report_postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutUserInput | report_postCreateOrConnectWithoutUserInput[]
    createMany?: report_postCreateManyUserInputEnvelope
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
  }

  export type block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput> | block_userCreateWithoutUser_block_user_blockerIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput[]
    upsert?: block_userUpsertWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput | block_userUpsertWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockerIdTouserInputEnvelope
    set?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    disconnect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    delete?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    update?: block_userUpdateWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput | block_userUpdateWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput[]
    updateMany?: block_userUpdateManyWithWhereWithoutUser_block_user_blockerIdTouserInput | block_userUpdateManyWithWhereWithoutUser_block_user_blockerIdTouserInput[]
    deleteMany?: block_userScalarWhereInput | block_userScalarWhereInput[]
  }

  export type block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput> | block_userCreateWithoutUser_block_user_blockedIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput[]
    upsert?: block_userUpsertWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput | block_userUpsertWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockedIdTouserInputEnvelope
    set?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    disconnect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    delete?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    update?: block_userUpdateWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput | block_userUpdateWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput[]
    updateMany?: block_userUpdateManyWithWhereWithoutUser_block_user_blockedIdTouserInput | block_userUpdateManyWithWhereWithoutUser_block_user_blockedIdTouserInput[]
    deleteMany?: block_userScalarWhereInput | block_userScalarWhereInput[]
  }

  export type chatroom_memberUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput> | chatroom_memberCreateWithoutUserInput[] | chatroom_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutUserInput | chatroom_memberCreateOrConnectWithoutUserInput[]
    upsert?: chatroom_memberUpsertWithWhereUniqueWithoutUserInput | chatroom_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatroom_memberCreateManyUserInputEnvelope
    set?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    disconnect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    delete?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    update?: chatroom_memberUpdateWithWhereUniqueWithoutUserInput | chatroom_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatroom_memberUpdateManyWithWhereWithoutUserInput | chatroom_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
  }

  export type comboUpdateManyWithoutUserNestedInput = {
    create?: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput> | comboCreateWithoutUserInput[] | comboUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comboCreateOrConnectWithoutUserInput | comboCreateOrConnectWithoutUserInput[]
    upsert?: comboUpsertWithWhereUniqueWithoutUserInput | comboUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comboCreateManyUserInputEnvelope
    set?: comboWhereUniqueInput | comboWhereUniqueInput[]
    disconnect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    delete?: comboWhereUniqueInput | comboWhereUniqueInput[]
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    update?: comboUpdateWithWhereUniqueWithoutUserInput | comboUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comboUpdateManyWithWhereWithoutUserInput | comboUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comboScalarWhereInput | comboScalarWhereInput[]
  }

  export type commentUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutUserInput | commentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutUserInput | commentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentUpdateManyWithWhereWithoutUserInput | commentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput> | followshipCreateWithoutUser_followship_followerIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput[]
    upsert?: followshipUpsertWithWhereUniqueWithoutUser_followship_followerIdTouserInput | followshipUpsertWithWhereUniqueWithoutUser_followship_followerIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followerIdTouserInputEnvelope
    set?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    disconnect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    delete?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    update?: followshipUpdateWithWhereUniqueWithoutUser_followship_followerIdTouserInput | followshipUpdateWithWhereUniqueWithoutUser_followship_followerIdTouserInput[]
    updateMany?: followshipUpdateManyWithWhereWithoutUser_followship_followerIdTouserInput | followshipUpdateManyWithWhereWithoutUser_followship_followerIdTouserInput[]
    deleteMany?: followshipScalarWhereInput | followshipScalarWhereInput[]
  }

  export type followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput> | followshipCreateWithoutUser_followship_followedIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput[]
    upsert?: followshipUpsertWithWhereUniqueWithoutUser_followship_followedIdTouserInput | followshipUpsertWithWhereUniqueWithoutUser_followship_followedIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followedIdTouserInputEnvelope
    set?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    disconnect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    delete?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    update?: followshipUpdateWithWhereUniqueWithoutUser_followship_followedIdTouserInput | followshipUpdateWithWhereUniqueWithoutUser_followship_followedIdTouserInput[]
    updateMany?: followshipUpdateManyWithWhereWithoutUser_followship_followedIdTouserInput | followshipUpdateManyWithWhereWithoutUser_followship_followedIdTouserInput[]
    deleteMany?: followshipScalarWhereInput | followshipScalarWhereInput[]
  }

  export type messageUpdateManyWithoutUserNestedInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUserInput | messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUserInput | messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUserInput | messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type postUpdateManyWithoutUserNestedInput = {
    create?: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput> | postCreateWithoutUserInput[] | postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: postCreateOrConnectWithoutUserInput | postCreateOrConnectWithoutUserInput[]
    upsert?: postUpsertWithWhereUniqueWithoutUserInput | postUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: postCreateManyUserInputEnvelope
    set?: postWhereUniqueInput | postWhereUniqueInput[]
    disconnect?: postWhereUniqueInput | postWhereUniqueInput[]
    delete?: postWhereUniqueInput | postWhereUniqueInput[]
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
    update?: postUpdateWithWhereUniqueWithoutUserInput | postUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: postUpdateManyWithWhereWithoutUserInput | postUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: postScalarWhereInput | postScalarWhereInput[]
  }

  export type post_likeUpdateManyWithoutUserNestedInput = {
    create?: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput> | post_likeCreateWithoutUserInput[] | post_likeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutUserInput | post_likeCreateOrConnectWithoutUserInput[]
    upsert?: post_likeUpsertWithWhereUniqueWithoutUserInput | post_likeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: post_likeCreateManyUserInputEnvelope
    set?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    disconnect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    delete?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    update?: post_likeUpdateWithWhereUniqueWithoutUserInput | post_likeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: post_likeUpdateManyWithWhereWithoutUserInput | post_likeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
  }

  export type praiseUpdateManyWithoutUserNestedInput = {
    create?: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput> | praiseCreateWithoutUserInput[] | praiseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutUserInput | praiseCreateOrConnectWithoutUserInput[]
    upsert?: praiseUpsertWithWhereUniqueWithoutUserInput | praiseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: praiseCreateManyUserInputEnvelope
    set?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    disconnect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    delete?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    update?: praiseUpdateWithWhereUniqueWithoutUserInput | praiseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: praiseUpdateManyWithWhereWithoutUserInput | praiseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: praiseScalarWhereInput | praiseScalarWhereInput[]
  }

  export type recycle_accountUpdateOneWithoutUserNestedInput = {
    create?: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
    connectOrCreate?: recycle_accountCreateOrConnectWithoutUserInput
    upsert?: recycle_accountUpsertWithoutUserInput
    disconnect?: recycle_accountWhereInput | boolean
    delete?: recycle_accountWhereInput | boolean
    connect?: recycle_accountWhereUniqueInput
    update?: XOR<XOR<recycle_accountUpdateToOneWithWhereWithoutUserInput, recycle_accountUpdateWithoutUserInput>, recycle_accountUncheckedUpdateWithoutUserInput>
  }

  export type report_postUpdateManyWithoutUserNestedInput = {
    create?: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput> | report_postCreateWithoutUserInput[] | report_postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutUserInput | report_postCreateOrConnectWithoutUserInput[]
    upsert?: report_postUpsertWithWhereUniqueWithoutUserInput | report_postUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: report_postCreateManyUserInputEnvelope
    set?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    disconnect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    delete?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    update?: report_postUpdateWithWhereUniqueWithoutUserInput | report_postUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: report_postUpdateManyWithWhereWithoutUserInput | report_postUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: report_postScalarWhereInput | report_postScalarWhereInput[]
  }

  export type guestUpdateOneWithoutUserNestedInput = {
    create?: XOR<guestCreateWithoutUserInput, guestUncheckedCreateWithoutUserInput>
    connectOrCreate?: guestCreateOrConnectWithoutUserInput
    upsert?: guestUpsertWithoutUserInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutUserInput, guestUpdateWithoutUserInput>, guestUncheckedUpdateWithoutUserInput>
  }

  export type block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput> | block_userCreateWithoutUser_block_user_blockerIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput[]
    upsert?: block_userUpsertWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput | block_userUpsertWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockerIdTouserInputEnvelope
    set?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    disconnect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    delete?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    update?: block_userUpdateWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput | block_userUpdateWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput[]
    updateMany?: block_userUpdateManyWithWhereWithoutUser_block_user_blockerIdTouserInput | block_userUpdateManyWithWhereWithoutUser_block_user_blockerIdTouserInput[]
    deleteMany?: block_userScalarWhereInput | block_userScalarWhereInput[]
  }

  export type block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput = {
    create?: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput> | block_userCreateWithoutUser_block_user_blockedIdTouserInput[] | block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput[]
    connectOrCreate?: block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput | block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput[]
    upsert?: block_userUpsertWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput | block_userUpsertWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput[]
    createMany?: block_userCreateManyUser_block_user_blockedIdTouserInputEnvelope
    set?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    disconnect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    delete?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    connect?: block_userWhereUniqueInput | block_userWhereUniqueInput[]
    update?: block_userUpdateWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput | block_userUpdateWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput[]
    updateMany?: block_userUpdateManyWithWhereWithoutUser_block_user_blockedIdTouserInput | block_userUpdateManyWithWhereWithoutUser_block_user_blockedIdTouserInput[]
    deleteMany?: block_userScalarWhereInput | block_userScalarWhereInput[]
  }

  export type chatroom_memberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput> | chatroom_memberCreateWithoutUserInput[] | chatroom_memberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: chatroom_memberCreateOrConnectWithoutUserInput | chatroom_memberCreateOrConnectWithoutUserInput[]
    upsert?: chatroom_memberUpsertWithWhereUniqueWithoutUserInput | chatroom_memberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: chatroom_memberCreateManyUserInputEnvelope
    set?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    disconnect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    delete?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    connect?: chatroom_memberWhereUniqueInput | chatroom_memberWhereUniqueInput[]
    update?: chatroom_memberUpdateWithWhereUniqueWithoutUserInput | chatroom_memberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: chatroom_memberUpdateManyWithWhereWithoutUserInput | chatroom_memberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
  }

  export type comboUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput> | comboCreateWithoutUserInput[] | comboUncheckedCreateWithoutUserInput[]
    connectOrCreate?: comboCreateOrConnectWithoutUserInput | comboCreateOrConnectWithoutUserInput[]
    upsert?: comboUpsertWithWhereUniqueWithoutUserInput | comboUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: comboCreateManyUserInputEnvelope
    set?: comboWhereUniqueInput | comboWhereUniqueInput[]
    disconnect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    delete?: comboWhereUniqueInput | comboWhereUniqueInput[]
    connect?: comboWhereUniqueInput | comboWhereUniqueInput[]
    update?: comboUpdateWithWhereUniqueWithoutUserInput | comboUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: comboUpdateManyWithWhereWithoutUserInput | comboUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: comboScalarWhereInput | comboScalarWhereInput[]
  }

  export type commentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput> | commentCreateWithoutUserInput[] | commentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: commentCreateOrConnectWithoutUserInput | commentCreateOrConnectWithoutUserInput[]
    upsert?: commentUpsertWithWhereUniqueWithoutUserInput | commentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: commentCreateManyUserInputEnvelope
    set?: commentWhereUniqueInput | commentWhereUniqueInput[]
    disconnect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    delete?: commentWhereUniqueInput | commentWhereUniqueInput[]
    connect?: commentWhereUniqueInput | commentWhereUniqueInput[]
    update?: commentUpdateWithWhereUniqueWithoutUserInput | commentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: commentUpdateManyWithWhereWithoutUserInput | commentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: commentScalarWhereInput | commentScalarWhereInput[]
  }

  export type followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput> | followshipCreateWithoutUser_followship_followerIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput[]
    upsert?: followshipUpsertWithWhereUniqueWithoutUser_followship_followerIdTouserInput | followshipUpsertWithWhereUniqueWithoutUser_followship_followerIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followerIdTouserInputEnvelope
    set?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    disconnect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    delete?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    update?: followshipUpdateWithWhereUniqueWithoutUser_followship_followerIdTouserInput | followshipUpdateWithWhereUniqueWithoutUser_followship_followerIdTouserInput[]
    updateMany?: followshipUpdateManyWithWhereWithoutUser_followship_followerIdTouserInput | followshipUpdateManyWithWhereWithoutUser_followship_followerIdTouserInput[]
    deleteMany?: followshipScalarWhereInput | followshipScalarWhereInput[]
  }

  export type followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput = {
    create?: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput> | followshipCreateWithoutUser_followship_followedIdTouserInput[] | followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput[]
    connectOrCreate?: followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput | followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput[]
    upsert?: followshipUpsertWithWhereUniqueWithoutUser_followship_followedIdTouserInput | followshipUpsertWithWhereUniqueWithoutUser_followship_followedIdTouserInput[]
    createMany?: followshipCreateManyUser_followship_followedIdTouserInputEnvelope
    set?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    disconnect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    delete?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    connect?: followshipWhereUniqueInput | followshipWhereUniqueInput[]
    update?: followshipUpdateWithWhereUniqueWithoutUser_followship_followedIdTouserInput | followshipUpdateWithWhereUniqueWithoutUser_followship_followedIdTouserInput[]
    updateMany?: followshipUpdateManyWithWhereWithoutUser_followship_followedIdTouserInput | followshipUpdateManyWithWhereWithoutUser_followship_followedIdTouserInput[]
    deleteMany?: followshipScalarWhereInput | followshipScalarWhereInput[]
  }

  export type messageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput> | messageCreateWithoutUserInput[] | messageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: messageCreateOrConnectWithoutUserInput | messageCreateOrConnectWithoutUserInput[]
    upsert?: messageUpsertWithWhereUniqueWithoutUserInput | messageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: messageCreateManyUserInputEnvelope
    set?: messageWhereUniqueInput | messageWhereUniqueInput[]
    disconnect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    delete?: messageWhereUniqueInput | messageWhereUniqueInput[]
    connect?: messageWhereUniqueInput | messageWhereUniqueInput[]
    update?: messageUpdateWithWhereUniqueWithoutUserInput | messageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: messageUpdateManyWithWhereWithoutUserInput | messageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: messageScalarWhereInput | messageScalarWhereInput[]
  }

  export type postUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput> | postCreateWithoutUserInput[] | postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: postCreateOrConnectWithoutUserInput | postCreateOrConnectWithoutUserInput[]
    upsert?: postUpsertWithWhereUniqueWithoutUserInput | postUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: postCreateManyUserInputEnvelope
    set?: postWhereUniqueInput | postWhereUniqueInput[]
    disconnect?: postWhereUniqueInput | postWhereUniqueInput[]
    delete?: postWhereUniqueInput | postWhereUniqueInput[]
    connect?: postWhereUniqueInput | postWhereUniqueInput[]
    update?: postUpdateWithWhereUniqueWithoutUserInput | postUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: postUpdateManyWithWhereWithoutUserInput | postUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: postScalarWhereInput | postScalarWhereInput[]
  }

  export type post_likeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput> | post_likeCreateWithoutUserInput[] | post_likeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: post_likeCreateOrConnectWithoutUserInput | post_likeCreateOrConnectWithoutUserInput[]
    upsert?: post_likeUpsertWithWhereUniqueWithoutUserInput | post_likeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: post_likeCreateManyUserInputEnvelope
    set?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    disconnect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    delete?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    connect?: post_likeWhereUniqueInput | post_likeWhereUniqueInput[]
    update?: post_likeUpdateWithWhereUniqueWithoutUserInput | post_likeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: post_likeUpdateManyWithWhereWithoutUserInput | post_likeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
  }

  export type praiseUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput> | praiseCreateWithoutUserInput[] | praiseUncheckedCreateWithoutUserInput[]
    connectOrCreate?: praiseCreateOrConnectWithoutUserInput | praiseCreateOrConnectWithoutUserInput[]
    upsert?: praiseUpsertWithWhereUniqueWithoutUserInput | praiseUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: praiseCreateManyUserInputEnvelope
    set?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    disconnect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    delete?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    connect?: praiseWhereUniqueInput | praiseWhereUniqueInput[]
    update?: praiseUpdateWithWhereUniqueWithoutUserInput | praiseUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: praiseUpdateManyWithWhereWithoutUserInput | praiseUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: praiseScalarWhereInput | praiseScalarWhereInput[]
  }

  export type recycle_accountUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
    connectOrCreate?: recycle_accountCreateOrConnectWithoutUserInput
    upsert?: recycle_accountUpsertWithoutUserInput
    disconnect?: recycle_accountWhereInput | boolean
    delete?: recycle_accountWhereInput | boolean
    connect?: recycle_accountWhereUniqueInput
    update?: XOR<XOR<recycle_accountUpdateToOneWithWhereWithoutUserInput, recycle_accountUpdateWithoutUserInput>, recycle_accountUncheckedUpdateWithoutUserInput>
  }

  export type report_postUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput> | report_postCreateWithoutUserInput[] | report_postUncheckedCreateWithoutUserInput[]
    connectOrCreate?: report_postCreateOrConnectWithoutUserInput | report_postCreateOrConnectWithoutUserInput[]
    upsert?: report_postUpsertWithWhereUniqueWithoutUserInput | report_postUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: report_postCreateManyUserInputEnvelope
    set?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    disconnect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    delete?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    connect?: report_postWhereUniqueInput | report_postWhereUniqueInput[]
    update?: report_postUpdateWithWhereUniqueWithoutUserInput | report_postUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: report_postUpdateManyWithWhereWithoutUserInput | report_postUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: report_postScalarWhereInput | report_postScalarWhereInput[]
  }

  export type guestCreateNestedOneWithoutWarningInput = {
    create?: XOR<guestCreateWithoutWarningInput, guestUncheckedCreateWithoutWarningInput>
    connectOrCreate?: guestCreateOrConnectWithoutWarningInput
    connect?: guestWhereUniqueInput
  }

  export type guestUpdateOneWithoutWarningNestedInput = {
    create?: XOR<guestCreateWithoutWarningInput, guestUncheckedCreateWithoutWarningInput>
    connectOrCreate?: guestCreateOrConnectWithoutWarningInput
    upsert?: guestUpsertWithoutWarningInput
    disconnect?: guestWhereInput | boolean
    delete?: guestWhereInput | boolean
    connect?: guestWhereUniqueInput
    update?: XOR<XOR<guestUpdateToOneWithWhereWithoutWarningInput, guestUpdateWithoutWarningInput>, guestUncheckedUpdateWithoutWarningInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type guestCreateWithoutActivity_activity_subscriberIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutActivity_activity_subscriberIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutActivity_activity_subscriberIdToguestInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedCreateWithoutActivity_activity_subscriberIdToguestInput>
  }

  export type guestCreateWithoutActivity_activity_guestIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutActivity_activity_guestIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutActivity_activity_guestIdToguestInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutActivity_activity_guestIdToguestInput, guestUncheckedCreateWithoutActivity_activity_guestIdToguestInput>
  }

  export type guestUpsertWithoutActivity_activity_subscriberIdToguestInput = {
    update: XOR<guestUpdateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedUpdateWithoutActivity_activity_subscriberIdToguestInput>
    create: XOR<guestCreateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedCreateWithoutActivity_activity_subscriberIdToguestInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutActivity_activity_subscriberIdToguestInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutActivity_activity_subscriberIdToguestInput, guestUncheckedUpdateWithoutActivity_activity_subscriberIdToguestInput>
  }

  export type guestUpdateWithoutActivity_activity_subscriberIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutActivity_activity_subscriberIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type guestUpsertWithoutActivity_activity_guestIdToguestInput = {
    update: XOR<guestUpdateWithoutActivity_activity_guestIdToguestInput, guestUncheckedUpdateWithoutActivity_activity_guestIdToguestInput>
    create: XOR<guestCreateWithoutActivity_activity_guestIdToguestInput, guestUncheckedCreateWithoutActivity_activity_guestIdToguestInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutActivity_activity_guestIdToguestInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutActivity_activity_guestIdToguestInput, guestUncheckedUpdateWithoutActivity_activity_guestIdToguestInput>
  }

  export type guestUpdateWithoutActivity_activity_guestIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutActivity_activity_guestIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type userCreateWithoutBlock_user_block_user_blockerIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutBlock_user_block_user_blockerIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBlock_user_block_user_blockerIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockerIdTouserInput>
  }

  export type userCreateWithoutBlock_user_block_user_blockedIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutBlock_user_block_user_blockedIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutBlock_user_block_user_blockedIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockedIdTouserInput>
  }

  export type userUpsertWithoutBlock_user_block_user_blockerIdTouserInput = {
    update: XOR<userUpdateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedUpdateWithoutBlock_user_block_user_blockerIdTouserInput>
    create: XOR<userCreateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockerIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBlock_user_block_user_blockerIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBlock_user_block_user_blockerIdTouserInput, userUncheckedUpdateWithoutBlock_user_block_user_blockerIdTouserInput>
  }

  export type userUpdateWithoutBlock_user_block_user_blockerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBlock_user_block_user_blockerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutBlock_user_block_user_blockedIdTouserInput = {
    update: XOR<userUpdateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedUpdateWithoutBlock_user_block_user_blockedIdTouserInput>
    create: XOR<userCreateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedCreateWithoutBlock_user_block_user_blockedIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutBlock_user_block_user_blockedIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutBlock_user_block_user_blockedIdTouserInput, userUncheckedUpdateWithoutBlock_user_block_user_blockedIdTouserInput>
  }

  export type userUpdateWithoutBlock_user_block_user_blockedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutBlock_user_block_user_blockedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type chatroom_memberCreateWithoutChatroomInput = {
    user: userCreateNestedOneWithoutChatroom_memberInput
  }

  export type chatroom_memberUncheckedCreateWithoutChatroomInput = {
    userId: string
  }

  export type chatroom_memberCreateOrConnectWithoutChatroomInput = {
    where: chatroom_memberWhereUniqueInput
    create: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput>
  }

  export type chatroom_memberCreateManyChatroomInputEnvelope = {
    data: chatroom_memberCreateManyChatroomInput | chatroom_memberCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutChatroomInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
    order?: number
    image_message?: image_messageCreateNestedManyWithoutMessageInput
    user?: userCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutChatroomInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    sender_id?: string | null
    is_read?: boolean
    order?: number
    image_message?: image_messageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutChatroomInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput>
  }

  export type messageCreateManyChatroomInputEnvelope = {
    data: messageCreateManyChatroomInput | messageCreateManyChatroomInput[]
    skipDuplicates?: boolean
  }

  export type chatroom_memberUpsertWithWhereUniqueWithoutChatroomInput = {
    where: chatroom_memberWhereUniqueInput
    update: XOR<chatroom_memberUpdateWithoutChatroomInput, chatroom_memberUncheckedUpdateWithoutChatroomInput>
    create: XOR<chatroom_memberCreateWithoutChatroomInput, chatroom_memberUncheckedCreateWithoutChatroomInput>
  }

  export type chatroom_memberUpdateWithWhereUniqueWithoutChatroomInput = {
    where: chatroom_memberWhereUniqueInput
    data: XOR<chatroom_memberUpdateWithoutChatroomInput, chatroom_memberUncheckedUpdateWithoutChatroomInput>
  }

  export type chatroom_memberUpdateManyWithWhereWithoutChatroomInput = {
    where: chatroom_memberScalarWhereInput
    data: XOR<chatroom_memberUpdateManyMutationInput, chatroom_memberUncheckedUpdateManyWithoutChatroomInput>
  }

  export type chatroom_memberScalarWhereInput = {
    AND?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
    OR?: chatroom_memberScalarWhereInput[]
    NOT?: chatroom_memberScalarWhereInput | chatroom_memberScalarWhereInput[]
    chatroomId?: UuidFilter<"chatroom_member"> | string
    userId?: UuidFilter<"chatroom_member"> | string
  }

  export type messageUpsertWithWhereUniqueWithoutChatroomInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutChatroomInput, messageUncheckedUpdateWithoutChatroomInput>
    create: XOR<messageCreateWithoutChatroomInput, messageUncheckedCreateWithoutChatroomInput>
  }

  export type messageUpdateWithWhereUniqueWithoutChatroomInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutChatroomInput, messageUncheckedUpdateWithoutChatroomInput>
  }

  export type messageUpdateManyWithWhereWithoutChatroomInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutChatroomInput>
  }

  export type messageScalarWhereInput = {
    AND?: messageScalarWhereInput | messageScalarWhereInput[]
    OR?: messageScalarWhereInput[]
    NOT?: messageScalarWhereInput | messageScalarWhereInput[]
    id?: UuidFilter<"message"> | string
    message?: StringFilter<"message"> | string
    created_at?: DateTimeFilter<"message"> | Date | string
    updated_at?: DateTimeFilter<"message"> | Date | string
    sender_id?: UuidNullableFilter<"message"> | string | null
    chatroom_id?: UuidNullableFilter<"message"> | string | null
    is_read?: BoolFilter<"message"> | boolean
    order?: IntFilter<"message"> | number
  }

  export type chatroomCreateWithoutChatroom_memberInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    message?: messageCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutChatroom_memberInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    message?: messageUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomCreateOrConnectWithoutChatroom_memberInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutChatroom_memberInput, chatroomUncheckedCreateWithoutChatroom_memberInput>
  }

  export type userCreateWithoutChatroom_memberInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutChatroom_memberInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutChatroom_memberInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutChatroom_memberInput, userUncheckedCreateWithoutChatroom_memberInput>
  }

  export type chatroomUpsertWithoutChatroom_memberInput = {
    update: XOR<chatroomUpdateWithoutChatroom_memberInput, chatroomUncheckedUpdateWithoutChatroom_memberInput>
    create: XOR<chatroomCreateWithoutChatroom_memberInput, chatroomUncheckedCreateWithoutChatroom_memberInput>
    where?: chatroomWhereInput
  }

  export type chatroomUpdateToOneWithWhereWithoutChatroom_memberInput = {
    where?: chatroomWhereInput
    data: XOR<chatroomUpdateWithoutChatroom_memberInput, chatroomUncheckedUpdateWithoutChatroom_memberInput>
  }

  export type chatroomUpdateWithoutChatroom_memberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutChatroom_memberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: messageUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type userUpsertWithoutChatroom_memberInput = {
    update: XOR<userUpdateWithoutChatroom_memberInput, userUncheckedUpdateWithoutChatroom_memberInput>
    create: XOR<userCreateWithoutChatroom_memberInput, userUncheckedCreateWithoutChatroom_memberInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutChatroom_memberInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutChatroom_memberInput, userUncheckedUpdateWithoutChatroom_memberInput>
  }

  export type userUpdateWithoutChatroom_memberInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutChatroom_memberInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type postCreateWithoutComboInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    comment?: commentCreateNestedManyWithoutPostInput
    user?: userCreateNestedOneWithoutPostInput
    post_like?: post_likeCreateNestedManyWithoutPostInput
    report_post?: report_postCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateWithoutComboInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
    comment?: commentUncheckedCreateNestedManyWithoutPostInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutPostInput
    report_post?: report_postUncheckedCreateNestedManyWithoutPostInput
  }

  export type postCreateOrConnectWithoutComboInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutComboInput, postUncheckedCreateWithoutComboInput>
  }

  export type userCreateWithoutComboInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutComboInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutComboInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutComboInput, userUncheckedCreateWithoutComboInput>
  }

  export type postUpsertWithoutComboInput = {
    update: XOR<postUpdateWithoutComboInput, postUncheckedUpdateWithoutComboInput>
    create: XOR<postCreateWithoutComboInput, postUncheckedCreateWithoutComboInput>
    where?: postWhereInput
  }

  export type postUpdateToOneWithWhereWithoutComboInput = {
    where?: postWhereInput
    data: XOR<postUpdateWithoutComboInput, postUncheckedUpdateWithoutComboInput>
  }

  export type postUpdateWithoutComboInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: commentUpdateManyWithoutPostNestedInput
    user?: userUpdateOneWithoutPostNestedInput
    post_like?: post_likeUpdateManyWithoutPostNestedInput
    report_post?: report_postUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateWithoutComboInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: commentUncheckedUpdateManyWithoutPostNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutPostNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutPostNestedInput
  }

  export type userUpsertWithoutComboInput = {
    update: XOR<userUpdateWithoutComboInput, userUncheckedUpdateWithoutComboInput>
    create: XOR<userCreateWithoutComboInput, userUncheckedCreateWithoutComboInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutComboInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutComboInput, userUncheckedUpdateWithoutComboInput>
  }

  export type userUpdateWithoutComboInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutComboInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type postCreateWithoutCommentInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboCreateNestedManyWithoutPostInput
    user?: userCreateNestedOneWithoutPostInput
    post_like?: post_likeCreateNestedManyWithoutPostInput
    report_post?: report_postCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateWithoutCommentInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
    combo?: comboUncheckedCreateNestedManyWithoutPostInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutPostInput
    report_post?: report_postUncheckedCreateNestedManyWithoutPostInput
  }

  export type postCreateOrConnectWithoutCommentInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutCommentInput, postUncheckedCreateWithoutCommentInput>
  }

  export type userCreateWithoutCommentInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutCommentInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCommentInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
  }

  export type postUpsertWithoutCommentInput = {
    update: XOR<postUpdateWithoutCommentInput, postUncheckedUpdateWithoutCommentInput>
    create: XOR<postCreateWithoutCommentInput, postUncheckedCreateWithoutCommentInput>
    where?: postWhereInput
  }

  export type postUpdateToOneWithWhereWithoutCommentInput = {
    where?: postWhereInput
    data: XOR<postUpdateWithoutCommentInput, postUncheckedUpdateWithoutCommentInput>
  }

  export type postUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUpdateManyWithoutPostNestedInput
    user?: userUpdateOneWithoutPostNestedInput
    post_like?: post_likeUpdateManyWithoutPostNestedInput
    report_post?: report_postUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    combo?: comboUncheckedUpdateManyWithoutPostNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutPostNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutPostNestedInput
  }

  export type userUpsertWithoutCommentInput = {
    update: XOR<userUpdateWithoutCommentInput, userUncheckedUpdateWithoutCommentInput>
    create: XOR<userCreateWithoutCommentInput, userUncheckedCreateWithoutCommentInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutCommentInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutCommentInput, userUncheckedUpdateWithoutCommentInput>
  }

  export type userUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutFollowship_followship_followerIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutFollowship_followship_followerIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFollowship_followship_followerIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFollowship_followship_followerIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followerIdTouserInput>
  }

  export type userCreateWithoutFollowship_followship_followedIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutFollowship_followship_followedIdTouserInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFollowship_followship_followedIdTouserInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFollowship_followship_followedIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followedIdTouserInput>
  }

  export type userUpsertWithoutFollowship_followship_followerIdTouserInput = {
    update: XOR<userUpdateWithoutFollowship_followship_followerIdTouserInput, userUncheckedUpdateWithoutFollowship_followship_followerIdTouserInput>
    create: XOR<userCreateWithoutFollowship_followship_followerIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followerIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFollowship_followship_followerIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFollowship_followship_followerIdTouserInput, userUncheckedUpdateWithoutFollowship_followship_followerIdTouserInput>
  }

  export type userUpdateWithoutFollowship_followship_followerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFollowship_followship_followerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpsertWithoutFollowship_followship_followedIdTouserInput = {
    update: XOR<userUpdateWithoutFollowship_followship_followedIdTouserInput, userUncheckedUpdateWithoutFollowship_followship_followedIdTouserInput>
    create: XOR<userCreateWithoutFollowship_followship_followedIdTouserInput, userUncheckedCreateWithoutFollowship_followship_followedIdTouserInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutFollowship_followship_followedIdTouserInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutFollowship_followship_followedIdTouserInput, userUncheckedUpdateWithoutFollowship_followship_followedIdTouserInput>
  }

  export type userUpdateWithoutFollowship_followship_followedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFollowship_followship_followedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type activityCreateWithoutGuest_activity_subscriberIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guest_activity_guestIdToguest?: guestCreateNestedOneWithoutActivity_activity_guestIdToguestInput
  }

  export type activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guestId?: string | null
  }

  export type activityCreateOrConnectWithoutGuest_activity_subscriberIdToguestInput = {
    where: activityWhereUniqueInput
    create: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput>
  }

  export type activityCreateManyGuest_activity_subscriberIdToguestInputEnvelope = {
    data: activityCreateManyGuest_activity_subscriberIdToguestInput | activityCreateManyGuest_activity_subscriberIdToguestInput[]
    skipDuplicates?: boolean
  }

  export type activityCreateWithoutGuest_activity_guestIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guest_activity_subscriberIdToguest?: guestCreateNestedOneWithoutActivity_activity_subscriberIdToguestInput
  }

  export type activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    subscriberId?: string | null
  }

  export type activityCreateOrConnectWithoutGuest_activity_guestIdToguestInput = {
    where: activityWhereUniqueInput
    create: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput>
  }

  export type activityCreateManyGuest_activity_guestIdToguestInputEnvelope = {
    data: activityCreateManyGuest_activity_guestIdToguestInput | activityCreateManyGuest_activity_guestIdToguestInput[]
    skipDuplicates?: boolean
  }

  export type inviteCreateWithoutGuest_invite_invitedIdToguestInput = {
    id?: string
    created_at?: Date | string
    guest_invite_inviterIdToguest?: guestCreateNestedOneWithoutInvite_invite_inviterIdToguestInput
  }

  export type inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput = {
    id?: string
    created_at?: Date | string
    inviterId?: string | null
  }

  export type inviteCreateOrConnectWithoutGuest_invite_invitedIdToguestInput = {
    where: inviteWhereUniqueInput
    create: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
  }

  export type inviteCreateWithoutGuest_invite_inviterIdToguestInput = {
    id?: string
    created_at?: Date | string
    guest_invite_invitedIdToguest?: guestCreateNestedOneWithoutInvite_invite_invitedIdToguestInput
  }

  export type inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput = {
    id?: string
    created_at?: Date | string
    invitedId?: string | null
  }

  export type inviteCreateOrConnectWithoutGuest_invite_inviterIdToguestInput = {
    where: inviteWhereUniqueInput
    create: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput>
  }

  export type inviteCreateManyGuest_invite_inviterIdToguestInputEnvelope = {
    data: inviteCreateManyGuest_invite_inviterIdToguestInput | inviteCreateManyGuest_invite_inviterIdToguestInput[]
    skipDuplicates?: boolean
  }

  export type praiseCreateWithoutGuestInput = {
    id?: string
    is_like: boolean
    created_at?: Date | string
    user?: userCreateNestedOneWithoutPraiseInput
  }

  export type praiseUncheckedCreateWithoutGuestInput = {
    id?: string
    is_like: boolean
    user_id?: string | null
    created_at?: Date | string
  }

  export type praiseCreateOrConnectWithoutGuestInput = {
    where: praiseWhereUniqueInput
    create: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput>
  }

  export type praiseCreateManyGuestInputEnvelope = {
    data: praiseCreateManyGuestInput | praiseCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type rewardCreateWithoutGuestInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type rewardUncheckedCreateWithoutGuestInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type rewardCreateOrConnectWithoutGuestInput = {
    where: rewardWhereUniqueInput
    create: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput>
  }

  export type rewardCreateManyGuestInputEnvelope = {
    data: rewardCreateManyGuestInput | rewardCreateManyGuestInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutGuestInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutGuestInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutGuestInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
  }

  export type warningCreateWithoutGuestInput = {
    id?: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type warningUncheckedCreateWithoutGuestInput = {
    id?: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type warningCreateOrConnectWithoutGuestInput = {
    where: warningWhereUniqueInput
    create: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
  }

  export type activityUpsertWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput = {
    where: activityWhereUniqueInput
    update: XOR<activityUpdateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedUpdateWithoutGuest_activity_subscriberIdToguestInput>
    create: XOR<activityCreateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedCreateWithoutGuest_activity_subscriberIdToguestInput>
  }

  export type activityUpdateWithWhereUniqueWithoutGuest_activity_subscriberIdToguestInput = {
    where: activityWhereUniqueInput
    data: XOR<activityUpdateWithoutGuest_activity_subscriberIdToguestInput, activityUncheckedUpdateWithoutGuest_activity_subscriberIdToguestInput>
  }

  export type activityUpdateManyWithWhereWithoutGuest_activity_subscriberIdToguestInput = {
    where: activityScalarWhereInput
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestInput>
  }

  export type activityScalarWhereInput = {
    AND?: activityScalarWhereInput | activityScalarWhereInput[]
    OR?: activityScalarWhereInput[]
    NOT?: activityScalarWhereInput | activityScalarWhereInput[]
    id?: UuidFilter<"activity"> | string
    content?: StringFilter<"activity"> | string
    route?: StringFilter<"activity"> | string
    param?: StringFilter<"activity"> | string
    subscriber_avatar?: StringFilter<"activity"> | string
    post_image?: StringFilter<"activity"> | string
    type?: StringFilter<"activity"> | string
    created_at?: DateTimeFilter<"activity"> | Date | string
    guestId?: UuidNullableFilter<"activity"> | string | null
    subscriberId?: UuidNullableFilter<"activity"> | string | null
  }

  export type activityUpsertWithWhereUniqueWithoutGuest_activity_guestIdToguestInput = {
    where: activityWhereUniqueInput
    update: XOR<activityUpdateWithoutGuest_activity_guestIdToguestInput, activityUncheckedUpdateWithoutGuest_activity_guestIdToguestInput>
    create: XOR<activityCreateWithoutGuest_activity_guestIdToguestInput, activityUncheckedCreateWithoutGuest_activity_guestIdToguestInput>
  }

  export type activityUpdateWithWhereUniqueWithoutGuest_activity_guestIdToguestInput = {
    where: activityWhereUniqueInput
    data: XOR<activityUpdateWithoutGuest_activity_guestIdToguestInput, activityUncheckedUpdateWithoutGuest_activity_guestIdToguestInput>
  }

  export type activityUpdateManyWithWhereWithoutGuest_activity_guestIdToguestInput = {
    where: activityScalarWhereInput
    data: XOR<activityUpdateManyMutationInput, activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestInput>
  }

  export type inviteUpsertWithoutGuest_invite_invitedIdToguestInput = {
    update: XOR<inviteUpdateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedUpdateWithoutGuest_invite_invitedIdToguestInput>
    create: XOR<inviteCreateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_invitedIdToguestInput>
    where?: inviteWhereInput
  }

  export type inviteUpdateToOneWithWhereWithoutGuest_invite_invitedIdToguestInput = {
    where?: inviteWhereInput
    data: XOR<inviteUpdateWithoutGuest_invite_invitedIdToguestInput, inviteUncheckedUpdateWithoutGuest_invite_invitedIdToguestInput>
  }

  export type inviteUpdateWithoutGuest_invite_invitedIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_invite_inviterIdToguest?: guestUpdateOneWithoutInvite_invite_inviterIdToguestNestedInput
  }

  export type inviteUncheckedUpdateWithoutGuest_invite_invitedIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inviterId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inviteUpsertWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput = {
    where: inviteWhereUniqueInput
    update: XOR<inviteUpdateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedUpdateWithoutGuest_invite_inviterIdToguestInput>
    create: XOR<inviteCreateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedCreateWithoutGuest_invite_inviterIdToguestInput>
  }

  export type inviteUpdateWithWhereUniqueWithoutGuest_invite_inviterIdToguestInput = {
    where: inviteWhereUniqueInput
    data: XOR<inviteUpdateWithoutGuest_invite_inviterIdToguestInput, inviteUncheckedUpdateWithoutGuest_invite_inviterIdToguestInput>
  }

  export type inviteUpdateManyWithWhereWithoutGuest_invite_inviterIdToguestInput = {
    where: inviteScalarWhereInput
    data: XOR<inviteUpdateManyMutationInput, inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestInput>
  }

  export type inviteScalarWhereInput = {
    AND?: inviteScalarWhereInput | inviteScalarWhereInput[]
    OR?: inviteScalarWhereInput[]
    NOT?: inviteScalarWhereInput | inviteScalarWhereInput[]
    id?: UuidFilter<"invite"> | string
    created_at?: DateTimeFilter<"invite"> | Date | string
    inviterId?: UuidNullableFilter<"invite"> | string | null
    invitedId?: UuidNullableFilter<"invite"> | string | null
  }

  export type praiseUpsertWithWhereUniqueWithoutGuestInput = {
    where: praiseWhereUniqueInput
    update: XOR<praiseUpdateWithoutGuestInput, praiseUncheckedUpdateWithoutGuestInput>
    create: XOR<praiseCreateWithoutGuestInput, praiseUncheckedCreateWithoutGuestInput>
  }

  export type praiseUpdateWithWhereUniqueWithoutGuestInput = {
    where: praiseWhereUniqueInput
    data: XOR<praiseUpdateWithoutGuestInput, praiseUncheckedUpdateWithoutGuestInput>
  }

  export type praiseUpdateManyWithWhereWithoutGuestInput = {
    where: praiseScalarWhereInput
    data: XOR<praiseUpdateManyMutationInput, praiseUncheckedUpdateManyWithoutGuestInput>
  }

  export type praiseScalarWhereInput = {
    AND?: praiseScalarWhereInput | praiseScalarWhereInput[]
    OR?: praiseScalarWhereInput[]
    NOT?: praiseScalarWhereInput | praiseScalarWhereInput[]
    id?: UuidFilter<"praise"> | string
    is_like?: BoolFilter<"praise"> | boolean
    user_id?: UuidNullableFilter<"praise"> | string | null
    guest_id?: UuidNullableFilter<"praise"> | string | null
    created_at?: DateTimeFilter<"praise"> | Date | string
  }

  export type rewardUpsertWithWhereUniqueWithoutGuestInput = {
    where: rewardWhereUniqueInput
    update: XOR<rewardUpdateWithoutGuestInput, rewardUncheckedUpdateWithoutGuestInput>
    create: XOR<rewardCreateWithoutGuestInput, rewardUncheckedCreateWithoutGuestInput>
  }

  export type rewardUpdateWithWhereUniqueWithoutGuestInput = {
    where: rewardWhereUniqueInput
    data: XOR<rewardUpdateWithoutGuestInput, rewardUncheckedUpdateWithoutGuestInput>
  }

  export type rewardUpdateManyWithWhereWithoutGuestInput = {
    where: rewardScalarWhereInput
    data: XOR<rewardUpdateManyMutationInput, rewardUncheckedUpdateManyWithoutGuestInput>
  }

  export type rewardScalarWhereInput = {
    AND?: rewardScalarWhereInput | rewardScalarWhereInput[]
    OR?: rewardScalarWhereInput[]
    NOT?: rewardScalarWhereInput | rewardScalarWhereInput[]
    id?: UuidFilter<"reward"> | string
    amount?: IntFilter<"reward"> | number
    created_at?: DateTimeFilter<"reward"> | Date | string
    updated_at?: DateTimeFilter<"reward"> | Date | string
    guest_id?: UuidNullableFilter<"reward"> | string | null
  }

  export type userUpsertWithoutGuestInput = {
    update: XOR<userUpdateWithoutGuestInput, userUncheckedUpdateWithoutGuestInput>
    create: XOR<userCreateWithoutGuestInput, userUncheckedCreateWithoutGuestInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutGuestInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutGuestInput, userUncheckedUpdateWithoutGuestInput>
  }

  export type userUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type warningUpsertWithoutGuestInput = {
    update: XOR<warningUpdateWithoutGuestInput, warningUncheckedUpdateWithoutGuestInput>
    create: XOR<warningCreateWithoutGuestInput, warningUncheckedCreateWithoutGuestInput>
    where?: warningWhereInput
  }

  export type warningUpdateToOneWithWhereWithoutGuestInput = {
    where?: warningWhereInput
    data: XOR<warningUpdateWithoutGuestInput, warningUncheckedUpdateWithoutGuestInput>
  }

  export type warningUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type warningUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messageCreateWithoutImage_messageInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
    order?: number
    chatroom?: chatroomCreateNestedOneWithoutMessageInput
    user?: userCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutImage_messageInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    sender_id?: string | null
    chatroom_id?: string | null
    is_read?: boolean
    order?: number
  }

  export type messageCreateOrConnectWithoutImage_messageInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutImage_messageInput, messageUncheckedCreateWithoutImage_messageInput>
  }

  export type messageUpsertWithoutImage_messageInput = {
    update: XOR<messageUpdateWithoutImage_messageInput, messageUncheckedUpdateWithoutImage_messageInput>
    create: XOR<messageCreateWithoutImage_messageInput, messageUncheckedCreateWithoutImage_messageInput>
    where?: messageWhereInput
  }

  export type messageUpdateToOneWithWhereWithoutImage_messageInput = {
    where?: messageWhereInput
    data: XOR<messageUpdateWithoutImage_messageInput, messageUncheckedUpdateWithoutImage_messageInput>
  }

  export type messageUpdateWithoutImage_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    chatroom?: chatroomUpdateOneWithoutMessageNestedInput
    user?: userUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutImage_messageInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    chatroom_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type guestCreateWithoutInvite_invite_invitedIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutInvite_invite_invitedIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutInvite_invite_invitedIdToguestInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedCreateWithoutInvite_invite_invitedIdToguestInput>
  }

  export type guestCreateWithoutInvite_invite_inviterIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutInvite_invite_inviterIdToguestInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutInvite_invite_inviterIdToguestInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedCreateWithoutInvite_invite_inviterIdToguestInput>
  }

  export type guestUpsertWithoutInvite_invite_invitedIdToguestInput = {
    update: XOR<guestUpdateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedUpdateWithoutInvite_invite_invitedIdToguestInput>
    create: XOR<guestCreateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedCreateWithoutInvite_invite_invitedIdToguestInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutInvite_invite_invitedIdToguestInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutInvite_invite_invitedIdToguestInput, guestUncheckedUpdateWithoutInvite_invite_invitedIdToguestInput>
  }

  export type guestUpdateWithoutInvite_invite_invitedIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutInvite_invite_invitedIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type guestUpsertWithoutInvite_invite_inviterIdToguestInput = {
    update: XOR<guestUpdateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedUpdateWithoutInvite_invite_inviterIdToguestInput>
    create: XOR<guestCreateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedCreateWithoutInvite_invite_inviterIdToguestInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutInvite_invite_inviterIdToguestInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutInvite_invite_inviterIdToguestInput, guestUncheckedUpdateWithoutInvite_invite_inviterIdToguestInput>
  }

  export type guestUpdateWithoutInvite_invite_inviterIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutInvite_invite_inviterIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type image_messageCreateWithoutMessageInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_messageUncheckedCreateWithoutMessageInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_messageCreateOrConnectWithoutMessageInput = {
    where: image_messageWhereUniqueInput
    create: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput>
  }

  export type image_messageCreateManyMessageInputEnvelope = {
    data: image_messageCreateManyMessageInput | image_messageCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type chatroomCreateWithoutMessageInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_member?: chatroom_memberCreateNestedManyWithoutChatroomInput
  }

  export type chatroomUncheckedCreateWithoutMessageInput = {
    id?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutChatroomInput
  }

  export type chatroomCreateOrConnectWithoutMessageInput = {
    where: chatroomWhereUniqueInput
    create: XOR<chatroomCreateWithoutMessageInput, chatroomUncheckedCreateWithoutMessageInput>
  }

  export type userCreateWithoutMessageInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutMessageInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMessageInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
  }

  export type image_messageUpsertWithWhereUniqueWithoutMessageInput = {
    where: image_messageWhereUniqueInput
    update: XOR<image_messageUpdateWithoutMessageInput, image_messageUncheckedUpdateWithoutMessageInput>
    create: XOR<image_messageCreateWithoutMessageInput, image_messageUncheckedCreateWithoutMessageInput>
  }

  export type image_messageUpdateWithWhereUniqueWithoutMessageInput = {
    where: image_messageWhereUniqueInput
    data: XOR<image_messageUpdateWithoutMessageInput, image_messageUncheckedUpdateWithoutMessageInput>
  }

  export type image_messageUpdateManyWithWhereWithoutMessageInput = {
    where: image_messageScalarWhereInput
    data: XOR<image_messageUpdateManyMutationInput, image_messageUncheckedUpdateManyWithoutMessageInput>
  }

  export type image_messageScalarWhereInput = {
    AND?: image_messageScalarWhereInput | image_messageScalarWhereInput[]
    OR?: image_messageScalarWhereInput[]
    NOT?: image_messageScalarWhereInput | image_messageScalarWhereInput[]
    id?: UuidFilter<"image_message"> | string
    image?: StringFilter<"image_message"> | string
    created_at?: DateTimeFilter<"image_message"> | Date | string
    updated_at?: DateTimeFilter<"image_message"> | Date | string
    message_id?: UuidNullableFilter<"image_message"> | string | null
  }

  export type chatroomUpsertWithoutMessageInput = {
    update: XOR<chatroomUpdateWithoutMessageInput, chatroomUncheckedUpdateWithoutMessageInput>
    create: XOR<chatroomCreateWithoutMessageInput, chatroomUncheckedCreateWithoutMessageInput>
    where?: chatroomWhereInput
  }

  export type chatroomUpdateToOneWithWhereWithoutMessageInput = {
    where?: chatroomWhereInput
    data: XOR<chatroomUpdateWithoutMessageInput, chatroomUncheckedUpdateWithoutMessageInput>
  }

  export type chatroomUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_member?: chatroom_memberUpdateManyWithoutChatroomNestedInput
  }

  export type chatroomUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutChatroomNestedInput
  }

  export type userUpsertWithoutMessageInput = {
    update: XOR<userUpdateWithoutMessageInput, userUncheckedUpdateWithoutMessageInput>
    create: XOR<userCreateWithoutMessageInput, userUncheckedCreateWithoutMessageInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutMessageInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutMessageInput, userUncheckedUpdateWithoutMessageInput>
  }

  export type userUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type comboCreateWithoutPostInput = {
    id?: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
    user: userCreateNestedOneWithoutComboInput
  }

  export type comboUncheckedCreateWithoutPostInput = {
    id?: string
    user_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type comboCreateOrConnectWithoutPostInput = {
    where: comboWhereUniqueInput
    create: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput>
  }

  export type comboCreateManyPostInputEnvelope = {
    data: comboCreateManyPostInput | comboCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type commentCreateWithoutPostInput = {
    id?: string
    comment: string
    created_at?: Date | string
    user?: userCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutPostInput = {
    id?: string
    comment: string
    created_at?: Date | string
    user_id?: string | null
  }

  export type commentCreateOrConnectWithoutPostInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput>
  }

  export type commentCreateManyPostInputEnvelope = {
    data: commentCreateManyPostInput | commentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type userCreateWithoutPostInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPostInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPostInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
  }

  export type post_likeCreateWithoutPostInput = {
    id?: string
    user?: userCreateNestedOneWithoutPost_likeInput
  }

  export type post_likeUncheckedCreateWithoutPostInput = {
    id?: string
    user_id?: string | null
  }

  export type post_likeCreateOrConnectWithoutPostInput = {
    where: post_likeWhereUniqueInput
    create: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput>
  }

  export type post_likeCreateManyPostInputEnvelope = {
    data: post_likeCreateManyPostInput | post_likeCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type report_postCreateWithoutPostInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    user?: userCreateNestedOneWithoutReport_postInput
  }

  export type report_postUncheckedCreateWithoutPostInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    user_id?: string | null
  }

  export type report_postCreateOrConnectWithoutPostInput = {
    where: report_postWhereUniqueInput
    create: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput>
  }

  export type report_postCreateManyPostInputEnvelope = {
    data: report_postCreateManyPostInput | report_postCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type comboUpsertWithWhereUniqueWithoutPostInput = {
    where: comboWhereUniqueInput
    update: XOR<comboUpdateWithoutPostInput, comboUncheckedUpdateWithoutPostInput>
    create: XOR<comboCreateWithoutPostInput, comboUncheckedCreateWithoutPostInput>
  }

  export type comboUpdateWithWhereUniqueWithoutPostInput = {
    where: comboWhereUniqueInput
    data: XOR<comboUpdateWithoutPostInput, comboUncheckedUpdateWithoutPostInput>
  }

  export type comboUpdateManyWithWhereWithoutPostInput = {
    where: comboScalarWhereInput
    data: XOR<comboUpdateManyMutationInput, comboUncheckedUpdateManyWithoutPostInput>
  }

  export type comboScalarWhereInput = {
    AND?: comboScalarWhereInput | comboScalarWhereInput[]
    OR?: comboScalarWhereInput[]
    NOT?: comboScalarWhereInput | comboScalarWhereInput[]
    id?: UuidFilter<"combo"> | string
    user_id?: UuidFilter<"combo"> | string
    post_id?: UuidFilter<"combo"> | string
    count?: IntFilter<"combo"> | number
    created_at?: DateTimeFilter<"combo"> | Date | string
    updated_at?: DateTimeFilter<"combo"> | Date | string
  }

  export type commentUpsertWithWhereUniqueWithoutPostInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutPostInput, commentUncheckedUpdateWithoutPostInput>
    create: XOR<commentCreateWithoutPostInput, commentUncheckedCreateWithoutPostInput>
  }

  export type commentUpdateWithWhereUniqueWithoutPostInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutPostInput, commentUncheckedUpdateWithoutPostInput>
  }

  export type commentUpdateManyWithWhereWithoutPostInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutPostInput>
  }

  export type commentScalarWhereInput = {
    AND?: commentScalarWhereInput | commentScalarWhereInput[]
    OR?: commentScalarWhereInput[]
    NOT?: commentScalarWhereInput | commentScalarWhereInput[]
    id?: UuidFilter<"comment"> | string
    comment?: StringFilter<"comment"> | string
    created_at?: DateTimeFilter<"comment"> | Date | string
    post_id?: UuidNullableFilter<"comment"> | string | null
    user_id?: UuidNullableFilter<"comment"> | string | null
  }

  export type userUpsertWithoutPostInput = {
    update: XOR<userUpdateWithoutPostInput, userUncheckedUpdateWithoutPostInput>
    create: XOR<userCreateWithoutPostInput, userUncheckedCreateWithoutPostInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPostInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPostInput, userUncheckedUpdateWithoutPostInput>
  }

  export type userUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type post_likeUpsertWithWhereUniqueWithoutPostInput = {
    where: post_likeWhereUniqueInput
    update: XOR<post_likeUpdateWithoutPostInput, post_likeUncheckedUpdateWithoutPostInput>
    create: XOR<post_likeCreateWithoutPostInput, post_likeUncheckedCreateWithoutPostInput>
  }

  export type post_likeUpdateWithWhereUniqueWithoutPostInput = {
    where: post_likeWhereUniqueInput
    data: XOR<post_likeUpdateWithoutPostInput, post_likeUncheckedUpdateWithoutPostInput>
  }

  export type post_likeUpdateManyWithWhereWithoutPostInput = {
    where: post_likeScalarWhereInput
    data: XOR<post_likeUpdateManyMutationInput, post_likeUncheckedUpdateManyWithoutPostInput>
  }

  export type post_likeScalarWhereInput = {
    AND?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
    OR?: post_likeScalarWhereInput[]
    NOT?: post_likeScalarWhereInput | post_likeScalarWhereInput[]
    id?: UuidFilter<"post_like"> | string
    post_id?: UuidNullableFilter<"post_like"> | string | null
    user_id?: UuidNullableFilter<"post_like"> | string | null
  }

  export type report_postUpsertWithWhereUniqueWithoutPostInput = {
    where: report_postWhereUniqueInput
    update: XOR<report_postUpdateWithoutPostInput, report_postUncheckedUpdateWithoutPostInput>
    create: XOR<report_postCreateWithoutPostInput, report_postUncheckedCreateWithoutPostInput>
  }

  export type report_postUpdateWithWhereUniqueWithoutPostInput = {
    where: report_postWhereUniqueInput
    data: XOR<report_postUpdateWithoutPostInput, report_postUncheckedUpdateWithoutPostInput>
  }

  export type report_postUpdateManyWithWhereWithoutPostInput = {
    where: report_postScalarWhereInput
    data: XOR<report_postUpdateManyMutationInput, report_postUncheckedUpdateManyWithoutPostInput>
  }

  export type report_postScalarWhereInput = {
    AND?: report_postScalarWhereInput | report_postScalarWhereInput[]
    OR?: report_postScalarWhereInput[]
    NOT?: report_postScalarWhereInput | report_postScalarWhereInput[]
    id?: UuidFilter<"report_post"> | string
    report_type?: StringFilter<"report_post"> | string
    content?: StringNullableFilter<"report_post"> | string | null
    created_at?: DateTimeFilter<"report_post"> | Date | string
    post_id?: UuidNullableFilter<"report_post"> | string | null
    user_id?: UuidNullableFilter<"report_post"> | string | null
  }

  export type postCreateWithoutPost_likeInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboCreateNestedManyWithoutPostInput
    comment?: commentCreateNestedManyWithoutPostInput
    user?: userCreateNestedOneWithoutPostInput
    report_post?: report_postCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateWithoutPost_likeInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
    combo?: comboUncheckedCreateNestedManyWithoutPostInput
    comment?: commentUncheckedCreateNestedManyWithoutPostInput
    report_post?: report_postUncheckedCreateNestedManyWithoutPostInput
  }

  export type postCreateOrConnectWithoutPost_likeInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutPost_likeInput, postUncheckedCreateWithoutPost_likeInput>
  }

  export type userCreateWithoutPost_likeInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPost_likeInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPost_likeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPost_likeInput, userUncheckedCreateWithoutPost_likeInput>
  }

  export type postUpsertWithoutPost_likeInput = {
    update: XOR<postUpdateWithoutPost_likeInput, postUncheckedUpdateWithoutPost_likeInput>
    create: XOR<postCreateWithoutPost_likeInput, postUncheckedCreateWithoutPost_likeInput>
    where?: postWhereInput
  }

  export type postUpdateToOneWithWhereWithoutPost_likeInput = {
    where?: postWhereInput
    data: XOR<postUpdateWithoutPost_likeInput, postUncheckedUpdateWithoutPost_likeInput>
  }

  export type postUpdateWithoutPost_likeInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUpdateManyWithoutPostNestedInput
    comment?: commentUpdateManyWithoutPostNestedInput
    user?: userUpdateOneWithoutPostNestedInput
    report_post?: report_postUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateWithoutPost_likeInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    combo?: comboUncheckedUpdateManyWithoutPostNestedInput
    comment?: commentUncheckedUpdateManyWithoutPostNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutPostNestedInput
  }

  export type userUpsertWithoutPost_likeInput = {
    update: XOR<userUpdateWithoutPost_likeInput, userUncheckedUpdateWithoutPost_likeInput>
    create: XOR<userCreateWithoutPost_likeInput, userUncheckedCreateWithoutPost_likeInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPost_likeInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPost_likeInput, userUncheckedUpdateWithoutPost_likeInput>
  }

  export type userUpdateWithoutPost_likeInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPost_likeInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type guestCreateWithoutPraiseInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutPraiseInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutPraiseInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutPraiseInput, guestUncheckedCreateWithoutPraiseInput>
  }

  export type userCreateWithoutPraiseInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutPraiseInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPraiseInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPraiseInput, userUncheckedCreateWithoutPraiseInput>
  }

  export type guestUpsertWithoutPraiseInput = {
    update: XOR<guestUpdateWithoutPraiseInput, guestUncheckedUpdateWithoutPraiseInput>
    create: XOR<guestCreateWithoutPraiseInput, guestUncheckedCreateWithoutPraiseInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutPraiseInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutPraiseInput, guestUncheckedUpdateWithoutPraiseInput>
  }

  export type guestUpdateWithoutPraiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutPraiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type userUpsertWithoutPraiseInput = {
    update: XOR<userUpdateWithoutPraiseInput, userUncheckedUpdateWithoutPraiseInput>
    create: XOR<userCreateWithoutPraiseInput, userUncheckedCreateWithoutPraiseInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutPraiseInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutPraiseInput, userUncheckedUpdateWithoutPraiseInput>
  }

  export type userUpdateWithoutPraiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPraiseInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutRecycle_accountInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    report_post?: report_postCreateNestedManyWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutRecycle_accountInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    report_post?: report_postUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutRecycle_accountInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutRecycle_accountInput, userUncheckedCreateWithoutRecycle_accountInput>
  }

  export type userUpsertWithoutRecycle_accountInput = {
    update: XOR<userUpdateWithoutRecycle_accountInput, userUncheckedUpdateWithoutRecycle_accountInput>
    create: XOR<userCreateWithoutRecycle_accountInput, userUncheckedCreateWithoutRecycle_accountInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutRecycle_accountInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutRecycle_accountInput, userUncheckedUpdateWithoutRecycle_accountInput>
  }

  export type userUpdateWithoutRecycle_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    report_post?: report_postUpdateManyWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutRecycle_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutReport_postInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    block_user_block_user_blockerIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberCreateNestedManyWithoutUserInput
    combo?: comboCreateNestedManyWithoutUserInput
    comment?: commentCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageCreateNestedManyWithoutUserInput
    post?: postCreateNestedManyWithoutUserInput
    post_like?: post_likeCreateNestedManyWithoutUserInput
    praise?: praiseCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountCreateNestedOneWithoutUserInput
    guest?: guestCreateNestedOneWithoutUserInput
  }

  export type userUncheckedCreateWithoutReport_postInput = {
    id?: string
    legal_name: string
    phone_number: string
    created_at?: Date | string
    updated_at?: Date | string
    user_name?: string | null
    introduction?: string | null
    guestId?: string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockerIdTouserInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedCreateNestedManyWithoutUser_block_user_blockedIdTouserInput
    chatroom_member?: chatroom_memberUncheckedCreateNestedManyWithoutUserInput
    combo?: comboUncheckedCreateNestedManyWithoutUserInput
    comment?: commentUncheckedCreateNestedManyWithoutUserInput
    followship_followship_followerIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followerIdTouserInput
    followship_followship_followedIdTouser?: followshipUncheckedCreateNestedManyWithoutUser_followship_followedIdTouserInput
    message?: messageUncheckedCreateNestedManyWithoutUserInput
    post?: postUncheckedCreateNestedManyWithoutUserInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutUserInput
    praise?: praiseUncheckedCreateNestedManyWithoutUserInput
    recycle_account?: recycle_accountUncheckedCreateNestedOneWithoutUserInput
  }

  export type userCreateOrConnectWithoutReport_postInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReport_postInput, userUncheckedCreateWithoutReport_postInput>
  }

  export type postCreateWithoutReport_postInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboCreateNestedManyWithoutPostInput
    comment?: commentCreateNestedManyWithoutPostInput
    user?: userCreateNestedOneWithoutPostInput
    post_like?: post_likeCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateWithoutReport_postInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    user_id?: string | null
    combo?: comboUncheckedCreateNestedManyWithoutPostInput
    comment?: commentUncheckedCreateNestedManyWithoutPostInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutPostInput
  }

  export type postCreateOrConnectWithoutReport_postInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutReport_postInput, postUncheckedCreateWithoutReport_postInput>
  }

  export type userUpsertWithoutReport_postInput = {
    update: XOR<userUpdateWithoutReport_postInput, userUncheckedUpdateWithoutReport_postInput>
    create: XOR<userCreateWithoutReport_postInput, userUncheckedCreateWithoutReport_postInput>
    where?: userWhereInput
  }

  export type userUpdateToOneWithWhereWithoutReport_postInput = {
    where?: userWhereInput
    data: XOR<userUpdateWithoutReport_postInput, userUncheckedUpdateWithoutReport_postInput>
  }

  export type userUpdateWithoutReport_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUpdateManyWithoutUserNestedInput
    combo?: comboUpdateManyWithoutUserNestedInput
    comment?: commentUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUpdateManyWithoutUserNestedInput
    post?: postUpdateManyWithoutUserNestedInput
    post_like?: post_likeUpdateManyWithoutUserNestedInput
    praise?: praiseUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUpdateOneWithoutUserNestedInput
    guest?: guestUpdateOneWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReport_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    legal_name?: StringFieldUpdateOperationsInput | string
    phone_number?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
    block_user_block_user_blockerIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserNestedInput
    block_user_block_user_blockedIdTouser?: block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserNestedInput
    chatroom_member?: chatroom_memberUncheckedUpdateManyWithoutUserNestedInput
    combo?: comboUncheckedUpdateManyWithoutUserNestedInput
    comment?: commentUncheckedUpdateManyWithoutUserNestedInput
    followship_followship_followerIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserNestedInput
    followship_followship_followedIdTouser?: followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserNestedInput
    message?: messageUncheckedUpdateManyWithoutUserNestedInput
    post?: postUncheckedUpdateManyWithoutUserNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutUserNestedInput
    praise?: praiseUncheckedUpdateManyWithoutUserNestedInput
    recycle_account?: recycle_accountUncheckedUpdateOneWithoutUserNestedInput
  }

  export type postUpsertWithoutReport_postInput = {
    update: XOR<postUpdateWithoutReport_postInput, postUncheckedUpdateWithoutReport_postInput>
    create: XOR<postCreateWithoutReport_postInput, postUncheckedCreateWithoutReport_postInput>
    where?: postWhereInput
  }

  export type postUpdateToOneWithWhereWithoutReport_postInput = {
    where?: postWhereInput
    data: XOR<postUpdateWithoutReport_postInput, postUncheckedUpdateWithoutReport_postInput>
  }

  export type postUpdateWithoutReport_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUpdateManyWithoutPostNestedInput
    comment?: commentUpdateManyWithoutPostNestedInput
    user?: userUpdateOneWithoutPostNestedInput
    post_like?: post_likeUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateWithoutReport_postInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    combo?: comboUncheckedUpdateManyWithoutPostNestedInput
    comment?: commentUncheckedUpdateManyWithoutPostNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutPostNestedInput
  }

  export type guestCreateWithoutRewardInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutRewardInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutRewardInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutRewardInput, guestUncheckedCreateWithoutRewardInput>
  }

  export type guestUpsertWithoutRewardInput = {
    update: XOR<guestUpdateWithoutRewardInput, guestUncheckedUpdateWithoutRewardInput>
    create: XOR<guestCreateWithoutRewardInput, guestUncheckedCreateWithoutRewardInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutRewardInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutRewardInput, guestUncheckedUpdateWithoutRewardInput>
  }

  export type guestUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutRewardInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type block_userCreateWithoutUser_block_user_blockerIdTouserInput = {
    id?: string
    created_at?: Date | string
    user_block_user_blockedIdTouser?: userCreateNestedOneWithoutBlock_user_block_user_blockedIdTouserInput
  }

  export type block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput = {
    id?: string
    created_at?: Date | string
    blockedId?: string | null
  }

  export type block_userCreateOrConnectWithoutUser_block_user_blockerIdTouserInput = {
    where: block_userWhereUniqueInput
    create: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput>
  }

  export type block_userCreateManyUser_block_user_blockerIdTouserInputEnvelope = {
    data: block_userCreateManyUser_block_user_blockerIdTouserInput | block_userCreateManyUser_block_user_blockerIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type block_userCreateWithoutUser_block_user_blockedIdTouserInput = {
    id?: string
    created_at?: Date | string
    user_block_user_blockerIdTouser?: userCreateNestedOneWithoutBlock_user_block_user_blockerIdTouserInput
  }

  export type block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput = {
    id?: string
    created_at?: Date | string
    blockerId?: string | null
  }

  export type block_userCreateOrConnectWithoutUser_block_user_blockedIdTouserInput = {
    where: block_userWhereUniqueInput
    create: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput>
  }

  export type block_userCreateManyUser_block_user_blockedIdTouserInputEnvelope = {
    data: block_userCreateManyUser_block_user_blockedIdTouserInput | block_userCreateManyUser_block_user_blockedIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type chatroom_memberCreateWithoutUserInput = {
    chatroom: chatroomCreateNestedOneWithoutChatroom_memberInput
  }

  export type chatroom_memberUncheckedCreateWithoutUserInput = {
    chatroomId: string
  }

  export type chatroom_memberCreateOrConnectWithoutUserInput = {
    where: chatroom_memberWhereUniqueInput
    create: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput>
  }

  export type chatroom_memberCreateManyUserInputEnvelope = {
    data: chatroom_memberCreateManyUserInput | chatroom_memberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type comboCreateWithoutUserInput = {
    id?: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
    post: postCreateNestedOneWithoutComboInput
  }

  export type comboUncheckedCreateWithoutUserInput = {
    id?: string
    post_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type comboCreateOrConnectWithoutUserInput = {
    where: comboWhereUniqueInput
    create: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput>
  }

  export type comboCreateManyUserInputEnvelope = {
    data: comboCreateManyUserInput | comboCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type commentCreateWithoutUserInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post?: postCreateNestedOneWithoutCommentInput
  }

  export type commentUncheckedCreateWithoutUserInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post_id?: string | null
  }

  export type commentCreateOrConnectWithoutUserInput = {
    where: commentWhereUniqueInput
    create: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput>
  }

  export type commentCreateManyUserInputEnvelope = {
    data: commentCreateManyUserInput | commentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type followshipCreateWithoutUser_followship_followerIdTouserInput = {
    id?: string
    created_at?: Date | string
    user_followship_followedIdTouser?: userCreateNestedOneWithoutFollowship_followship_followedIdTouserInput
  }

  export type followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput = {
    id?: string
    created_at?: Date | string
    followedId?: string | null
  }

  export type followshipCreateOrConnectWithoutUser_followship_followerIdTouserInput = {
    where: followshipWhereUniqueInput
    create: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput>
  }

  export type followshipCreateManyUser_followship_followerIdTouserInputEnvelope = {
    data: followshipCreateManyUser_followship_followerIdTouserInput | followshipCreateManyUser_followship_followerIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type followshipCreateWithoutUser_followship_followedIdTouserInput = {
    id?: string
    created_at?: Date | string
    user_followship_followerIdTouser?: userCreateNestedOneWithoutFollowship_followship_followerIdTouserInput
  }

  export type followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput = {
    id?: string
    created_at?: Date | string
    followerId?: string | null
  }

  export type followshipCreateOrConnectWithoutUser_followship_followedIdTouserInput = {
    where: followshipWhereUniqueInput
    create: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput>
  }

  export type followshipCreateManyUser_followship_followedIdTouserInputEnvelope = {
    data: followshipCreateManyUser_followship_followedIdTouserInput | followshipCreateManyUser_followship_followedIdTouserInput[]
    skipDuplicates?: boolean
  }

  export type messageCreateWithoutUserInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    is_read?: boolean
    order?: number
    image_message?: image_messageCreateNestedManyWithoutMessageInput
    chatroom?: chatroomCreateNestedOneWithoutMessageInput
  }

  export type messageUncheckedCreateWithoutUserInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_id?: string | null
    is_read?: boolean
    order?: number
    image_message?: image_messageUncheckedCreateNestedManyWithoutMessageInput
  }

  export type messageCreateOrConnectWithoutUserInput = {
    where: messageWhereUniqueInput
    create: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput>
  }

  export type messageCreateManyUserInputEnvelope = {
    data: messageCreateManyUserInput | messageCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type postCreateWithoutUserInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboCreateNestedManyWithoutPostInput
    comment?: commentCreateNestedManyWithoutPostInput
    post_like?: post_likeCreateNestedManyWithoutPostInput
    report_post?: report_postCreateNestedManyWithoutPostInput
  }

  export type postUncheckedCreateWithoutUserInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
    combo?: comboUncheckedCreateNestedManyWithoutPostInput
    comment?: commentUncheckedCreateNestedManyWithoutPostInput
    post_like?: post_likeUncheckedCreateNestedManyWithoutPostInput
    report_post?: report_postUncheckedCreateNestedManyWithoutPostInput
  }

  export type postCreateOrConnectWithoutUserInput = {
    where: postWhereUniqueInput
    create: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput>
  }

  export type postCreateManyUserInputEnvelope = {
    data: postCreateManyUserInput | postCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type post_likeCreateWithoutUserInput = {
    id?: string
    post?: postCreateNestedOneWithoutPost_likeInput
  }

  export type post_likeUncheckedCreateWithoutUserInput = {
    id?: string
    post_id?: string | null
  }

  export type post_likeCreateOrConnectWithoutUserInput = {
    where: post_likeWhereUniqueInput
    create: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput>
  }

  export type post_likeCreateManyUserInputEnvelope = {
    data: post_likeCreateManyUserInput | post_likeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type praiseCreateWithoutUserInput = {
    id?: string
    is_like: boolean
    created_at?: Date | string
    guest?: guestCreateNestedOneWithoutPraiseInput
  }

  export type praiseUncheckedCreateWithoutUserInput = {
    id?: string
    is_like: boolean
    guest_id?: string | null
    created_at?: Date | string
  }

  export type praiseCreateOrConnectWithoutUserInput = {
    where: praiseWhereUniqueInput
    create: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput>
  }

  export type praiseCreateManyUserInputEnvelope = {
    data: praiseCreateManyUserInput | praiseCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type recycle_accountCreateWithoutUserInput = {
    id?: string
    delete_time: Date | string
  }

  export type recycle_accountUncheckedCreateWithoutUserInput = {
    id?: string
    delete_time: Date | string
  }

  export type recycle_accountCreateOrConnectWithoutUserInput = {
    where: recycle_accountWhereUniqueInput
    create: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
  }

  export type report_postCreateWithoutUserInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    post?: postCreateNestedOneWithoutReport_postInput
  }

  export type report_postUncheckedCreateWithoutUserInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    post_id?: string | null
  }

  export type report_postCreateOrConnectWithoutUserInput = {
    where: report_postWhereUniqueInput
    create: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput>
  }

  export type report_postCreateManyUserInputEnvelope = {
    data: report_postCreateManyUserInput | report_postCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type guestCreateWithoutUserInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    warning?: warningCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutUserInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    warning?: warningUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutUserInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutUserInput, guestUncheckedCreateWithoutUserInput>
  }

  export type block_userUpsertWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput = {
    where: block_userWhereUniqueInput
    update: XOR<block_userUpdateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedUpdateWithoutUser_block_user_blockerIdTouserInput>
    create: XOR<block_userCreateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockerIdTouserInput>
  }

  export type block_userUpdateWithWhereUniqueWithoutUser_block_user_blockerIdTouserInput = {
    where: block_userWhereUniqueInput
    data: XOR<block_userUpdateWithoutUser_block_user_blockerIdTouserInput, block_userUncheckedUpdateWithoutUser_block_user_blockerIdTouserInput>
  }

  export type block_userUpdateManyWithWhereWithoutUser_block_user_blockerIdTouserInput = {
    where: block_userScalarWhereInput
    data: XOR<block_userUpdateManyMutationInput, block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserInput>
  }

  export type block_userScalarWhereInput = {
    AND?: block_userScalarWhereInput | block_userScalarWhereInput[]
    OR?: block_userScalarWhereInput[]
    NOT?: block_userScalarWhereInput | block_userScalarWhereInput[]
    id?: UuidFilter<"block_user"> | string
    created_at?: DateTimeFilter<"block_user"> | Date | string
    blockerId?: UuidNullableFilter<"block_user"> | string | null
    blockedId?: UuidNullableFilter<"block_user"> | string | null
  }

  export type block_userUpsertWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput = {
    where: block_userWhereUniqueInput
    update: XOR<block_userUpdateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedUpdateWithoutUser_block_user_blockedIdTouserInput>
    create: XOR<block_userCreateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedCreateWithoutUser_block_user_blockedIdTouserInput>
  }

  export type block_userUpdateWithWhereUniqueWithoutUser_block_user_blockedIdTouserInput = {
    where: block_userWhereUniqueInput
    data: XOR<block_userUpdateWithoutUser_block_user_blockedIdTouserInput, block_userUncheckedUpdateWithoutUser_block_user_blockedIdTouserInput>
  }

  export type block_userUpdateManyWithWhereWithoutUser_block_user_blockedIdTouserInput = {
    where: block_userScalarWhereInput
    data: XOR<block_userUpdateManyMutationInput, block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserInput>
  }

  export type chatroom_memberUpsertWithWhereUniqueWithoutUserInput = {
    where: chatroom_memberWhereUniqueInput
    update: XOR<chatroom_memberUpdateWithoutUserInput, chatroom_memberUncheckedUpdateWithoutUserInput>
    create: XOR<chatroom_memberCreateWithoutUserInput, chatroom_memberUncheckedCreateWithoutUserInput>
  }

  export type chatroom_memberUpdateWithWhereUniqueWithoutUserInput = {
    where: chatroom_memberWhereUniqueInput
    data: XOR<chatroom_memberUpdateWithoutUserInput, chatroom_memberUncheckedUpdateWithoutUserInput>
  }

  export type chatroom_memberUpdateManyWithWhereWithoutUserInput = {
    where: chatroom_memberScalarWhereInput
    data: XOR<chatroom_memberUpdateManyMutationInput, chatroom_memberUncheckedUpdateManyWithoutUserInput>
  }

  export type comboUpsertWithWhereUniqueWithoutUserInput = {
    where: comboWhereUniqueInput
    update: XOR<comboUpdateWithoutUserInput, comboUncheckedUpdateWithoutUserInput>
    create: XOR<comboCreateWithoutUserInput, comboUncheckedCreateWithoutUserInput>
  }

  export type comboUpdateWithWhereUniqueWithoutUserInput = {
    where: comboWhereUniqueInput
    data: XOR<comboUpdateWithoutUserInput, comboUncheckedUpdateWithoutUserInput>
  }

  export type comboUpdateManyWithWhereWithoutUserInput = {
    where: comboScalarWhereInput
    data: XOR<comboUpdateManyMutationInput, comboUncheckedUpdateManyWithoutUserInput>
  }

  export type commentUpsertWithWhereUniqueWithoutUserInput = {
    where: commentWhereUniqueInput
    update: XOR<commentUpdateWithoutUserInput, commentUncheckedUpdateWithoutUserInput>
    create: XOR<commentCreateWithoutUserInput, commentUncheckedCreateWithoutUserInput>
  }

  export type commentUpdateWithWhereUniqueWithoutUserInput = {
    where: commentWhereUniqueInput
    data: XOR<commentUpdateWithoutUserInput, commentUncheckedUpdateWithoutUserInput>
  }

  export type commentUpdateManyWithWhereWithoutUserInput = {
    where: commentScalarWhereInput
    data: XOR<commentUpdateManyMutationInput, commentUncheckedUpdateManyWithoutUserInput>
  }

  export type followshipUpsertWithWhereUniqueWithoutUser_followship_followerIdTouserInput = {
    where: followshipWhereUniqueInput
    update: XOR<followshipUpdateWithoutUser_followship_followerIdTouserInput, followshipUncheckedUpdateWithoutUser_followship_followerIdTouserInput>
    create: XOR<followshipCreateWithoutUser_followship_followerIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followerIdTouserInput>
  }

  export type followshipUpdateWithWhereUniqueWithoutUser_followship_followerIdTouserInput = {
    where: followshipWhereUniqueInput
    data: XOR<followshipUpdateWithoutUser_followship_followerIdTouserInput, followshipUncheckedUpdateWithoutUser_followship_followerIdTouserInput>
  }

  export type followshipUpdateManyWithWhereWithoutUser_followship_followerIdTouserInput = {
    where: followshipScalarWhereInput
    data: XOR<followshipUpdateManyMutationInput, followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserInput>
  }

  export type followshipScalarWhereInput = {
    AND?: followshipScalarWhereInput | followshipScalarWhereInput[]
    OR?: followshipScalarWhereInput[]
    NOT?: followshipScalarWhereInput | followshipScalarWhereInput[]
    id?: UuidFilter<"followship"> | string
    created_at?: DateTimeFilter<"followship"> | Date | string
    followedId?: UuidNullableFilter<"followship"> | string | null
    followerId?: UuidNullableFilter<"followship"> | string | null
  }

  export type followshipUpsertWithWhereUniqueWithoutUser_followship_followedIdTouserInput = {
    where: followshipWhereUniqueInput
    update: XOR<followshipUpdateWithoutUser_followship_followedIdTouserInput, followshipUncheckedUpdateWithoutUser_followship_followedIdTouserInput>
    create: XOR<followshipCreateWithoutUser_followship_followedIdTouserInput, followshipUncheckedCreateWithoutUser_followship_followedIdTouserInput>
  }

  export type followshipUpdateWithWhereUniqueWithoutUser_followship_followedIdTouserInput = {
    where: followshipWhereUniqueInput
    data: XOR<followshipUpdateWithoutUser_followship_followedIdTouserInput, followshipUncheckedUpdateWithoutUser_followship_followedIdTouserInput>
  }

  export type followshipUpdateManyWithWhereWithoutUser_followship_followedIdTouserInput = {
    where: followshipScalarWhereInput
    data: XOR<followshipUpdateManyMutationInput, followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserInput>
  }

  export type messageUpsertWithWhereUniqueWithoutUserInput = {
    where: messageWhereUniqueInput
    update: XOR<messageUpdateWithoutUserInput, messageUncheckedUpdateWithoutUserInput>
    create: XOR<messageCreateWithoutUserInput, messageUncheckedCreateWithoutUserInput>
  }

  export type messageUpdateWithWhereUniqueWithoutUserInput = {
    where: messageWhereUniqueInput
    data: XOR<messageUpdateWithoutUserInput, messageUncheckedUpdateWithoutUserInput>
  }

  export type messageUpdateManyWithWhereWithoutUserInput = {
    where: messageScalarWhereInput
    data: XOR<messageUpdateManyMutationInput, messageUncheckedUpdateManyWithoutUserInput>
  }

  export type postUpsertWithWhereUniqueWithoutUserInput = {
    where: postWhereUniqueInput
    update: XOR<postUpdateWithoutUserInput, postUncheckedUpdateWithoutUserInput>
    create: XOR<postCreateWithoutUserInput, postUncheckedCreateWithoutUserInput>
  }

  export type postUpdateWithWhereUniqueWithoutUserInput = {
    where: postWhereUniqueInput
    data: XOR<postUpdateWithoutUserInput, postUncheckedUpdateWithoutUserInput>
  }

  export type postUpdateManyWithWhereWithoutUserInput = {
    where: postScalarWhereInput
    data: XOR<postUpdateManyMutationInput, postUncheckedUpdateManyWithoutUserInput>
  }

  export type postScalarWhereInput = {
    AND?: postScalarWhereInput | postScalarWhereInput[]
    OR?: postScalarWhereInput[]
    NOT?: postScalarWhereInput | postScalarWhereInput[]
    id?: UuidFilter<"post"> | string
    picture?: StringFilter<"post"> | string
    content?: StringFilter<"post"> | string
    created_at?: DateTimeFilter<"post"> | Date | string
    updated_at?: DateTimeFilter<"post"> | Date | string
    user_id?: UuidNullableFilter<"post"> | string | null
  }

  export type post_likeUpsertWithWhereUniqueWithoutUserInput = {
    where: post_likeWhereUniqueInput
    update: XOR<post_likeUpdateWithoutUserInput, post_likeUncheckedUpdateWithoutUserInput>
    create: XOR<post_likeCreateWithoutUserInput, post_likeUncheckedCreateWithoutUserInput>
  }

  export type post_likeUpdateWithWhereUniqueWithoutUserInput = {
    where: post_likeWhereUniqueInput
    data: XOR<post_likeUpdateWithoutUserInput, post_likeUncheckedUpdateWithoutUserInput>
  }

  export type post_likeUpdateManyWithWhereWithoutUserInput = {
    where: post_likeScalarWhereInput
    data: XOR<post_likeUpdateManyMutationInput, post_likeUncheckedUpdateManyWithoutUserInput>
  }

  export type praiseUpsertWithWhereUniqueWithoutUserInput = {
    where: praiseWhereUniqueInput
    update: XOR<praiseUpdateWithoutUserInput, praiseUncheckedUpdateWithoutUserInput>
    create: XOR<praiseCreateWithoutUserInput, praiseUncheckedCreateWithoutUserInput>
  }

  export type praiseUpdateWithWhereUniqueWithoutUserInput = {
    where: praiseWhereUniqueInput
    data: XOR<praiseUpdateWithoutUserInput, praiseUncheckedUpdateWithoutUserInput>
  }

  export type praiseUpdateManyWithWhereWithoutUserInput = {
    where: praiseScalarWhereInput
    data: XOR<praiseUpdateManyMutationInput, praiseUncheckedUpdateManyWithoutUserInput>
  }

  export type recycle_accountUpsertWithoutUserInput = {
    update: XOR<recycle_accountUpdateWithoutUserInput, recycle_accountUncheckedUpdateWithoutUserInput>
    create: XOR<recycle_accountCreateWithoutUserInput, recycle_accountUncheckedCreateWithoutUserInput>
    where?: recycle_accountWhereInput
  }

  export type recycle_accountUpdateToOneWithWhereWithoutUserInput = {
    where?: recycle_accountWhereInput
    data: XOR<recycle_accountUpdateWithoutUserInput, recycle_accountUncheckedUpdateWithoutUserInput>
  }

  export type recycle_accountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recycle_accountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    delete_time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_postUpsertWithWhereUniqueWithoutUserInput = {
    where: report_postWhereUniqueInput
    update: XOR<report_postUpdateWithoutUserInput, report_postUncheckedUpdateWithoutUserInput>
    create: XOR<report_postCreateWithoutUserInput, report_postUncheckedCreateWithoutUserInput>
  }

  export type report_postUpdateWithWhereUniqueWithoutUserInput = {
    where: report_postWhereUniqueInput
    data: XOR<report_postUpdateWithoutUserInput, report_postUncheckedUpdateWithoutUserInput>
  }

  export type report_postUpdateManyWithWhereWithoutUserInput = {
    where: report_postScalarWhereInput
    data: XOR<report_postUpdateManyMutationInput, report_postUncheckedUpdateManyWithoutUserInput>
  }

  export type guestUpsertWithoutUserInput = {
    update: XOR<guestUpdateWithoutUserInput, guestUncheckedUpdateWithoutUserInput>
    create: XOR<guestCreateWithoutUserInput, guestUncheckedCreateWithoutUserInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutUserInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutUserInput, guestUncheckedUpdateWithoutUserInput>
  }

  export type guestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    warning?: warningUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    warning?: warningUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type guestCreateWithoutWarningInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseCreateNestedManyWithoutGuestInput
    reward?: rewardCreateNestedManyWithoutGuestInput
    user?: userCreateNestedOneWithoutGuestInput
  }

  export type guestUncheckedCreateWithoutWarningInput = {
    id?: string
    password: string
    user_name: string
    avatar: string
    verify_photo: string
    verify: boolean
    created_at?: Date | string
    updated_at?: Date | string
    email?: string
    emailOTP?: boolean
    activity_activity_subscriberIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_subscriberIdToguestInput
    activity_activity_guestIdToguest?: activityUncheckedCreateNestedManyWithoutGuest_activity_guestIdToguestInput
    invite_invite_invitedIdToguest?: inviteUncheckedCreateNestedOneWithoutGuest_invite_invitedIdToguestInput
    invite_invite_inviterIdToguest?: inviteUncheckedCreateNestedManyWithoutGuest_invite_inviterIdToguestInput
    praise?: praiseUncheckedCreateNestedManyWithoutGuestInput
    reward?: rewardUncheckedCreateNestedManyWithoutGuestInput
    user?: userUncheckedCreateNestedOneWithoutGuestInput
  }

  export type guestCreateOrConnectWithoutWarningInput = {
    where: guestWhereUniqueInput
    create: XOR<guestCreateWithoutWarningInput, guestUncheckedCreateWithoutWarningInput>
  }

  export type guestUpsertWithoutWarningInput = {
    update: XOR<guestUpdateWithoutWarningInput, guestUncheckedUpdateWithoutWarningInput>
    create: XOR<guestCreateWithoutWarningInput, guestUncheckedCreateWithoutWarningInput>
    where?: guestWhereInput
  }

  export type guestUpdateToOneWithWhereWithoutWarningInput = {
    where?: guestWhereInput
    data: XOR<guestUpdateWithoutWarningInput, guestUncheckedUpdateWithoutWarningInput>
  }

  export type guestUpdateWithoutWarningInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUpdateManyWithoutGuestNestedInput
    reward?: rewardUpdateManyWithoutGuestNestedInput
    user?: userUpdateOneWithoutGuestNestedInput
  }

  export type guestUncheckedUpdateWithoutWarningInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    user_name?: StringFieldUpdateOperationsInput | string
    avatar?: StringFieldUpdateOperationsInput | string
    verify_photo?: StringFieldUpdateOperationsInput | string
    verify?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    emailOTP?: BoolFieldUpdateOperationsInput | boolean
    activity_activity_subscriberIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestNestedInput
    activity_activity_guestIdToguest?: activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestNestedInput
    invite_invite_invitedIdToguest?: inviteUncheckedUpdateOneWithoutGuest_invite_invitedIdToguestNestedInput
    invite_invite_inviterIdToguest?: inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestNestedInput
    praise?: praiseUncheckedUpdateManyWithoutGuestNestedInput
    reward?: rewardUncheckedUpdateManyWithoutGuestNestedInput
    user?: userUncheckedUpdateOneWithoutGuestNestedInput
  }

  export type chatroom_memberCreateManyChatroomInput = {
    userId: string
  }

  export type messageCreateManyChatroomInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    sender_id?: string | null
    is_read?: boolean
    order?: number
  }

  export type chatroom_memberUpdateWithoutChatroomInput = {
    user?: userUpdateOneRequiredWithoutChatroom_memberNestedInput
  }

  export type chatroom_memberUncheckedUpdateWithoutChatroomInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type chatroom_memberUncheckedUpdateManyWithoutChatroomInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type messageUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUpdateManyWithoutMessageNestedInput
    user?: userUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateManyWithoutChatroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type activityCreateManyGuest_activity_subscriberIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    guestId?: string | null
  }

  export type activityCreateManyGuest_activity_guestIdToguestInput = {
    id?: string
    content: string
    route: string
    param: string
    subscriber_avatar: string
    post_image: string
    type: string
    created_at?: Date | string
    subscriberId?: string | null
  }

  export type inviteCreateManyGuest_invite_inviterIdToguestInput = {
    id?: string
    created_at?: Date | string
    invitedId?: string | null
  }

  export type praiseCreateManyGuestInput = {
    id?: string
    is_like: boolean
    user_id?: string | null
    created_at?: Date | string
  }

  export type rewardCreateManyGuestInput = {
    id?: string
    amount: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type activityUpdateWithoutGuest_activity_subscriberIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_activity_guestIdToguest?: guestUpdateOneWithoutActivity_activity_guestIdToguestNestedInput
  }

  export type activityUncheckedUpdateWithoutGuest_activity_subscriberIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type activityUncheckedUpdateManyWithoutGuest_activity_subscriberIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guestId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type activityUpdateWithoutGuest_activity_guestIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_activity_subscriberIdToguest?: guestUpdateOneWithoutActivity_activity_subscriberIdToguestNestedInput
  }

  export type activityUncheckedUpdateWithoutGuest_activity_guestIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type activityUncheckedUpdateManyWithoutGuest_activity_guestIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    route?: StringFieldUpdateOperationsInput | string
    param?: StringFieldUpdateOperationsInput | string
    subscriber_avatar?: StringFieldUpdateOperationsInput | string
    post_image?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inviteUpdateWithoutGuest_invite_inviterIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest_invite_invitedIdToguest?: guestUpdateOneWithoutInvite_invite_invitedIdToguestNestedInput
  }

  export type inviteUncheckedUpdateWithoutGuest_invite_inviterIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type inviteUncheckedUpdateManyWithoutGuest_invite_inviterIdToguestInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type praiseUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutPraiseNestedInput
  }

  export type praiseUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type praiseUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rewardUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_messageCreateManyMessageInput = {
    id?: string
    image: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type image_messageUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_messageUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type image_messageUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    image?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comboCreateManyPostInput = {
    id?: string
    user_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type commentCreateManyPostInput = {
    id?: string
    comment: string
    created_at?: Date | string
    user_id?: string | null
  }

  export type post_likeCreateManyPostInput = {
    id?: string
    user_id?: string | null
  }

  export type report_postCreateManyPostInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    user_id?: string | null
  }

  export type comboUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutComboNestedInput
  }

  export type comboUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comboUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type post_likeUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneWithoutPost_likeNestedInput
  }

  export type post_likeUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type post_likeUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_postUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneWithoutReport_postNestedInput
  }

  export type report_postUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_postUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userCreateManyUser_block_user_blockerIdTouserInput = {
    id?: string
    created_at?: Date | string
    blockedId?: string | null
  }

  export type block_userCreateManyUser_block_user_blockedIdTouserInput = {
    id?: string
    created_at?: Date | string
    blockerId?: string | null
  }

  export type chatroom_memberCreateManyUserInput = {
    chatroomId: string
  }

  export type comboCreateManyUserInput = {
    id?: string
    post_id: string
    count: number
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type commentCreateManyUserInput = {
    id?: string
    comment: string
    created_at?: Date | string
    post_id?: string | null
  }

  export type followshipCreateManyUser_followship_followerIdTouserInput = {
    id?: string
    created_at?: Date | string
    followedId?: string | null
  }

  export type followshipCreateManyUser_followship_followedIdTouserInput = {
    id?: string
    created_at?: Date | string
    followerId?: string | null
  }

  export type messageCreateManyUserInput = {
    id?: string
    message?: string
    created_at?: Date | string
    updated_at?: Date | string
    chatroom_id?: string | null
    is_read?: boolean
    order?: number
  }

  export type postCreateManyUserInput = {
    id?: string
    picture: string
    content: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type post_likeCreateManyUserInput = {
    id?: string
    post_id?: string | null
  }

  export type praiseCreateManyUserInput = {
    id?: string
    is_like: boolean
    guest_id?: string | null
    created_at?: Date | string
  }

  export type report_postCreateManyUserInput = {
    id?: string
    report_type: string
    content?: string | null
    created_at?: Date | string
    post_id?: string | null
  }

  export type block_userUpdateWithoutUser_block_user_blockerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_block_user_blockedIdTouser?: userUpdateOneWithoutBlock_user_block_user_blockedIdTouserNestedInput
  }

  export type block_userUncheckedUpdateWithoutUser_block_user_blockerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userUncheckedUpdateManyWithoutUser_block_user_blockerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userUpdateWithoutUser_block_user_blockedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_block_user_blockerIdTouser?: userUpdateOneWithoutBlock_user_block_user_blockerIdTouserNestedInput
  }

  export type block_userUncheckedUpdateWithoutUser_block_user_blockedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type block_userUncheckedUpdateManyWithoutUser_block_user_blockedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blockerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatroom_memberUpdateWithoutUserInput = {
    chatroom?: chatroomUpdateOneRequiredWithoutChatroom_memberNestedInput
  }

  export type chatroom_memberUncheckedUpdateWithoutUserInput = {
    chatroomId?: StringFieldUpdateOperationsInput | string
  }

  export type chatroom_memberUncheckedUpdateManyWithoutUserInput = {
    chatroomId?: StringFieldUpdateOperationsInput | string
  }

  export type comboUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postUpdateOneRequiredWithoutComboNestedInput
  }

  export type comboUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type comboUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: StringFieldUpdateOperationsInput | string
    count?: IntFieldUpdateOperationsInput | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type commentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postUpdateOneWithoutCommentNestedInput
  }

  export type commentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type commentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    comment?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type followshipUpdateWithoutUser_followship_followerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_followship_followedIdTouser?: userUpdateOneWithoutFollowship_followship_followedIdTouserNestedInput
  }

  export type followshipUncheckedUpdateWithoutUser_followship_followerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type followshipUncheckedUpdateManyWithoutUser_followship_followerIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followedId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type followshipUpdateWithoutUser_followship_followedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_followship_followerIdTouser?: userUpdateOneWithoutFollowship_followship_followerIdTouserNestedInput
  }

  export type followshipUncheckedUpdateWithoutUser_followship_followedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type followshipUncheckedUpdateManyWithoutUser_followship_followedIdTouserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    followerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUpdateManyWithoutMessageNestedInput
    chatroom?: chatroomUpdateOneWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    image_message?: image_messageUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type messageUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    chatroom_id?: NullableStringFieldUpdateOperationsInput | string | null
    is_read?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
  }

  export type postUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUpdateManyWithoutPostNestedInput
    comment?: commentUpdateManyWithoutPostNestedInput
    post_like?: post_likeUpdateManyWithoutPostNestedInput
    report_post?: report_postUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    combo?: comboUncheckedUpdateManyWithoutPostNestedInput
    comment?: commentUncheckedUpdateManyWithoutPostNestedInput
    post_like?: post_likeUncheckedUpdateManyWithoutPostNestedInput
    report_post?: report_postUncheckedUpdateManyWithoutPostNestedInput
  }

  export type postUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    picture?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type post_likeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post?: postUpdateOneWithoutPost_likeNestedInput
  }

  export type post_likeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type post_likeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type praiseUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: guestUpdateOneWithoutPraiseNestedInput
  }

  export type praiseUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type praiseUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    is_like?: BoolFieldUpdateOperationsInput | boolean
    guest_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type report_postUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: postUpdateOneWithoutReport_postNestedInput
  }

  export type report_postUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type report_postUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    report_type?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    post_id?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}